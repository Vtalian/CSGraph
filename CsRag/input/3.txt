第3章  程序的转换及机器级表示

1.IA-32 /x86-64指令系统概述
ISA 规定了机器级程序的格式和行为，因而先介绍相应的 Intel 指令集体系结构。x86 是 Intel 开发的一种处理器体系结构的泛称。该系列中较早期的处理器名称以数字来表示，并以“86”结尾，包括 Intel 8086、80286、i386 和 i486 等，因此其架构被称为“x86”。由于数字并 不能作为注册商标， 因此 Intel 及其竞争者均对新一代处理器使用了可注册的名称， 如 Pentium 、PentiumPro, Core 2、Core i7 等。现在 Intel 把 32 位 x86 架构的名称 x86-32 改称为 IA-32,全名 为“Intel Architecture, 32-bit”。后来，由 AMD 首先提出了一个 Intel 指令集的 64 位版本，命名 为“x86-64”。它在 IA-32 的基础上对寄存器的宽度和个数、浮点运算指令等进行了扩展，并 加入了一些新的特性，指令能够直接处理长度为 64 位的数据。后来 AMD 将其更名为 AMD64, 而 Intel 称其为lntel64。
Intel 最早推出的 64 位架构是基于超长指令字(Very Long Instruction Word, VLIW)技术的 IA-64体系结构，Intel 称其为显式并行指令计算机(Explicitly Parallel Instruction Computer, EPIC)0Intel 的安腾(Itanium)和安腾 2 (Itanium 2)处理器分别在 2000 年和 2002 年问世， 它们是 IA-64 体系结构的最早的具体实现。安腾体系结构试图完全脱离 IA-32 CISC 架构的束 缚，最大限度地提高软件和硬件之间的协同性，力求将处理器的处理能力和编译软件的功能结 合起来，在指令中将并行执行信息以明显的方式告诉硬件。但是，这种思路被证明是不易实现 的，而且，因为安腾釆用了全新的指令集，虽然可以在兼容模式中执行 IA-32 代码，但是性能 不太好，因而安腾并没有在市场上获得成功。AMD 公司利用 Intel 公司在 IA-64 架构上的失败，抢先在 2003 年推出了兼容 IA-32 的 64 位 版本指令集 X86-64,它在保留 IA-32 指令集的基础上，增加了新的数据格式及其操作指令，寄 存器长度扩展为64 位，并将通用寄存器个数从 8 个扩展到 16 个。通过 x86-64, AMD 获得了以 前属于 Intel 的一些高端市场。AMD 后来将 x86-64 更名为 AMD64。
Intel 发现用 1A-64 直接替换 IA-32 行不通，于是，在 2004 年推出了 1A32-EM64T (Extended Memory 64 Technology, 64 位内存扩展技术)，它支持 x86-64 指令集。Intel 为了表 zK EM64T 的 64 位模式特点，又使其与 IA-64 有所区别，2006 年开始把 EM64T 改名为 Intel 64。因此，Intel 64 是与 IA-64 完全不同的体系结构，它与 IA-32 和 AMD64 兼容。
目前，AMD 的 64 位处理器架构 AMD64 和 Intel 的 64 位处理器架构 Intel 64 都支持 x86-64 指令集， 因而，通常人们直接使用 x86-64 代表 64 位 Intel 指令集架构。x86-64 有时也简称 为 x64。

1.1  IA-32的寄存器组织
不考虑 I/O 指令，IA-32 指令的操作数有三类：立即数、寄存器操作数和存储器操作数。 立即数就在指令中，无需指定其存放位置。寄存器操作数需要指定操作数所在寄存器的编号， 例如，图 3. 1 中的指令指定了源操作数寄存器的编号为 001。当操作数为存储单元内容时，需 要指定操作数所在存储单元的地址，例如，图 3. 1 中的指令指定了目的操作数的存储单元地址 为 BX 和 DI 两个寄存器的内容相加再减
6,得到的是一个 16 位偏移地址，它和相应的段寄存 器内容进行特定的运算就可以得到操作数所在的存储单元的地址。当然，图 3.1 给出的是早期 8086 实地址模式下的指令，因而存储地址计算方式比较简单。现在，IA-32 引入了保护模式, 采用的是段页式存储管理方式，因而存储地址计算变得比较复杂。
IA-32 指令中用到的寄存器主要分为定点寄存器组、浮点寄存器栈和多媒体扩展寄存器组。 下面分别介绍 IA-32 的定点寄存器组、浮点寄存器栈和多媒体扩展寄存器组。



1.1.1定点寄存器组
因为 IA-32 由最初的 8086/8088 向后兼容扩展而来，因此，寄存器的结构也体现了逐步扩展的特点。图1-1 给出了定点(整数)寄存器组的结构。
图 1-1  IA-32 的定点寄存器组
从图 1-1 可以看出，IA-32 中的定点寄存器中共有 8 个通用寄存(General-Purpose Register,GPR)、两个专用寄存器和 6 个段寄存器°定京通用寄存器是指没有专门用途的可以存放 各类定点操作数的寄存器。
8 个通用寄存器的长度为 32 位，其中 EAX、EBX、ECX 和 EDX 主要用来存放操作数，可 根据操作数长度是字节、字还是双字来确定存取寄存器的最低 8 位、最低 16 位还是全部 32 位。ESP、EBP、ESI 和EDI 主要用来存放变址值或指针，可以作为 16 位或 32 位寄存器使用， 其中，ESP 是建杙指寄存器，EBP 是基址指针寄存器
两个专用寄存器分别是基址指针寄存器EIP 和标志基址指针寄存器EFLAGS。EIP 从 16 位的IP 扩展 而来，指令指针寄存器 IP (Instruction Pointer)与程序计数器 PC 是功能完全一样的寄存器，名 称不同而已，在本教材中两者通用，它们都是用来存放即将执行指令的地址的寄存器。EFLAGS 从 16 位的 FLAGS 扩展而来。实地址模式时，使用 16 位的 IP 和 FLAGS 寄存器，保护 模式时，使用 32 位的 EIP 和 EFLAGS 寄存器。
两个专用寄存器分别是基址指针寄存器EIP 和标志基址指针寄存器EFLAGS。EIP 从 16 位的IP 扩展 而来，指令指针寄存器 IP (Instruction Pointer)与程序计数器 PC 是功能完全一样的寄存器，名 称不同而已，在本教材中两者通用，它们都是用来存放即将执行指令的地址的寄存器。EFLAGS 从 16 位的 FLAGS 扩展而来。实地址模式时，使用 16 位的 IP 和 FLAGS 寄存器，保护 模式时，使用 32 位的 EIP 和 EFLAGS 寄存器。
EFLAGS 寄存器主要用于记录机器的状态和控制信息，如图 1-2 所示。
图 1-2 状态标志寄存器 EFLAGS
EFLAGS 寄存器的第 0 ~ 11 位中的 9 个标志位是从最早的 8086 微处理器延续下来的，它们 按功能可以分为 6 个条件标志和 3 个控制标志。其中，条件标志用来存放运行的状态信息，由 硬件自动设定， 条件标志有时也称为条件码；控制标志由软件设定,用于中断响应、串操作和 单步执行等控制。
常用条件标志的含义说明如下。
0F( Overflow Flag)：溢出标志。反映带符号数的运算结果是否超过相应数值范围。例 如， 字节运算结果超出-128 ~+127 或字运算结果超出-32 768 - +32 767 时，称为“溢出”， 此时 OF = 1； 否则 OF=0。
SF(Sign Flag)：符号标志。反映带符号数运算结果的符号。负数时，SF = 1 ；否则 SF=O。ZF(Zero Flag)：零标志。反映运算结果是否为 0。若结果为 0, ZF = 1 ；否则 ZF=O。
CF( Carry Flag)：进位标志。反映无符号整数加(减)运算后的进(借)位情况。有 进(借)位则CF = 1;否则 CF=O。
综上可知，OF 和 SF 对于无符号数运算来说没有意义，而 CF 对于带符号整数运算来说没 有意义。控制标志的含义说明如下。
DF(Direction Flag):方向标志。用来确定串操作指令执行时变址寄存器 SI(ESI)和 DI (EDI) 中的内容是自动递增还是递减。若 DF = 1,则为递减；否则为递增。可用 std 指令和 cld 指令分别将 DF 置 1 和清 0。
IF( Interrupt Flag)：中断允许标志。若 IF = 1,表示允许响应中断；否则禁止响应中断。 IF 对非屏蔽中断和内部异常不起作用，仅对外部可屏蔽中断起作用。可用 sti 指令和 cli 指令分 别将 IF 置1 和清 0。
TF(Trap Flag)：陷阱标志。用来控制单步执行操作。TF = 1 时，CPU 按单步方式执行 指令， 此时，可以控制在每执行完一条指令后，就把该指令执行得到的机器状态(包括各寄存 器和内存单元的值等)显示出来。没有专门的指令用于该标志的修改，但可用栈操作指令 (如 pushPpushfd 和 popf/popfd) 来改变其值。
EFLAGS 寄存器的第 12-31 位中的其他状态或控制信息是从 80286 以后逐步添加的。包括 用于表示当前程序的 I/O 特权级(IOPL)、当前任务是否是嵌套任务(NT)、当前处理器是否 处于虚拟 8086 方式(VM) 等一些状态或控制信息。
6 个段寄存器都是 16 位,CPU 根据段寄存器的内容，与寻址方式确定的有效地址一起， 并结合其他用户不可见的内部寄存器，生成操作数所在的存储地址。

1.1.2 浮点寄存器栈和多媒体扩展寄存器组
IA-32 的浮点处理架构有两种。一种是与 x86 配套的浮点协处理器 x87 架构，它是一种栈 结构 FPU,x87 中进行运算的浮点数来源于浮点寄存器栈的栈顶；另一种是由 MMX 发展而来 的 SSE 架构，釆用单指令多数据(Single Instruction Multi Data, SIMD)技术，SIMD 技术可实 现单条指令同时并行处理多个数据元素的功能，其操作数来源于专门新增的 8 个 128 位寄存器 XMM0~XMM7。

小贴士
FPU (Float Point Unit,浮点运算器)是专用于浮点运算的处理器，以前的 FPU 是单 独的芯片， 在 80486 之后，Intel 把 FPU 集成在 CPU 之内。
MMX 是 MultiMedia extensions (多媒体扩展)的缩写。MMX 指令于 1997 年首次运用 于 P54C Pentium 处理器，称之为多能奔腾。MMX 技术主要是指在 CPU 中加入了特地为视 频信号(video signal)、音频信号(audio signal)以及图像处理(graphical manipulation) 而设计的 57 条指令，因此，MMX CPU极大地提高了多媒体(如立体声、视频、三维动画 等)处理能力。x87 FPU 中有 8 个数据寄存器，每个 80 位。此外，还有控制寄存器、状态寄存器和标记寄存器各一个,它们的长度都是 16 位。数据寄存器被组织成一个浮点寄存器栈,栈顶记为 ST(O),下一个元素是 ST(1),再下一个是ST(2),以此类推。栈的大小是 8,当栈被装满时，可访问的元素为 ST(0) -ST(7)。控制寄存器主要用于指定浮点处理单元的舍入方式及最大有 效数据位数(即精度)，Intel 浮点处理器的默认精度是 64 位，即指 80 位扩展精度浮点数；状 态寄存器用来记录比较结果，并标记运算是否溢出、是否产生错误等，此外还记录了数据寄存 器栈的栈顶位置；标记寄存器指出了 8 个数据寄存器各自的状态， 比如是否为空、是否可用、 是否为零、是否是特殊值(如 NaN、+8、-8)等。
SSE 指令集由 MMX 指令集发展而来。MMX 指令使用的 8 个 64 位寄存器 MMO ~ MM7 借用 了 x87 FPU 中 8 个 80 位浮点数据寄存器 ST(0) ~ ST(7),每个 MMX 寄存器实际上是对应 80 位 浮点数据寄存器中 64 位尾数所占的位，因此，每条 MMX 指令可以同时处理 8 个字节，或 4 个 字，或 2 个双字，或一个 64 位的数据。由于 MMX 指令并没有带来 3D 游戏性能的显著提升， 1999 年 Intel 公司在 Pentium III CPU 产品中首推 SSE 指令集，后来又陆续推出了 SSE2、SSE3、 SSSE3 和 SSE4 等采用 SIMD 技术的指令集，这些统称为 SSE 指令集。SSE 指令集兼容 MMX 指令，并通过 SIMD 技术在单个时钟周期内并行处理多个浮点数来有效提高浮点运算速度。因为 在 MMX 技术中借用了 x87 FPU 的 8 个浮点寄存器，导致了 x87 浮点运算速度的降低，因而 SSE 指令集增加了 8 个128 位的 SSE 指令专用的多媒体扩展通用寄存器 XMM0~XMM7。这样，SSE指令的寄存器位数是 MMX 指令寄存器位数的两倍，因而一条 SSE 指令可以同时并行处理 16 个 字节，或 8 个字，或 4 个双字(32 位整数或单精度浮点数)，或两个四字的数据，而且从 SSE2 开始，还支持 128 位整数运算或同时并行处理两个 64 位双精度浮点数。
综上所述，IA-32 中的通用寄存器共有三类：8 个 8/16/32 位定点通用寄存器、8 个 MMX 指令/x87 FPU使用的 64 位/80 位寄存器 MMO/ST(O) ~ MM7/ST(7)、8 个 SSE 指令使用的 128 位寄存器 XMM0~XMM7。

图1-3  IA-32 中通用寄存器的编号

1.1.3 EFLAGS寄存器
IA-32中标志寄存器的名称为EFLAGS，其大小为4个字节(32位)，由原来的16位FLAGS寄存器扩展而来。EFLAGS寄存器的每位都有意义，每位的值或为1或为0，代表On/Off或True/False，如下图所示：

其中有些位由系统直接设定，有些位则根据程序命令的执行结果设置。其中,与程序调试相关的状态标识包括:零标识(ZF),溢出标识(OF),进位标识(CF)和符号标识(SF)，含义如下:
(1)零标识(ZF)。若算数或逻辑运算结果为0,则ZF值为1,否则ZF值为0。
(2)溢出标识(OF)。有符号整数溢出时,OF置为1;最高有效位(MSB)改变时,OF置为1。
(3)进位标识(CF)。无符号整数溢出时,CF置为1。
(4)符号标识(SF)。等于运算结果的最高位(即有符号整数的符号位);0表示正数, 1表示负数。
(5)方向标识(DF)。另一个需要注意的标识是控制标识(DF),该标识位为方向标识,用于控制串处理指令处理信息的方向。当DF为1时,每次操作后使变址寄存器ESI和EDI减小,这样就使串处理从高地址向低地址方向处理;当DF为0时,处理方向相反。DF标识由STD指令置位,由CLD指令清除。
(6)陷阱标识(TF)和中断允许标识(IF)。它们是与中断和异常相关的标识位。如果TF标识位置为1,CPU将在执行完每条指令后产生单步中断,调试器使用该特性在调试程序时进行单步执行,该标识位还可用于检查调试器是否正常运行如果IF位置位,则CPU在收到中断请求后,应该对中断请求进行响应处理。

1.1.4 指令指针寄存器
指令指针寄存器(EIP)存放当前代码段中将被执行的下一条指令的线性地址偏移。程序运行时，CPU根据CS段寄存器和EIP寄存器中的地址偏移读取下一条指令，将指令传送到指令缓冲区，并将EIP寄存器的值自增，增大的大小即被读取指令的字节数。EIP寄存器的值一般不能直接修改，EIP寄存器的更改有两种途径：一是通过特殊的跳转和调用/返回指令JMP、Jcc、CALL、RET等；二是通过中断或异常进行修改。

1.1.5 段寄存器（Segment Register）
IA-32中存在6个16位的段寄存器: CS、SS、DS、ES、FS和GS。分别用于存储保护模式下逻辑地址中的段选择器。
(1)代码段寄存器：存放应用程序代码所在的段的段描述符索引(该段描述符中包含代码段的线性基址)。CPU在获取将要执行的下一条指令时，使用CS寄存器找到代码段的线性基址，再与EIP中的线性地址偏移量相加，从而得到下一条指令的线性地址。
(2)栈段寄存器：存放栈段的段描述符索引(该段描述符中包含栈段的线性基址)。
(3)数据段寄存器：存放数据段的段描述符索引(这些描述符中均包含数据段的线性基址)。DS数据段含有程序使用的大部分数据，ES、FS和GS分别对应IA-32中引入的附加数据段。ES数据段可以为某些串指令存放目的数据，FS数据段寄存器可用于计算结构化异常处理、线程环境块、进程环境块等地址。

1.2保护模式下的寻址方式
根据指令给定信息得到操作数或操作数地址的方式称为寻址方式。图 3.4 给出了 IA-32 中 的各种寻址方式。其中，立即寻址指指令中直接给出操作数;寄存器寻址指指令中给出操作数 所在的寄存器的编号。除了立即寻址和寄存器寻址外，其他寻址方式下的操作数都在存储单元 中，称为存储器操作数。
存储器操作数的寻址方式与微处理器的工作模式有关。IA-32 处理器主要有两种工作模式， 即实地址模式和保护模式。实地址模式是为与 8086/8088 兼容而设置的，在加电或复位时处于这一模式。此模式下的 存储管理、中断控制以及应用程序运行环境等都与 8086/8088 相同。其最大寻址空间为 1MB, 32 条地址线中的 A31 - A20不起作用，存储管理采用分段方式，每段的最大地址空间为 64KB, 物理地址由段地址乘以 16 加上偏移地址构成，其中段地址位于段寄存器中，偏移地址用来指 定段内一个存储单元。例如，当前指令地址为(CS)<<4 + (IP),其中 CS( Code Segment)为代码段寄存器,用于存放当前代码段地址，IP 寄存器中存放的是当前指令在代码段内的偏移地址这里，（CS）和（IP）分别表示寄存器 CS 和 IP 中的内容。内存区 OOOOOH -003FFH 存放 中断向量表，共存放256 个中断向量，采用 8086/8088 的中断类型和中断处理方式。有关中 断、中断向量和中断向量表等概念，详见第 7 章和第 8 章相关内容。
保护模式的引入是为了实现在多任务方式下对不同任务使用的虚拟存储空间进行完全的隔 离，以保证不同任务之间不会相互破坏各自的代码和数据。保护模式是 80286 以上高档微处理 器最常用的工作模式。系统启动后总是先进入实地址模式，对系统进行初始化，然后转入保护模式进行操作。在保护模式下，处理器采用虚拟存储器管理方式。
IA-32 采用段页式虚拟存储管理方式，CPU 首先通过分段方式得到线性地址 LA,再通过分 页方式实现从线性地址到物理地址的转换。有关虚拟存储器管理、段页式、分段、分页、线性 地址、物理地址等概念及其实现原理将在第 6 章的 6.5 节和 6.6 节详细介绍。
图 1-3 给出了 1A-32 在保护模式下的各种寻址方式，其中，存储器操作数的访问过程需要 计算线性地址 LA,图中除了最后一行（相对寻址）计算的是转移目标指令的线性地址以外， 其他的都是指操作数的线性地址。相对寻址的线性地址与 PC（即 EIP 或 IP）有关，而操作数的 线性地址与 PC 无关.它取决于某个段寄存器的内容和有效地址。根据段寄存器的内容能够确 定操作数所在的段在某个存储空间的起始地址，而有效地址则给出了操作数所在段的偏移 地址。

图 1-4  1A-32 的寻址方式
注： LA：线性地址（X）：X 的内容 SR：段寄存器 PC：程序计数器 R：寄存器 A：指令中给定地址段的位移量B：基址寄存器 I：变址寄存器 S：比例系数
从图 3.4 中可以看出，在存储器操作数的情况下，指令必须显式或隐式地给出以下信息。段寄存器 SR （可用段前缀显式给出，也可缺省使用默认段寄存器）。8/16/32 位位移量 4 （由位移量字段显式给出，例如，图 3.1 中的字段 disp8）。基址寄存器 B （由相应字段显式给出，可指定为任一通用寄存器）。变址寄存器 I （由相应字段显式给出，可指定除 ESP 外的任一通用寄存器）。有比例变址和非比例变址两种变址方式。比例变址时,变址值等于变址寄存器内容乘以世 例系数 S（也称为比例因子），S 的含义为操作数的字节个数，在 IA-32 中，S 的取值可以是 1、 2、4 或 8。例如，对数组元素访问时，若数组元素的类型为 short,则比例系数就是 2；若数组 元素类型为 float,则比例系数就是 4。IA-32 提供的“基址加位移”、“基址加变址加位移”等。这些复杂的存储器操作数寻址方式，主要是为了指令能够方便地访问到数组和结构等复合数据 结构内的元素。非比例变址相当于比例系数为 1 的比例变址情况,也即，变址值就是变址寄存 器的内容，无需乘以比例系数。
有效地址由指令中给出的寻址方式来确定如何计算。例如，对于 Intel 格式的汇编指令 “moveax, [ ebp + esi * 4 + 1000H] " (AT&T 格式为 “mov4096( %ebp,%esi ,4) , %eax”)，其源 操作数的寻址方式为“基址加比例变址加位移”，因此，有效地址通过将基址寄存器 EBP 的内 容、变址值(变址寄存器 ESI 的内容乘以比例系数 4)和位移量 1000H 三者相加得到。

1.3 IA-32机器指令格式
与大多数 ISA 一样，IA-32 提供了数据传送、算术和逻辑运算、程序流程控制等常用指令 类型。下面分别介绍这几类常用指令类型。
在 1A-32 中，大部分指令并不需要区分其操作数是什么类型，只把操作数当成一个 0/1 序 列来处理， 因而，机器指令中只要再有相应的字段能够区分操作数的长度即可，例如，在 图 3.1 中的位 W 可指出操作数是 8 位还是 16 位。对于 8086/8088 来说，因为只有 8 位和 16 位 两种长度，因此用一位就行，但是， 发展到 IA-32,已经有 8 位（字节）、16 位（字）、32 位 （双字）等不同长度，因而用来表示操作数长度的字段 W 至少要有 2 位。在对应的汇编指令 中，通过在指令助记符后面加一个长度后缀，或通过专门的数据长度指示符来指出操作数长 度。IA-32 由 16 位架构发展而来，因此，Intel 最初规定一个字为 16 位，因而 32 位为双字。
IA-32 中有些指令需要区分操作数类型，通常由指令操作码来区分指令操作数是带符号整 数、无符号整数还是浮点数。例如，浮点运算指令处理的都是浮点数，乘法指令 imul 的操作 数是带符号整数，乘法指令 mul 的操作数是无符号整数。
高级语言中的表达式最终是通过指令指定的运算来实现的，表达式中出现的变量或常数就 是指令中指定的操作数，因而高级语言所支持的数据类型与指令中指定的操作数类型之间有密 切的关系。下面以 C 语言和 IA-32 指令系统为例，说明高级语言与指令系统之间在数据类型方 面是如何对应的。
C 语言程序中的基本数据类型主要有以下几类。
（1）指针或地址：用来表示字符串或其他数据区域的指针或存储地址，可声明为 char*等 类型，其宽度为 32 
位，对应 IA-32 中的双字。
（2）序数、位串等：用来表示序号、元素个数、元素总长度、位串等的无符号数，可声明为 unsigned、char、unsigned short[int]、unsigned[int] unsigned long[ int]（括号中的 int 可省略）类 型， 分别对应 IA-32 中的字节、字、双字和双字。因为 1A-32 是 32 位架构，所以，编译器把 long 型数据定义为 32 位。ISOC99 规定 long long 型数据至少是 64 位，而 IA-32 中没有能处理 64 位数 据的指令，因而编译器大多将 unsigned long long 型数据运算转换为多条 32 位运算指令来实现。
（3）带符号整数：它是 C 语言中运用最广泛的基本数据类型，可声明为 char、short [int]、 int、long[int]类型，分别对应 IA-32 中的字节、字、双字和双字，用补码表示。与对待 unsigned long long数据一样，编译器将 long long 型数据运算转换为多条 32 位运算指令来实现。
（4）浮点数：用来表示实数，可声明为 float, double 和 long double 类型，分另 U 采用 IEEE 754 的单精度、双精度和扩展精度标准表示。long double 类型是 ISO C99 中新引入的，对于许多处 理器和编译器来说，它等价于 double 类型，但是由于与 x86 处理器配合的协处理器 x87 中使用了深度为 8 的 80 位的浮点寄存器栈，对于 Intel 兼容机来说，GCC 釆用了 80 位的“扩展精度” 格式表示。x87 中定义的 80 位扩展浮点格式包含 4 个字段：1 位符号位 s、15 位阶码 e （偏置常 数为 16 383）、
1 位显式首位有效位（explicit leading significant bit）丿和 63 位尾数/。Intel 采用 的这种扩展浮点数格式与 IEEE 754 规定的单精度和双精度浮点数格式的一个重要的区别是, 它没有隐藏位，有效位数共 64 位。GCC 为了提高 long double 浮点数的访存性能，将其存储为 12 个字节（即 96 位，数据访问分 32 位和 64 位两次读写），其中前两个字节不用。图1-5 给出了 C 语言基本数据类型和 IA-32 操作数长度之间的对应关系。

图1-5 C 语言基本数据类型和 IA-32 操作数长度之间的对应关系

GCC 生成的汇编代码中的指令助记符大部分都有长度后缀，例如，传送指令可以有 movb（字节传送）、movw（字传送）、movl（双字传送）等，这里，指令助记符最后的'b，、’w'和 '1'是长度后缀。从表3.1 中可看出，双字整数和双精度浮点数的长度后缀都一样。因为已经 通过指令操作码区分了是浮点数还是整数，所以长度后缀相同不会产生歧义。在微软 MASMI 具生成的 Intel 汇编格式中，并不用长度后缀来表示操作数长度，而是直接通过寄存器的名称 和长度指示符 PTR 等来区分操作数长度，有关信息可以查看微软和 Intel 的相关资料。

1.4寄存器传送语言 RTL

1.5 Linux汇编语言简介
作为最基本的编程语言之一，汇编语言虽然应用的范围不算很广，但重要性 却勿庸置疑，因为它能够完成许多其它语言所无法完成的功能。就拿Linux内核来讲，虽然绝大部分代码是用C语言编写的，但仍然不可避免地在某些关键地方使用了汇编代码，其中主要是在Linux的启动部分。由于这部分代码与硬件的关系非常密切，即使是C语言也会有些力不从心，而汇编语言则能够很好扬长避短，最大限度地发挥硬件的性能。
汇编语言直接同计算机的底层软件甚至硬件进行交互，它具有如下一些优点：
●	能够直接访问与硬件相关的存储器或I/O端口；
●	能够不受编译器的限制，对生成的二进制代码进行完全的控制；
●	能够对关键代码进行更准确的控制，避免因线程共同访问或者硬件设备共享引起的死锁；
●	能够根据特定的应用对代码做最佳的优化，提高运行速度；
●	能够最大限度地发挥硬件的功能。
同时还应该认识到，汇编语言是一种层次非常低的语言，它仅仅高于直接手 工编写二进制的机器指令码，因此不可避免地存在一些缺点：
●	编写的代码非常难懂，不好维护；
●	很容易产生bug，难于调试；
●	只能针对特定的体系结构和处理器进行优化；
●	开发效率很低，时间长且单调。
Linux下用汇编语言编写的代码具有两种不同的形式。第一种是完全的汇编代码，指的是整个程序全部用汇编语言编写。尽管是完全的汇编代码，Linux平台下的汇编工具也吸收了C语言的长处，使得程序员可以使用#include、#ifdef等预处理指令，并能够通过宏定义来简化代码。第二种是内嵌的汇编代码，指的 是可以嵌入到C语言程序中的汇编代码片段。虽然ANSI的C语言标准中没有关于内嵌汇编代码的相应规定，但各种实际使用的C编译器都做了这方面的扩充，这其中当然就包括Linux平台下的GCC。
1.5.1 汇编语言的格式
汇编语言是一个大小写不敏感的语言，mov和Mov一样，ax和AX也是一样。
1.5.1.2 标号与名字
所有出现在英文冒号之前的都是标号，标号会在编译的时候自动替换为地址。也就是说在写如下命令的时候：
again:
    ...
loop again
这个again将会被自动替换为again标签所在的地址。
1.5.1.3. 助记符
本质是伪指令，将会被编译器翻译。例如在数据段声明数据的时候可以给如下定义：
string db 'hello world!', 0dh, 0ah, '$'
这里的string就是一个可加可不加的助记符，方便后续我们能够找到该位置。例如两条伪指令：
mov dx, offset string   #获取string的偏移地址
mov dx, seg string     #获取string的段地址
1.5.1.4 操作符和参数
操作符和参数才是严格意义上的汇编部分，参数之间应该由英文逗号分隔。
1.5.1.5 注释
以英文分号开头，后续所有内容都是注释类容。翻译时，将会跳过注释这段内容。
1.5.1.6 保留字（不分大小写）
指令助记符，如 MOV、ADD 和 MUL；
寄存器名称；
伪指令，告诉汇编器如何汇编程序；
属性，提供变量和操作数的大小与使用信息。例如 BYTE、WORD、DB；
运算符，在常量表达式中使用；
预定义符号，比如 @data，它在汇编时返回常量的整数值；
其他

1.5.2 段
1.5.2.1 概述
段是程序最重要的东西。一段二进制的数字（对于CPU来说数据和指令本质都是二进制数字，没有任何区别）放在一起叫做一个段。这个段可以是数据，可以是代码，也可以是代码+数据。而这个段仅仅只是存在逻辑上的，大部分情况由系统对这些段进行管理，可能把一堆段放到一起。虽然物理上这一系列段连续起来了，但是逻辑上这系列的段应该是分开的。
在汇编语言中定义了如下四个段：
代码段；
堆栈段；
数据段；
附加段；
并且分别用了四个寄存器来存储四个段的首地址：CS（代码段）、SS（堆栈段）、DS（数据段）、ES（附加段）。以及三个专用的寄存器来存储偏移地址：IP（代码段）、SP（堆栈段）、DI（附加段）。
所以一个数据/指令所在的位置应该是：段首地址+偏移地址。
1.5.2.2 段定义
xxx segment [定位] [组合] [段字] ['类别'] 	#段开始，声明一个叫做xxx的段；
   ...        	#对于段的描述；
xxx end       	#结束xxx段声明；
（1）段定位属性
Byte：段开始为下一个可用的字节地址(xxxx xxxxB)，属性值为1；
Word：段开始为下一个可用的偶数地址(xxxx xxx0B)，属性值为2；
Dword：段开始为下一个可用的4倍数地址(xxxx xx00B)，属性值为4；
Para：段开始为下一个可用的节地址(xxxx 0000B)，属性值为16；
Page：段开始为下一个可用的页地址(0000 0000B)，属性值为256；
简单来说就是强迫对齐。简化段默认会采用word，堆栈段默认采用para定义。
（2）段组合属性
Private：本段与其他段没有逻辑关系，不与其他段进行合并。每段都有自己的段地址，根据书写的顺序与伪指令要求的摆放。完整段默认采用此方式；
Public：连接程序把本段与其他同名同类型的段相邻摆放，然后为所段制定一个共同的物理段地址。这是简化段默认采用的方式；
Stack：堆栈的一部分，所有的堆栈段将会默认合并，按照public的方式；
Common：连接程序把所有同名同类型的逻辑段指定同一个物理的段地址，这样可以方便数据共享，避免繁琐的跨段调用。
（3）段字属性
为了支持32位操作系统而设计的。
（4）段类别
指定段是用来干什么的，分为三类。'code'、'data'、'stack'。分别表示代码段、数据段、堆栈段。必须带有英文单引号书写。方便连接程序进行段组合。
（5）段的描述
-直接使用代码
直接用一行代码独占一行，就可以声明一行。
-数据描述
以下两种方式都是数据描述：
string db 'hello world!', 0dh, 0ah, '$'
arr   db 01h, 02h, 03h, 04h
代码和数据是可以混合起来描述一个段的，这也是为什么段可以是数据+代码，但是并不建议这么使用。程序是逐行执行的，千万不能上面一行是代码，也不是跳转指令，下一行就是数据，鬼知道这串数据翻译过去会是什么代码。一般情况都是建议数据最好单独放在一个段，代码放一个段，堆栈放一个段。
其基本模式如下：
[助记符] (数据类型) 数据
db	字节，1字节；
dw	字，2字节；
dd	双字，4字节；
df	三字，6字节；
dq	四字，8字节；
dt	10字节；
如：
db 1
dw 1
这两个都是1，但是他们是不一样的，一个占用的大小空间是1字节，一个是2字节。而偏移地址1对应的是1字节，所以在遍历的时候，对于db只用+1，dw这种就应该+2。对于dd应该+3，以此类推。
在字符串定义的时候，一定要注意末尾的'$'，该符号是字符串的结束符号。 你可以通过DOS命令输出单个字符来输出这个字符。但是字符串里该字符对于DOS系统是字符串的结尾符。
0ah：下移一行；
0dh：回到行首。
-占用大小
很多时候我们只是想分配一个空间而不想去填充内容，例如栈的定义的时候，我们只想分配空间，具体的数据应该等到push的时候再来说明。
如此就可以用如下指令：
db 127 dup(0)
上面的代码就分配了127个db类型，初始值为0的空间，注意不是说变量。尽量保证声明空间是2的次方倍数，但是又不能超过64KB。关于地址对齐有个非常有意思的现象，观察64位的windows系统，你会发现文件大小和占用空间在kb上基本不相同，占用空间都是4kb的整数倍。
其基本语法如下：
[助记符] (数据类型) 个数 sup(初始值)
这里的初始值不仅能用于第三类，也可以用于上面的第二类——数据描述。
（6）一个标准的完整段定义
datas segment		;此处输入数据段代码
datas ends

stacks segment ;此处输入堆栈段代码
	  db 128 dup (0)
stacks ends

codes segment
	assume cs:codes,ds:datas,ss:stacks
	start:
	      mov    ax, datas
	      mov    ds, ax

              ...        ;代码

	      mov    ax,4c00h
	      int    21h
codes ends
end start
这只是一个参考模板。段的定义是随心所欲的，只要不发生冲突，不违反规范。段的名字也是随心所欲的，这里取datas、stacks、codes只是提醒程序员。
对于堆栈段，尽量都要预分配一个合适的空间大小，这里一定要注意。
assume cs:codes,ds:datas,ss:stacks
这条伪指令的作用，就是告诉CPU，cs是什么，ds是什么，ss是什么。但是请记住，assume指令只会给cs、ss赋值，并不会给ds赋值。
所以我们后面要在程序的开头写这样子的代码：
mov    ax, datas
mov    ds, ax
来将datas这个段首地址赋值给ds。
这里还有一条重要的伪指令
start:
这个东西就是告诉CPU，IP偏移地址在这个地方。
最后有一段现在无法理解的代码：
mov    ax,4c00h
int     21h
这个是告诉系统，程序结束了。参数就是ax，发起的中断向量号是21h。
所有伪指令是不会留到exe中的，在翻译的过程中，就已经被处理掉了。像assume这种就会直接被放到文件头里面去。
1.5.3 一个最简单的汇编程序
AT&T格式 
#hello.s
.data							#数据段声明
msg：.string "Hello, world!\n" 	#要输出的字符串 
len = . - msg					#字串长度
.text								#代码段声明
.global _start					#指定入口函数

_start：	          				#在屏幕上显示一个字符串
movl $1en,%edx 				#参数三：字符串长度 
movl $msg,%ecx  				#参数二：要显示的字符串 
movl $1,%ebx    				#参数一：文件描述符(stdout) 
movl $4,%eax 					#系统调用号(sys write)
int $0x80						#调用内核功能
								#退出程序 
movl $0,%ebx					#参数一：退出代码
movl $1,%eax					#系统调用号(sys exit)
int  $0x80						#调用内核功能
上述代码调用Linux内核提供的sys write来显示一个字符串，然后再调用sys_exit退出程序。在Linux内核源文件include/asm-i386/unistd.h中，可以找到所有系统调用的定义。
1.5.3.1 Linux汇编工具
Linux平台下的汇编工具虽然种类很多，但同DOS/Windows—样，最基本的仍然是汇编器、连接器和调试器。
(1).汇编器
汇编器(assembler)的作用是将用汇编语言编写的源程序转换成二进制形式的目标代码。Linux平台的标准汇编器是GAS，它是GCC所依赖的后台汇编工具，通常包含在binutils软件包中。GAS使用标准的AT&T汇编语法，可以用来汇编用AT&T格式编写的程序：
$as -o hello.o hello.s
Linux平台上另一个经常用到的汇编器是NASM，它提供了很好的宏指令功能，并能够支持相当多的目标代码格式，包括bin、a.out、coff、elf、rdf等。NASM采用的是人工编写的语法分析器，因而执行速度要比GAS快很多，但是是它使用的是Intel汇编语法。
(2).链接器
由汇编器产生的目标代码是不能直接在计算机上运行的，它必须经过链接器的处理才能生成可执行代码。链接器通常用来将多个目标代码连接成一个可执行代码，这样可以先将整个程序分成几个模块来单独开发，然后才将它们组合（链接）成一个应用程序。Linux使用Id作为标准的链接程序，它同样也包含在binutils软件包中。汇编程序在成功通过GAS或NASM的编译并生成目标代码后，就可以使用Id将其链接成可执行程序：
$ld -s -o hello hello.o 
-s会删除掉所有的符号信息。
(3).调试器
Linux下调试汇编代码既可以用GDB、DDD这类通用的调试器，也可以使用专门用来调试汇编代码的 ALD(Assembly Language Debugger)。
从调试的角度来看，使用GAS的好处是可以在生成的目标代码中包含符号表(symbol table)，这样就可以使用GDB和DDD来进行源码级的调试了。要在生成的可执行程序中包含符号表，可以采用下面的方式进行编译和链接：
$as -gstabs -o hello.o hello.s
$ld -o hello hell.o
执行as命令时带上参数-gstabs可以告诉汇编器在生成的目标代码中加上符号表。同时需要注意的是，在用Id命令进行链接时不要加上-s参数，否则目标代码中的符号表在链接时会被删去。
1.6 IA-32汇编指令系统
1.6.1 汇编指令
汇编指令有六部分构成，如下图：

其中，Prefix指令前缀，可选字段；Opand操作码，必有的内容；Mod R/M操作数辅助说明，可选字段；SIB，Mod R/M辅助说明，可选字段，但是出现Mod R/M 这个必须有；Displacement操作数作为内存地址时用来表示位移，可选项Immediate立即数。
(1)指令前缀prefix大小为一个字节，用来辅助说明指令的具体功能，例如66：81FE 4746 CMP SI,474中“66”就是指令前缀，后面跟一个：。
(2)操作码opand，必有字节,大小为1到3字节。
(3)Mod R/M说明操作数的寻址方式，包括寄存器选择、内存操作数的偏移等等，大小为一个字节，由三部分组成，分别为 Mod（字节前两位），Reg（字节中间三位），R/M(字节后三位)。
(4)SIB，大小为一个字节，也是用来辅助操作数寻址的，一般用于辅助Mod R/M。当出现基址加变址寻址或者基址寻址时要用到。

1.6.2 操作数格式
注：LA线性地址；(X)X的内容；SR段寄存器；PC程序计数器；R寄存器。
A：指令中给定地址段的位移量 B：基址寄存器  I：变址寄存器 S：比例系数。
IA-32汇编指令举例
 80483f4:       55                 	push	%ebp
 80483f5:       89 e5               	mov  	%esp,%ebp
 80483f7:       83 ec 28             	sub   	$0x28,%esp
 80483fa:       c7 45 f4 00 00 00 00 	movl   	$0x0,-0xc(%ebp)
 8048401:       eb 18               	jmp    	804841b <f1+0x27>
 8048403:       b8 10 85 04 08    	mov    	$0x8048510,%eax
 8048408:       8b 55 f4             mov    	-0xc(%ebp),%edx
 804840b:       89 54 24 04          mov    	%edx,0x4(%esp)
 804840f:        89 04 24            mov    	%eax,(%esp)
第一条MOV指令
89e5          mov     %esp,%ebp
对应机器码 1000 1001 1110 1001。第1个字节前6位是操作码，D=0表示reg为源操作数，W=1表示数据类型是字。第2个字节前2位mod=11表示是寄存器寻址，没有位移量。接着3位reg=101表示寄存器编号是ebp，因为mod=11，所以后3位001代表寄存器编号esp。
第二条MOV指令
B810850408        mov     $0x8048510,%eax
对应机器码 1011 1000 0001 0000 1000 0101 0000 0100 0000 1000。第1字节前4位是操作码。W=1表示传递的数据类型是字，后3位代表寄存器编号EAX(000)。第2-5字节表示数据，如果w=1则是16位的数据。
第三条MOV指令
8B55f4      mov     -0xc(%ebp),%edx
对应机器码 1000 1011 0101 0101 1111 0100。第1字节前7位是操作码，第8位W=1表示传递的数据类型是字。第2字节前2位，mod=01表示是存储器寻址，8位位移量。reg=010表示寄存器编号是edx。mod=01 r/m=101对应的是[ebp]+disp8，8位位移量。W=1、mod=01，第3字节为8位位移量0xf4。
第四条MOV指令
890424      mov     %eax,(%esp)
对应机器码 1000 1011 0000 0100 0010 0100。查看mov指令，89表示寄存器到存储器，第1字节前7位是操作码，第8位W=1表示传递的数据类型是字。第2字节前2位，mod=00表示是存储器寻址，没有位移量。reg=000表示寄存器编号是eax。mod=00 r/m=100对应的是[--][--]，表示后面的是SIB字节。第3字节前2位，SS=00表示比例因子0。Index=100不表示寄存器编号，对应none，base=100表示寄存器编号esp。

1.6.3 IA-32汇编指令系统

                                      如图所示

1.7 实验：IA32汇编语言初步
1.7.1 汇编语言-定点加法指令
采用eax、ebx、ecx、edx四个寄存器存放数据10、20、30、40，编程完成10+20+30+40，结果存放在eax，写出完整的可执行汇编程序代码，并采用gdb调试，查看寄存器结果。（截图给出代码、在gdb上的调试与运行结果）

作业截图4 add.s源代码
1.7.1.1 汇编、链接、调试：
$as -gstabs -o test.o test.s 
$ld -o test test.o 
$gdb test
GNU gdb 5.1.1
Copyright 2002 Free Software Foundation， Inc.
GDB is free software， covered by the GNU General Public License， and you are welcome to change it and/or distribute copies of it under certain conditions.
Type "show copying" to see the conditions.
There is absolutely no warranty for GDB. Type "show warranty" for details.
This GDB was configured as "i386-suse-linux".
(gdb) l
1	#test.s
2	.text						#代码段声明
3	.global  _start      		#指定入口函数
4	_start:   					#在屏幕上显示一个字符串
5		movl $10,%eax		#立即数5送入寄存器eax
6		movl $20,%ebx		#立即数8送入寄存器ecx
7		movl $30,%ecx		#立即数8送入寄存器ecx	
8		movl $40,%edx		#立即数8送入寄存器ecx
9		addl %ebx,%eax		#5+8的结果送入寄存器eax
10		addl %ecx,%eax 
11		addl %edx,%eax 
12							#退出程序
13		movl $0,%ebx			#参数一：退出代码
14		movl $1,%eax			#系统调用号（sys exit）
15		int  $0x80       	#调用内核功能10
(gdb)
（1）设置断点，查看寄存器内容：
10
(gdb) b	8
Breakpoint 1 at 0x804805e: file test.s. line 8.
(gdb) r
Sterting progrmr /rool/ex08/test
Breakpoint 1._ start () at lest.s:8
8						add  %ecx.%eax 	=5+8的结果送入寄存器eax .
（2）单步执行，查看寄存器结果：
(gdb) info register
eax		0x5		5
ecx		0x8		8
edx		0x0		0
ebx		0x0		0
esp		0xbfffe7f0	0xbfffe7f0
ebp		0x0		0
esi		0x0		0
edi		0x0		0
eip		0x804805e	0x804805e <_ start+10>
eflags	0x200212 [ AF IF ID]
cs		0x73	115
ss		0x78	123
ds		0x7b	123
es		0x7b	123
fs		0x0		0
gs		0x0		0
(gdb) n
13			movl S0，%ebx  #参数一，退出代码	
(gdb) info regcister
eax		0xd		13
ecx		0x8		8
edx		0x0		0
ebx		0x0		0
esp		0xbfffe7f0		0xbfffe7f0
ebp		0x0		0x0		
esi		0x0		0
edi		0x0		0
eip		0x8048060		0x80-48060 <_ start+l2>
eflags	0x200202 [ IF ID ]
cs		0x73	115
ss		0x78	123
ds		0x7b	123
es		0x7b	123
fs		0x0		0
gs		0x0		0
(gdb)

作业截图5 add.s调试运行结果

1.7.2 汇编语言-传送指令
假设有以下程序：
#include <stdio.h>
int main(){
char val=10; 
int *ptr;
*ptr=20;
(1)val=(char)*ptr;
(2)*ptr=(int)val;
return 0;
}
1.7.2.1 编译并反汇编程序，找到加下划线1、2两行的关键汇编指令，截图并解释说明。
1.7.2.3 如果val和*ptr分别是以下类型的呢？

1.7.3、汇编语言-传送及定点运算指令
.text				#代码段声明
.global _start		#指定入口函数

_start:
movl $0x12345678，%eax
movl $0x12345678，%ebx
movl $0x804806d， %edi
movl $0x4，%ecx
movb $0x1234，%al
movl $0x4050，%eax
movb (%edi， %ecx)， %ah
movb $-17， (%esp)
movl %eax， -12(%esp)

movb $-128, %al 
negb %al
notb %al
movw $-32768, %ax 
negw %ax
notw %ax
movl $-2147483648, %eax
negl %eax
notl %eax
movl $10, %eax
negl %eax
notl %eax
movb $0, %al
negb %al
notb %al

movl $0，%ebx
movl $1，%eax
int   $0x80

1.7.3.1 为1-10行程序添加注释，说明操作数的寻址方式；
1.7.3.2 编译以上代码，编译命令为as -gstabs test1.s -o test1.o。查看是否有警告信息，根据警告提示改正代码重新编译。（截图给出编译出错信息及改进的代码行）

作业截图6 add.s编译出错信息

作业截图7 add.s改进的代码行
将目标文件链接为可执行文件，命令为ld test1.o -o test1。
1.7.3.4 进入gdb调试环境，采用如下步骤进行调试。
（1）查看代码，命令为l（L的小写，不是1）；
（2）设置断点，命令为b n(n为movl $0x12345678，%ebp代码所在的行，具体指根据查看代码结果得到)（给出截图）

作业截图8 进入调试环境
（3）运行代码，命令为r。程序会在movl $0x12345678，%ebp这停下来，此时该代码未被执行，前一行代码已执行完毕。用p /x $eax查看前一代码执行完后EAX的值，也可用info registers命令查看所有寄存器值。（给出截图）

 作业截图9 查看寄存器值
（4）用n命令单步执行，并查看相应寄存器和内存的值，查看寄存器值的命令为p /x $寄存器名，第9和10行运行后查看内存的命令分别为x /x $esp和x /x $esp-12，截图记录结果。

作业截图10 单步执行
（5）调试程序，查看指令11-25行执行结果和标志寄存器中标志位，填写下表。

1.7.4、汇编语言-定点加减运算指令
用以下程序验证加减法运算及其对标志寄存器的影响。
#include "stdio.h" 
void main( ) { 
unsigned int x=2147483647;
unsigned int y=2147483649;
unsigned int z1=x-y;
unsigned int z2=x+y;
int m=x;
int n=y;
int k1=m-n;
int k2=m+n;
} 
1.7.4.1 手工计算x、y、m、n、z1、z2、k1、k2及eflag 中OF/CF/SF/ZF的值，再与机器中的对应值对照。 
1.7.4.2 写出对应汇编程序中对应的加减法汇编指令。 
1.7.5、汇编语言-定点乘除运算指令
用以下程序验证乘除法运算及其对标志寄存器的影响。
#include "stdio.h" 
void main( ) { 
unsigned int x=6;
unsigned int y=10;
unsigned int z1=x*y;
unsigned int z2=x/y;
int m=6;
int n=-2147483637;
int k1=m*n;
int k2=m/n;
} 
1.7.5.1 手工计算x、y、m、n、z1、z2、k1、k2及Eflag 中OF/CF/SF/ZF的值，再与机器中的对应值对照。 
1.7.5.2 写出对应汇编程序中对应的加减法汇编指令。 

思考题：
汇编中往往有以下程序段：
movl	$80,-8(%ebp) 
movl -8(%ebp), %eax
movl %eax,4(%esp)
……
movl	%eax,-4(%ebp) 	
movl	-4(%ebp),%eax
2-3行是否可以优化成一行movl -8(%ebp),4(%esp)？5-6行有意义么？可以优化掉么？

                                    
    APPENIDIX  	F    
汇编程序格式
F 1 汇编语言的格式
汇编语言是一个大小写不敏感的语言，mov和Mov一样，ax和AX也是一样。
1.1 标号与名字
所有出现在英文冒号之前的都是标号：
标号是由用户自己定义的，最长不超过31字节的名字；
只能包含字母、数字、'$'、'?'、'@'，这五类字符；
不能以数字为开头；
不能是保留字；
标号必须唯一；
标号会在编译的时候自动替换为地址。也就是说在写如下命令的时候：
again:
    ...
loop again
这个again将会被自动替换为again标签所在的地址。
1.2 助记符
本质也是伪指令，将会被编译器翻译。助记符的命名规则同标号。
例如在数据段声明数据的时候可以给如下定义
string db 'hello world!', 0dh, 0ah, '$'
这里的string就是一个可加可不加的助记符。这个只是为了方便后续我们能够找到该位置。例如两条伪指令：
mov dx, offset string   #获取string的偏移地址
mov dx, seg string     #获取string的段地址
1.3 操作符和参数
操作符和参数才算是严格意义上的汇编部分。
参数之间应该由英文逗号分隔。
x86的架构每条语句不一定等长，ARM架构每条语句等长。
1.4 注释
以英文分号开头，后续所有内容都是注释类容。翻译时，将会跳过注释这段内容。
1.5 保留字（不分大小写）
指令助记符，如 MOV、ADD 和 MUL；
寄存器名称；
伪指令，告诉汇编器如何汇编程序；
属性，提供变量和操作数的大小与使用信息。例如 BYTE、WORD、DB；
运算符，在常量表达式中使用；
预定义符号，比如 @data，它在汇编时返回常量的整数值；
其他

F 2 段
2.1 概述
段是程序最重要的东西。一段二进制的数字（对于CPU来说数据和指令本质都是二进制数字，没有任何区别）放在一起叫做一个段。这个段可以是数据，可以是代码，也可以是代码+数据。而这个段仅仅只是存在逻辑上的，大部分情况由系统对这些段进行管理，可能把一堆段放到一起。虽然物理上这一系列段连续起来了，但是逻辑上这系列的段应该是分开的。
在汇编语言中定义了如下四个段：
代码段；
堆栈段；
数据段；
附加段；
并且分别用了四个寄存器来存储四个段的首地址：CS（代码段）、SS（堆栈段）、DS（数据段）、ES（附加段）。以及三个专用的寄存器来存储偏移地址：IP（代码段）、SP（堆栈段）、DI（附加段）。
所以一个数据/指令所在的位置应该是：段首地址+偏移地址。
那么一个段为什么最大只有64KB？假定1标定第一个字节，2标定第二个字节。在8086中，用的是16位寄存器，来表示偏移地址，而16位寄存器最大只能表示65535个数字，所以也就只能管理64KB。
同理，对于32位机器，最大能标定2^32=4GB。这也就是为什么当年的32位机器的最大内存条只能插4GB，如果插更多的内存条将会毫无反应，因为寻址寄存器只有这么大。
汇编语言是如何执行的。以EXE文件为例。电脑读取文件是顺序读取的，从头开始，所以在EXE文件的头部就有文件头。而文件头里面就会告诉CPU，CS、SS、DS、ES的值，以及IP、SP的值。在文件头读取完成之后就会读取装入模块，也就是程序本身。
然后程序就会从CS：IP的地方开始执行，CPU会把CS：IP所指向的内存当做代码而不是数据；每执行一条语句，IP就会加上相应的字节数。比如mov带有两个参数，那他就会读入两个参数，把紧接着的二进制数字当做数据而非是代码。（一定要注意数据和代码对于CPU是一种东西，唯一的区别是程序员想要怎么理解这段二级制数字）。
IP寄存器是不能够被直接赋值的，但是可以通过指令修改，例如jmp，ret等等。
还有一个很重要的知识点是：段是用户自己定义的。在完整段的声明里，段的名字是一个助记符，你可以取任意合法的值，可以完全不按照我们给的常用的段的声明名字来。数据段、代码段、堆栈段、附加段对于程序来说没有任何意义，是一样的。他们有没有意义主要取决于四个段地址寄存器的值。也就是说你的程序可以声明多个段（远超出四个段），甚至可以在其中执行的时候进行远转移，修改CS的值，来达到超大程序的目的（这也是为什么几个G的程序还能够运行）。
总的来说：
段是用户自己定义的，不同段对程序来说没有区别；
段是做什么用的，完全取决于四个段首地址寄存器；
用户可以定义远超四个段；
超越段进行代码调用或则数据调用的时候，就要好好利用offset和seg两个伪指令。
2.2 段定义
xxx segment [定位] [组合] [段字] ['类别'] 	#段开始，声明一个叫做xxx的段；
   ...        	#对于段的描述；
xxx end       	#结束xxx段声明；
2.3 段定位属性
Byte：段开始为下一个可用的字节地址(xxxx xxxxB)，属性值为1；
Word：段开始为下一个可用的偶数地址(xxxx xxx0B)，属性值为2；
Dword：段开始为下一个可用的4倍数地址(xxxx xx00B)，属性值为4；
Para：段开始为下一个可用的节地址(xxxx 0000B)，属性值为16；
Page：段开始为下一个可用的页地址(0000 0000B)，属性值为256；
简单来说就是强迫对齐。简化段默认会采用word，堆栈段默认采用para定义。
2.4 段组合属性
Private：本段与其他段没有逻辑关系，不与其他段进行合并。每段都有自己的段地址，根据书写的顺序与伪指令要求的摆放。完整段默认采用此方式；
Public：连接程序把本段与其他同名同类型的段相邻摆放，然后为所段制定一个共同的物理段地址。这是简化段默认采用的方式；
Stack：堆栈的一部分，所有的堆栈段将会默认合并，按照public的方式；
Common：连接程序把所有同名同类型的逻辑段指定同一个物理的段地址，这样可以方便数据共享，避免繁琐的跨段调用。
2.5 段字属性
为了支持32位操作系统而设计的。
2.6 段类别
指定段是用来干什么的，分为三类。'code'、'data'、'stack'。分别表示代码段、数据段、堆栈段。必须带有英文单引号书写。方便连接程序进行段组合。
2.7 段的描述
*直接使用代码
直接用一行代码独占一行，就可以声明一行。
*数据描述
以下两种方式都是数据描述：
string db 'hello world!', 0dh, 0ah, '$'
arr   db 01h, 02h, 03h, 04h
代码和数据是可以混合起来描述一个段的，这也是为什么段可以是数据+代码，但是并不建议这么使用。程序是逐行执行的，千万不能上面一行是代码，也不是跳转指令，下一行就是数据，鬼知道这串数据翻译过去会是什么代码。一般情况都是建议数据最好单独放在一个段，代码放一个段，堆栈放一个段。
其基本模式如下：
[助记符] (数据类型) 数据
db	字节，1字节；
dw	字，2字节；
dd	双字，4字节；
df	三字，6字节；
dq	四字，8字节；
dt	10字节；
如：
db 1
dw 1
这两个都是1，但是他们是不一样的，一个占用的大小空间是1字节，一个是2字节。而偏移地址1对应的是1字节，所以在遍历的时候，对于db只用+1，dw这种就应该+2。对于dd应该+3，以此类推。
在字符串定义的时候，一定要注意末尾的'$'，该符号是字符串的结束符号。 你可以通过DOS命令输出单个字符来输出这个字符。但是字符串里该字符对于DOS系统是字符串的结尾符。
0ah：下移一行；
0dh：回到行首。
2.8 占用大小
很多时候我们只是想分配一个空间而不想去填充内容，例如栈的定义的时候，我们只想分配空间，具体的数据应该等到push的时候再来说明。
如此就可以用如下指令：
db 127 dup(0)
上面的代码就分配了127个db类型，初始值为0的空间，注意不是说变量。尽量保证声明空间是2的次方倍数，但是又不能超过64KB。关于地址对齐有个非常有意思的现象，观察64位的windows系统，你会发现文件大小和占用空间在kb上基本不相同，占用空间都是4kb的整数倍。
其基本语法如下：
[助记符] (数据类型) 个数 sup(初始值)
这里的初始值不仅能用于第三类，也可以用于上面的第二类——数据描述。
2.9 一个标准的完整段定义
datas segment		;此处输入数据段代码
datas ends

stacks segment ;此处输入堆栈段代码
	  db 128 dup (0)
stacks ends

codes segment
	assume cs:codes,ds:datas,ss:stacks
	start:
	      mov    ax, datas
	      mov    ds, ax

              ...        ;代码

	      mov    ax,4c00h
	      int    21h
codes ends
end start
这只是一个参考模板。段的定义是随心所欲的，只要不发生冲突，不违反规范。段的名字也是随心所欲的，这里取datas、stacks、codes只是提醒程序员。
对于堆栈段，尽量都要预分配一个合适的空间大小，这里一定要注意。
assume cs:codes,ds:datas,ss:stacks
这条伪指令的作用，就是告诉CPU，cs是什么，ds是什么，ss是什么。但是请记住，assume指令只会给cs、ss赋值，并不会给ds赋值。
所以我们后面要在程序的开头写这样子的代码：
mov    ax, datas
mov    ds, ax
来将datas这个段首地址赋值给ds。
这里还有一条重要的伪指令
start:
这个东西就是告诉CPU，IP偏移地址在这个地方。
最后有一段现在无法理解的代码：
mov    ax,4c00h
int    21h
这个是告诉DOS系统，程序结束了。参数就是ax，发起的中断向量号是21h。
所有伪指令是不会留到exe中的，在翻译的过程中，就已经被处理掉了。像assume这种就会直接被放到文件头里面去。

2.A-32 /x86-64指令系统
2.1传送指令
传送指令用于寄存器、存储单元或 I/O 端口之间传送信息，分为通用数据传送、地址传 送、标志传送和 I/O 信息传送等几类，除了部分标志传送指令外，其他指令均不影响标志位的 状态。
2.1.1.通用数据传送指令
通用数据传送指令传送的是寄存器或存储器中的数据，主要有以下几种。
·MOV: 一般的传送指令，包括 movb、movw 和 movl 等。
·MOVS：符号扩展传送指令，将短的源数据高位符号扩展后传送到目的地址，如 movsbw 表 示把一个字节进行符号扩展后送到一个字地址中。
·MOVZ：零扩展传送指令，将短的源数据高位零扩展后传送到目的地址，如 movzwl 表示把 一个字的高位进行零扩展后送到一个双字地址中。
·XCHG：数据交换指令，将两个寄存器内容互换。例如，xchgb 表示字节交换。
·PUSH：先执行 R[sp]—R[sp] -2 或 R[esp]—R[esp] -4,然后将一个字或双字从指定寄 存器送到 SP或 ESP 指示的栈单元中°如 pushl 表示双字压栈，pushw 表示字压栈。
·POP：先将一个字或双字从 SP 或 ESP 指示的栈单元送到指定寄存器中，再执行 R[sp] 一 R[sp]+2 或R[esp]—R[esp] +4。如 popl 表示双字出栈，popw 表示字出栈。
桟(stack)是一种采用“先进后出”方式进行访问的一块存储区，在处理过程调用时 非常有用。大多数情况下，栈是从高地址向低地址增长的，在 IA-32 中，用 ESP 寄存器指向 当前栈顶，而栈底通常在一个固定的高地址上。图 3.5 给出了在 16 位架构下的 pushw 和 popw 指令执行结果示意图。图中显示，在执行 pushw 指令之后，SP 指向存放有 AX 内容的 单元，也即新栈顶指向了当前刚入栈的数据。若随后再执行 popw 指令，则原先在栈顶的两 个字节退出栈，栈顶向高地址移动两个单元，又回到 pushw 指令执行前的位置。这里请注意 AH 和 AL 的存放位置，因为 Intel 架构采用的是小端方式，所以应该是 AL 在低地址上，AH 在高地址上。
 
图 2-1  pushw 和 popw 指令的执行
2.1.2.地址传送指令
地址传送指令传送的是操作数的存储地址，指定的目的寄存器不能是段寄存器，且 源操作数必须是存储器寻址方式。注意，这些指令均不影响标志位。主要是加載有效地 地(Load Effect Address, LEA) 指令，用来将源操作数的存储地址送到目的寄存器中。如 leal 指令把一个 32 位的地址传送到一个 32 位的寄存器中。通常利用该指令执行一些简单 操作，例如，对于例 3. 1 中的运算 i+j，编译器使用了指令uleal (%edx,%eax), %eax", 以实现 R[ eax]←R[ edx] +R[eax]的功能，该指令执行前，R[ edx] =i, R[ eax] =j,指令 执行后 R[ eax] = i +jo
2.1.3.输入输出指令
输入输出指令专门用于在累加器和 I/O 端口之间进行数据传送。例如，in 指令用于将 I/O 端口内容送累加器，out 指令将累加器内容送 I/O 端口。
2.1.4.标志传送指令
标志传送指令专门用于对标志寄存器进行操作。如 pushf 指令用于将标志寄存器的内容压 栈，popf 指令将栈顶内容送标志寄存器。

2.2定点算术运算指令
定点算术运算指令用于二进制数和无符号十进制数的各种算术运算。1A-32 中的二进制定 点数可以是 8 位、16 位或 32 位数；无符号十进制数（BCD 码）主要是采用 8421 码表示的数。 高级语言中的算术运算都被转换为二进制数运算指令实现，因此，本书所讲的运算指令都是指 二进制数运算指令。
2.2.1.加/减运算指令
加/减类指令（ADD/SUB）用于对给定长度的两个位串进行相加或相减，两个操作数中最 多只能有一个是存储器操作数，不区分是无符号数还是带符号整数，产生的和/差送到目的地， 生成的标志信息送标志寄存器 FLAGS/EFLAGS。
2.2.2.增/减运算指令
增/减类（INC/DEC）指令对给定长度的一个位串加 1 或减 1,给定操作数既是源操作数也是目的操作数，不区分是无符号数还是带符号整数，生成的标志信息送标志寄存器 FLAGS/ EFLAGS,注意不生成 CF 标志。
2.2.3.取负指令
取负类指令 NEG 用于求操作数的负数，也即，将给定长度的一个位串“各位取反、末尾 加 1”，也称之为取补指令。给定操作数既是源操作数也是目的操作数， 生成的标志信息送标 志寄存器FLAGS/EFLAGS。若字节操作数的值为-128,或字操作数的值为-32 768,或双字操 作数的值为-2 147483648,则其操作数无变化，但 OF = 1。若操作数的值为 0,则取补结果仍 为 0 且 CF 置 0,否则总是使 CF置 1。
2.2.4.比较指令
比较类指令 CMP 用于两个寄存器操作数的比较，用目的操作数减去源操作数，结果不送 回目的操作数，即两个操作数保持原值不变，只是标志位作相应改变，因而功能类似 SUB 指 令。通常，该指令后面跟条件转移指令或条件设置指令。
2.2.5.乘/除运算指令
乘法指令分成 MUL（无符号数乘）和 IMUL（带符号整数乘）两类，指令中可以明显地给出 一个操作数、两个操作数或三个操作数。
若指令中只给岀一个操作数 SRC,则另一个源操作数隐含在累加器 AVAX/EAX 中，将 SRC 和累加器内
容相乘，结果存放在 AX（16 位时）或 DX-AX（32 位时）或 EDX-EAX（64 位 时）中。DX-AX 表示 32 位乘积的高、低 16 位分别在 DX 和 AX 中。若指令中给出两个操作数 DST 和 SRC,则将 DST 和 SRC 相乘，结果存放在 DST 中。若指令中给出三个操作数 REG、SRC 和 IMM,则将 SRC 和立即数 IMM 相乘，结果存放在 寄存器 REG 中。除法指令分成 DIV（无符号数除）和 IDIV（带符号整数除）两类，指令中只明显指出除数， 用累加
器 AL/AX/EAX 中的内容除以指令中指定的除数。若源操作数为 8 位，则 16 位的被除 数隐含在 AX 寄存器中，商送回 AL,余数在 AH 中；若源操作数为 16 位，则 32 位的被除数隐 含在 DX-AX 寄存器中，商送回 AX, 余数在 DX 中；若源操作数是 32 位，则 64 位的被除数隐 含在 EDX-EAX 寄存器中，商送回 EAX,余数在 EDX 中。需要说明的是，如果商超过目的寄存 器能存放的最大值，系统产生类型号为。的中断，并且商和余数均不确定。


图2-2  定点算术运算指令汇总1


图2-2  定点算术运算指令汇总2
·假设 R[ax] =FFFAH, R[bx]=FFFOH,则执行 Intel 格式指令 “add ax, bx” 后， AX、BX 中的内容各是什么？标志 CF、OF、ZF、SF 各是什么？要求分别将操作数作为无符号 数和带符号整数来解释并验证指令执行结果。
根据 Intel 指令格式规定可知，指令“addax,bx”的功能是 R[ax]<-R[ax] + R[bx], 指令的执行在图 2.6 所示的整数加减运算器中进行，执行后其结果在 AX 中，即 R[ax]= FFFAH + FFFOH = FFEAH,而 BX 的内容不变，即 R[bx] =FFF0H,标志 CF = 1, SF = 1, OF = 0, ZF=0o 若作为无符号数来解释，则根据 CF
= 1 可判断其结果溢出；若作为带符号整数来解 释，则根据 OF=0 可判断其结果不溢出且和为-22。无符号数加法运算结果验证如下：R[ax] = FFFAH,即值为 65 530, R[bx]=FFF0H,即值为 65 520,所以结果为 65 530
+65 520 = 131 050, 显然大于 16 位最大可表示的无符号数 65 535,即结果溢出，验证正确。带符号整数加法运算 结果验证如下：R[ax]=FFFAH,即值为-110B=-6, R[bx]=FFF0H,即值为-10000B = -16,所以结果为
-6 + (-16)=-22，验证正确。
· 假设 R[eax] =000000B4H, R[ebx] =00000011H, M[000000F8H] =000000AOH,请问：
（1）执行指令“mulb%bl”后，哪些寄存器的内容会发生变化？是否与执行“imulb%bl” 指令所发生的变化一样？为什么？请用该例给出的数据验证你的结论。
（2）执行指令"imull$-16, (%eax,%ebx,4), %eax"后，哪些寄存器和存储单元发生了变 化？乘积的机器数和真值各是多少？
 因为 R[eax] = 000000B4H, R[ebx] = 00000011H,所以，R[al] = B4H, R[bl] = 11H。
（3）指令“mulb % bl"中指出的操作数为 8 位，故指令的功能为“R[ax]—R[al] X R[bl「‘，因此， 改变内容的寄存器是 AX, 指令执行后 R[ax] =0BF4H, 即十进制数 30600 执  行指令“ imulb%bl ” 后，R[ax]=FAF4H,即十进制数-1292。由此可见，两条指令执行后发 生变化的寄存器都是 AX,但是存入 AX 的内容不一样。mulb 指令执行的是无符号数乘法，而 imulb 执行的是带符号整数乘法，根据 2. 7.5 节中给出的无符号数和带符号整数的乘法运算规 则可知，若乘积只取低 8 位，则两者的机器数一样，在此例中两者都是 F4H； 若乘积取 16 位， 则高 8 位可能不同，此例中一个是 0BH, —个是 FAH。验证：此例中 mulb 指令执行的运算是180 x 17 =3060,而 imulb 指令执行的运算是-76 x 17 = -1292。
（4）指令“imull $-16 , ( %eax ,%ebx,4) , %eax”的功能是“R[ eax]—( -16) X M[ R[ eax]
4xR[ebx]]”，其中，第二个乘数所在的存储单元地址为 R[eax]+4 xR[ebx] =0x64 + (0x11 «2)= 0xF8= 000000F8H,因为 M[000000F8H] =000000AOH,与-16 相乘后得到一个负的乘积，因 此乘积的符号为负， 乘积数值部分绝对值的机器数为 000000A0H «4 = 00000A00H,对其各位 取反末位加 1,得到乘积的机器数为 FFFFF600H,即指令执行后 EAX 中存放的内容为 FFFFF600H，其真值为-2560。

2.3按位运算指令
按位运算指令用来对不同长度的操作数进行按位操作，立即数只能作为源操作数，不能作 为目的操作数，并且最多只能有一个为存储器操作数。按位运算指令主要分为逻辑运算指令和 移位指令。
2.3.1 逻辑运算指令
以下 5 类逻辑运算指令中，仅 NOT 指令不影响条件标志位，其他指令执行后，OF = CF =0,而 ZF 和 SF 则根据运算结果来设置：若结果为全 0,则 ZF = 1；若最高位为 1,则 SF = 1。
NOT：单操作数的取反指令，它将操作数每一位取反，然后把结果送回对应位。
AND：对双操作数按位逻辑“与”，主要用来实现“掩码”操作。例如，执行指令“andb $Oxf, %aT'后，AL 的高 4 位被屏蔽而变成 0,低 4 位被析取出来。
OR：对双操作数按位逻辑“或”，常用于使目的操作数的特定位置 1。例如，执行指令“orw$0x3, %bx”
后，BX 寄存器的最后两位被置 1。
XOR：对双操作数按位进行逻辑“异或”，常用于判断两个操作数中哪些位不同或用于改 变指定位的值。例如，执行指令“xorw$0xl, %bx”后，BX 寄存器最低位被取反。
TEST：根据两个操作数相“与”的结果来设置条件标志，常用于需检测某种条件但不能 改变原操作数的场合。例如，可通过执行“testb$Oxl, %al"指令判断 AL 最后一位是否为 1。 判断规则为：若 ZF=O, 则说明 AL 最后一位为 1;否则为 0。也可通过执行“testb%al, %al” 指令来判断 AL 是否为 0、正数或负数。判断规则为：若 ZF = 1,则说明 AL 为 0；若 SF=O 且 ZF=O,则说明 AL 为正数；若 SF = 1,则说明 AL 为负数。
2.3.2 移位指令
移位指令将寄存器或存储单元中的 8、16 或 32 位二进制数进行算术移位、逻辑移位或循 环移位。在移位过程中，把 CF 看作扩展位，用它接受从操作数最左或最右移出的一个二进制 位。只能移动 1~31 位， 所移位数可以是立即数或存放在 CL 寄存器中的一个数值。
SHL；逻辑左移，每左移一次，最高位送入CF,并在低位补0。SHR：逻辑右移，每右移一次，最低位送入           CF,并在高位补0。SAL：算术左移，操作与 SHL 指令类似，每次移位，最高位送入 CF,并在低位补 0。执行 SAL 指令时，如果移位前后符号位发生变化，则。F = l,表示左移后结果溢出。这是 SAL 与 SHL 的不同之处。SAR：算术右移，每右移一次，操作数的最低位送入CF,并在高位补符号。ROL：循环左移，每左移一次，最高位移到最低位，并送入CF。ROR：循环右移，每右移一次，最低位移到最高位，并送入 CF。
·RCL：带循环左移，将 CF 作为操作数的一部分循环左移。
·RCR：带循环右移，将 CF 作为操作数的一部分循环右移。
· 假设 short 型变量 x 被编译器分配在寄存器 AX 中，R[ax]=FF80H,则以下汇编 代码段执行后变量*的机器数和真值分别是多少？
movw %ax, %dx salw $2 , %ax addl %dx, %ax sarw %1, %ax
显然这里的汇编指令是 GCC 默认的 AT&T 格式，$2 和$1 分别表示立即数 2 和 1。假设 上述代码段执行前 R[ax]=x,则执行（（x<<2） +x） >>1 后，R[ax]=5x/2。算术左移时，AX 中的内容在移位前、后符号未发生变化，故 0F=0,没有溢出。最终 AX 的内容为 FEC0H,解释 为 short 型整数时，其值为-320。验证：x= -128 , 5x/2= -320o 经验证，结果正确。
2.4控制转移指令
IA-32 中指令执行的顺序由 CS 和 EIP 确定。正常情况下，指令按照它们在存储器中的存放 顺序一条一条地按序执行，但是，在有些情况下，程序需要转移到另一段代码去执行，可以釆 用改变 CS 和 EIP, 或者仅改变 EIP 的方法来实现转移。第一种称为段间转移,也叫远转移,转 移目标的属性为 FAR；第二种称为段内转移,分近转移和短转移,转移目标的属性分别为 NEAR 和 SHORT0
段内转移和段间转移都有直接转移和间接转移之分。直接转移是指转移的目标地址作为立 即数直接出现在指令的机器码中；间接转移则是指转移的目标地址间接存储在某一寄存器或存 储单元中。
目标转移地址的计算方法有两种。一种是通过将当前 EIP 的值增加或减少某一个值，也就 是以当前指令为中心往前或往后转移，称为相对转移;另一种是以新的值代替当前EIP 的值，称为绝对转移。在IA-32 指令系统中，所有段内直接转移都是相对转移，所有段内间接转移和 段间转移都是绝对转移。
IA-32 提供了多种控制转移指令，有无条件转移指令、条件转移指令、条件设置指令、调 用/返回指令和中断指令等。这些指令中，除中断指令外，其他指令都不影响状态标志位，但 有些指令的执行受状态标志的影响。与条件转移指令和条件设置指令相关的还有条件传送 指令。
2.4.1.无条件转移指令
无条件转移到转移目标地址处执行。按不同的寻址方法可分为以下 6 种指令形式。JMP SHORT DST：段内直接短转移，在-128B - + 127B 范围相对转移，DST 为标号。JMP NEAR PTR DST：段内直接近转移，在±32KB 范围内相对转移，DST 为标号。JMP DST：段内间接转移，在 64KB 范围内绝对转移，DST 为寄存器。
JMP WORD PTR DST：段内间接转移，在 64KB 范围内绝对转移，DST 为存储单元。
JMP FAR PTR DST：段间直接转移，段外绝对转移，DST 为标号。
JMP DWORD PTR DST：段间间接转移，段外绝对转移，DST 为存储单元。

2.4.2.条件转移指令
条件转移指令以条件标志或者条件标志位的逻辑运算结果作为转移依据。如果满足转移条 件，则程序转移到由标号 label 确定的目标地址处执行；否则继续执行下一条指令。这类指令 都釆用相对转移方式在段内直接转移。图2-3列出了常用条件转移指令的转移条件。
图2-3  条件转移指令

IA-32 中不管高级语言程序中定义的变量是带符号整数还是无符号整 数，对应的加（减）法指令都是一样的，都是在如图 2. 6 所示的电路中执行。每条加（减） 法指令执行以后，会根据运算结果产生相应的进/借位标志 CF、符号标志 SF、溢出标志 OF 和 零标志 ZF 等，并保存到标志寄存器（FLAGS/EFLAGS）中。
对于比较大小后进行分支转移的情况，通常在条件转移指令前面的是比较指令或减法指 令，因此， 大多是通过减法来获得标志信息，然后再根据标志信息来判定两个数的大小，从而 决定该转移到何处执行指令。对于无符号整数的情况，判断大小时使用的是 CF 和 ZF 标志。 ZF = 1 说明两数相等，CF = 1 说明有借位，是“小于”的关系，通过对 ZF 和 CF 的组合，得到 表 3.6 中序号 9、10、11 和 12 这四条指令中的结论。对于带符号整数的情况，判断大小时使用 SF、OF 和 ZF 标志。ZF = 1 说明两数相等，SF = OF 时说明结果是以下两种情况之一：①两数 之差为正数（SF=O）且结果未溢出（0F=0）；②两数之差为负数（SF = 1）且结果溢出 （OF = 1）。这两种情况显然反映的是“大于”关系。同样，若 SF 尹 OF,则反映"小于”关系。 带符号整数比较时对应表 3. 6 中序号 13、14、15 和 16 这四条指令。
·假设被减数的机器数为 X,减数的机器数为匕 则在如图 2. 6 所示的整数加减运算器中计 算两数的差时，计算公式为：X-Y = X + （-Y)补。现举两个例子来说明上述无符号整数和带符号整数的大小判断规则。
假定 X = 1001, 7=1100,则 Sub = l , Y' =0011,加法器中的运算为 1001 - 1100 = 1001 + 0011+1 =(0)1101,因此 ZF=0, C=0o 若是无符号整数比较，则是 9 和 12 相比，是“小于” 的关系，此时 CF = C@Sub = l,满足表 3.6 中序号 11 对应指令中的条件；若是带符号整数比 较，则是-7 和-4 比较，显然也是“小于”关系，此时符号位为 1,即 SF = 1,而根据两个加 数符号相异一定不会溢出的原则，得到 OF=0, 因而 SF#OF,满足表 3. 6 中序号 15 对应指令中的条件。
假定 X = 1100, Y=1001,则 Sub = 1, Y' =0110,加法器中的运算为 1100 - 1001 = 1100 + 0110
+ 1 =(1)0011,因此 ZF=0, C = l。若是无符号数比较，则是 12 和 9 相比，是“大于” 的关系，显然此时 CF = C©Sub=0,满足表 3. 6 中序号 9 对应指令中的条件；若是带符号整数 比较，则是-4 和-7 比较， 也是“大于”的关系，显然此时 SF=0 且 OF=0,即 SF = OF,满 足表 3. 6 中序号 13 对应指令中的条件。

2.4.3.条件设置指令
条件设置指令用来将条件标志组合得到的条件值设置到一个 8 位通用寄存器中，其设置的 条件值与表 3. 6 中条件转移指令的转移条件值完全一样，指令助记符也类似，只要将 J 换成 SET 即可。其格式为：
SETCC DST
DST 通常是一个 8 位寄存器。例如，假定将组合条件值存放在 DL 寄存器中，则对应表 3. 6中序号 1 的指令为“setc%dl”，其含义为：若 CF = 1,则 R[dl] =1；否则 R[dl] =0o 对应
表 3. 6 中序号 14 的指令为“setge%dl”，其含义为：若 SF = OF 或 ZF = 1,则 R[dl]=l；否则
R[dl]=O。每个条件转移指令都有对应的条件设置指令。
例以下各组指令序列用于某种比较结果记录到 CL 寄存器。根据以下各组指令序列，分别判断数据％在 C 语言程序中的数据类型，并说明指令序列的功能。
CMP 指令通过执行减法来设置条件标志位，每组中第二条 SETcc 指令中使用的条件 标志都是由％ 和 y 相减后设置的。
第一组 X 和:r 都是 32 位数据，指令 setb 对应表 3.6 中序号为 11 的指令，设置条件为 CF = 1 且ZF = 0,说明是无符号整数小于比较，因此，X 和丁可能是 unsigned, unsigned long 或指针型 数据。第二组'和 y 都是 32 位数据，指令 seme 对应表 3. 6 中序号为 4 的指令，设置条件为 ZF=0,说明是两个位串的不相等比较，因此，x 和 y 可能是 unsigned, int、unsigned longs  long 或指针型数据。第三组都是 16 位数据，指令 setl 对应表 3. 6 中序号为 15 的指令，设置条件为 SF0OF且 ZF=0,说明是带符号整数小于比较，因此，x 和 y 只能是 short 型数据。第四组 X 和 y 都是 8 位数据，指令 setae 对应表 3.6 中序号为 10 的指令，设置条件为 CF=0或 ZF = 1,说明是无符号整数大于等于比较，因此，，和 y 只能是 unsigned char 型数据。 以下各组指令序列用于测试变量攵的某种特性，并将测试结果记录到 CL 寄存器。
根据以下各组指令序列，分别判断数据x在C语言程序中的数据类型，并说明指令序列的功能。

TEST 指令执行后，OF = CF=0,而 ZF 和 SF 则根据两个操作数相“与”的结果来设 置：若结果为全 0,则 ZF = 1；若最高位为 1,则 SF = 1。前三组的 TEST 指令对*和，相“与” 得到的是 X 本身。
第一组"为 32 位数据，指令 sete 对应表 3.6 中序号为 3 的指令，设置条件为 ZF = 1,因而 是对位串*判断是否等于 0,显然，x 可能是 unsigned, int 或指针型数据。
第二组*为 32 位数据，指令 setge 对应表 3. 6 中序号为 14 的指令，设置条件为 SF = OF 或 ZF = 1, 因为 OF=0,所以设置条件转换为 SF=0 或 ZF = 1,即判断，的符号是否为正或，是否 为 0,说明是带符号整数大于等于 0 比较，因此，/可能是 int 或 long 型数据。
第三组"为 16 位数据，指令 setns 对应表 3.6 中序号为 6 的指令，设置条件为 SF=0, 说明是带符号整数是否为非负数比较，即判断 X 是否大于等于。，因此，％只能是 short 型 数据。
第四组的 TEST 指令对/和 OxOF 相"与”，析取 x 的低 4 位，，为 8 位数据，指令 setz 对应 表 3.6 中序号为 3 的指令，设置条件为 ZF = 1,因而是对 TEST 指令析取出的位串判断是否为 0,即判断*的低 4 位是否为0,因此，x 可能是 char 或 unsigned char 型数据。

2.4.4 条件传送指令
该类指令的功能是，如果符合条件就进行传送操作，否则什么都不做。设置的条件和 表 3. 6 中的条件转移指令的转移条件完全一样，指令助记符也类似，只要将 J 换成 CM0V 即 可。其格式为：CMOVcc DST, SRC源操作数 SRC 可以是 16 位或 32 位寄存器或存储器操作数，传送目的地 DST 必须是 16 位或 32 位寄存器。例如，对应表 3.6 中序号 1 的指令“cmovc % eax, %edx”，其含义为：若 CF = 1,则R[edx]«—R[eax]；否则什么都不做。对应序号 14 的指令"cmovge （%eax）, %edx", 其含义为：若 SF= OF 或 ZF = 1,则 R[edx]<-M[R[eax]]:否则什么都不做。
2.4.5 调用和返回指令
为便于模块化程序设计，往往把程序中某些具有独立功能的部分编写成独立的程序模块， 称之为子程序。这些子程序可以被主程序调用，并且执行完毕后又返回主程序继续执行原来的 程序。子程序的使用有助于提高程序的可读性，并有利于代码重用，它是程序员进行模块化编 程的重要手段。子程序的使用主要通过过程调用或函数调用实现,为叙述方便起见，本书将过 程（调用）和函数（调用）统称为过程（调用）。为实现这一功能，IA-32 提供了以下两条 指令。
调用指令
调用指令 CALL 是一种无条件转移指令，跳转方式与 JMP 指令类似。它具有两个功能： ①将返回地址入栈（相当于 PUSH 操作）；②跳转到指定地址处执行。执行时，首先将当前 EIP 或 CS：EIP 的内容（即返回地址，相当于 CALL 指令下面一条指令的地址）入栈，然后将调 用目标地址（即子程序的首地址）装入 EIP 或 CS:EIP,以将控制转移到被调用的子程序执行。 显然，CALL 指令会修改栈指针 ESP。
CALL 指令有以下 5 种基本类型。
CALL NEAR PTR DST：段内直接调用（NEAR PTR 可省略），DST 为子程序入口地址。
CALL DST：段内间接调用，DST 为寄存器。
CALL WORD PTR DST：段内间接调用，DST 为存储单元。CALL FAR PTR DST：段间直接调用，DST 为子程序入口地址。CALL DWORD PTR DST；段间间接调用，DST 为存储单元。
返回指令
返回指令 RET 也是一种无条件转移指令，通常放在子程序的末尾，使子程序执行后返回 主程序继续执行。该指令执行过程中，返回地址被从栈顶取出（相当于 POP 指令），并送到 EIP 寄存器（段内或段间调用时）和 CS 寄存器（仅段间调用）。显然，RET 指令会修改栈指 针。若 RET 指令带有一个立即数 n, 则当它完成上述操作后，还会执行 R[esp]—R[esp] +□ 操作，从而实现预定的修改栈指针 ESP 的目的。

2.4.6 中断指令
中断的概念和过程调用有些类似，两者都是将返回地址先压栈，然后转到某个程序去执 行。它们的主要区别是：①过程调用跳转到一个用户事先设定好的子程序，而中断跳转则是 转向系统事先设定好的中断服务程序；②过程调用可以是 NEAR 或 FAR 类型，能直接或间接 跳转，而中断跳转通常是段间间接转移，因为中断处理会从用户态转到内核态执行；③过程 调用只保存返回地址，而中断指令还要使标志寄存器入栈保存。1A-32 提供了以下关于中断的 指令。
INTn：n 为中断类型号，取值范围为0~255。iret/iretd：中断返回指令，偏移地址和段地址送 CS:EIP,并恢复标志寄存器。
into：溢出中断指令，若 OF = 1,产生类型号为 4 的异常，进入相应的异常处理。 
sysenter:快速进入系统调用指令。
sysexit：快速退出系统调用指令。
与中断相关的内容详见第 7 章和第 8 章。

2.5 X87浮点指令
IA-32 的浮点处理架构有两种：较早的一种是与 x86 配套的浮点协处理器 x87 架构，采用 栈结构； 另一种是由 MMX 发展而来的 SSE 指令集架构，采用的是单指令多数据(Single Instruction Multi Data,SIMD)技术，包括 SSE、SSE2、SSE3、SSSE3、SSE4 等。对于 IA-32 架构， GCC 默认生成 x87 指令集代码，如果想要生成 SEE 指令集代码，则需要设置适当的编译选项。
x87 FPU 有一个浮点寄存器栈，栈的深度为 8,每个浮点寄存器有 80 位。根据指令的操作 功能，x87 浮点数指令可分为浮点数装入、浮点数存储、整数浮点数转换、浮点数算术运算和 浮点数测试比较等几种类型。
浮点数装入指令用来将存储单元或原栈中的浮点数装入到浮点寄存器栈的栈顶 ST(0)。由 于浮点寄存器宽度为 80 位，所以，这些指令中指定的从存储单元中取出的浮点数不管是 32 位 还是 64 位，都要先转换为 80 位扩展精度格式后再装入栈顶。浮点数存储指令用来将浮点寄存器栈的栈顶 ST(0)中的元素存储到存储单元中。由于浮 点寄存器宽度为 80 位，所以，需要先将 80 位扩展精度格式转换为 32 位或 64 位格式后再存储 到指定存储单元中。由于 x87 中浮点寄存器为 80 位，而在内存中的浮点数可能占 32 位、64 位或 96 位，因而 在内存单元和浮点数寄存器之间进行数据传送的过程中，可能会丢失精度而造成错误计算结 果，需要引起注意。图 1-9 所示是两个功能完全相同的程序，但是，使用 gcc 的一些旧版本对它们进行编译时， 会发生以下情况：使用 gcc-O2 编译程序一时，运行后输出结果是 0,也就是说。不等于使 用 gcc-02 编译程序二时，运行后输出结果却是 1,也就是说 a 等于 6。两个几乎一模一样的程 序，但运行结果不一致。

图 2-4 浮点运算示例
出现上述情况的主要原因是存储单元和浮点数寄存器之间进行数据传送的过程中丢失了 精度。gcc 对于程序一的处理过程如下：先计算 a=f(10),然后将其写到存储单元，由于 0. 1 = 0. 0 0011[0011]B,即转换为二进制数时是无限循环小数，因此无法用有限位数的二进制精确 表示。在将其从 80 位的浮点寄存器写入到 64 位(double 类型占 64 位)的存储区域时，产生 了精度损失。然后，计算 6=f(10), 这个结果并没被写入存储器中，这样，在计算关系表达式 “a==b”时，直接将损失了精度的 a 与栈顶中的 6 进行比较，由于 3 没有精度损失，因此 a 与 6 不相等。
gcc 对于程序二的处理过程如下：a 与 6 在计算完成之后，由于程序中多了一个 c=f(10) 的计算， 使得 gcc 必须把先前计算的 a 和 6 都写入存储器中，于是都产生了精度损失，因而它 们的值完全一样， 再把它们读到浮点寄存器栈中进行比较时，得出的结果就是 a 等于 6。
使用较新版本的 gcc (如 gcc 4.4.7)编译时，用-02 优化选项的情况下，两个程序输出的 结果都为1,并没有发生题目中所说的情况，对它们反汇编后发现，两个程序都没有计算 f(10)就直接把 i 设置成 1 了，显然编译器进行了相应的优化。
上述 gcc 旧版本出现的问题主要是编译器没有处理好。从这个例子可以看出，编译器的设 计和硬件结构是紧密相关的。对于编译器设计者来说，只有真正了解底层硬件结构和真正理解 指令集体系结构， 才能够翻译出没有错误的目标代码，并为程序员完全屏蔽掉硬件实现的细 节，方便应用程序员开发出可靠的程序。对于应用程序开发者来说，也只有真正了解底层硬件 的结构，才有能力编制出高效的程序， 能够快速定位出错的地方，并对程序的行为作出正确的 判断。

2.6 MMX/SSE指令
在多媒体应用中，图形、图像、视频和音频处理存在大量具有共同特征的操作，因而 Intel 公司于1997 年推出了 MMX( Multi Media extension,多媒体扩展)指令集，它是一种多媒体指 令增强技术，包括 57 条多媒体处理指令，通过这些指令可以一次处理多个数据。但是，因为 MMX 指令与 x87 FPU 共用同一套寄存器。因而 MMX 指令与 x87 浮点运算指令不能同时执行， 降低了整个系统的运行性能。
随着网络、通信、语音、图形、图像、动画和音/视频等多媒体处理软件对处理器性能越 来越高的要求，Intel 在多能奔腾以后的处理器中加入了更多流式 SIMD 扩展(Stream SIMD Extension,简称 SSE)指令集，包括 SSE、SSE2、SSE3、SSSE3、SSE4 等，这些都是典型的数 据级并行处理技术。
SSE 指令集最早是 1999 年 Intel 在 Pentium III 处理器中推出的，包括了 70 条指令，其中包 含提高 3D 图形运算效率的 50 条 SIMD 浮点运算指令、12 条 MMX 整数运算增强指令和 8 条优 化内存中连续数据块传输指令。理论上这些指令对图像处理、浮点运算、3D 运算、视频处理、 音频处理等诸多多媒体应用起到全面强化的作用。SSE 兼容 MMX 指令，它可以通过 SIMD 技术 在单时钟周期内并行处理 4 个单精度浮点数据来有效地提高浮点运算速度。
2001 年 Intel 在 Pentium 4 中发布了一套包括 144 条新指令的 SSE2 指令集，提供了浮点SIMD 指令、整数 SIMD 指令、浮点数和整数之间转换等指令。SSE2 增加了能处理 128 位整数 和同时并行处理两个 64 位双精度浮点数的指令。为了更好地利用高速缓存，还新增了几条缓 存指令，允许程序员控制已经缓存过的数据。
2004年年初 Intel 公司在新款 Pentium 4（ P4E, Prescott 核心）处理器中发布了 SSE3 , 
2005 年4月 AMD 公司也发表具备部分 SSE3 功效的处理器 Athlon 64,此后的 x86 处理器几乎都具备 SSE3 的新指令集功能。SSE3 新增了 13 条指令，其中一条用于视频解码，两条用于线程同步， 其余用于复杂的数学运算、浮点数与整数之间的转换以及 SIMD 浮点运算，使处理器对 DSP 及 3D 处理的性能大为提升。此外， SSE3 针对多线程应用进行优化，使处理器原有的超线程功能 得到了更好发挥。
2005 年，作为 SSE3 指令集的补充版本，SSSE3 出现在酷睿微架构处理器中，新增 16 条指 令，进一步增强了 CPU 在多媒体、图形图像和 Internet 等方面的处理能力。
2008 年 SSE4 指令集发布，它被视为最重要的多媒体扩展指令集架构改进方式，将延续了 多年的 32位架构升级至 64 位。SSE4 增加了 54 条指令，其中 SSE4. 1 指令子集包含 47 条指令， SSE4.2 包含 7 条指令。SSE4. 1 主要针对向量绘图运算、3D 游戏加速、视频编码加速及协同处 理加速等方面，此外还加入了 6 条浮点运算增强指令，这使得图形渲染处理性能和 3D 游戏效 果等得到极大提升。除此之外，SSE4. 1 指令集还加入了串流式负载指令，可提高图形帧缓冲 区的数据读取频宽，理论上可获取完整的缓存行， 即单次读取 64 位而非原来的 8 位。SSE4.2 主要针对字符串和文本处理。例如，对 XML 应用进行高速査找及对比，在如 Web 服务器应用 等方面有显著的性能改善。
下面用一个简单的例子来比较普通指令与数据级并行指令的执行速度。为了使比较结果尽 量不受访存操作的影响，以下例子中的运算操作数主要是寄存器操作数。此外，为了使比较结 果尽量准确，例子中设置了较大的循环次数值，为 0x4000000 = 2”。例子只是为了说明指令执 行速度的快慢，并没有考虑结果是否溢出。
图 3. 8 给岀了釆用普通指令的累加函数 dummy_add 对应的汇编代码，其中粗体字部分为循环 体， 循环控制指令 loop 执行时，先检测寄存器 ECX 的内容，若为 0 则退出循环，否则 ECX 的内 容减 1,并再次进入循环体的第一条指令开始执行，循环体的第一条指令地址由 loop 指令指出。

图 2-5 釆用普通指令的累加函数
图 2-5 给出了釆用数据级并行指令的累加函数 dummy_add_sse 对应的汇编代码，其中粗体 字部分为循环体。

图 2-6 采用 SSE 指令的累加函数
从图 2-6 可以看出，dummy_add 函数中，每次循环只完成一个字节的累加，而在图 3. 9 所 示的dummy_add_sse 函数中，每次循环执行的指令为“paddb %xmmO, %xmml ",也即每次循 环并行完成两个XMM 寄存器中的 16 个一字节数据的累加，对于与 dummy_add 同样的工作量， 循环次数应为其 1/16,即（0x4000000 » 4） =0x400000 = 2,因而，可以预期它所用的时间大 约只有 dummy_add 的 l/16。在相同环境下测试两个函数的执行时间，dummy_add 所用时间约为 22.643 816s,而 dummy_add_sse所用时间约为 1.411  588s,两者之比大约为 16.  041  378。这与预期的结果一致。dummy_add_sse 函数中用到的 SSE 指令有两种，除了 paddb 以外，还有一种是 movdqa 指 令，它的功能是将双四字（128 位）从源操作数处移到目标操作数处。该指令可用于在 XMM 寄存器与 128 位存储单元之间移入/移出双四字，或在两个 XMM 寄存器之间移动。该指令的源 操作数或目标操作数是存储器操作数时，操作数必须是 16 字节边界对齐，否则将发生一般保 护性异常（#GP）。若需要在未对齐的存储单元中移入/移出双四字，可以使用 movdqu 指令。 更多有关 SSE 指令集的内容请参看 Intel 的相关资料。
2.7 编译
编译器(ccl)将文本文件hello.i翻译成文本文件he11o.s，he11o.s包含一个汇编语言程序。编译器将c语言转换成汇编语言。
编译程序的基本功能是把源程序（高级语言）翻译成目标程序。除了基本功能之外，编译程序还具备语法检查、调试措施、修改手段、覆盖处理、目标程序优化、不同语言合用以及人机联系等重要功能。
2.7.1 Ubuntu下编译的命令
gcc hello.i -S -o hello.s
C语言源程序为：
#include "stdio.h"
#include "stdlib.h"
int main(int argc, char *argv[1]){
int i;
if (argc!=4){
printf("usage: hello no name time \n");
exit(1);
}
for (i=0;i<8;i++){
printf("Hello　 %s %s\ n", argv[1], argv[2]);
sleep(atoi(argv[3]));
}
getchar();
return 0;
} 
编译后的汇编语言程序为：
	.file	"ss.c"
	.text
	.section	.rodata
	.align 4
.LC0:
	.string	"\347\224\250\346\263\225: hello \345\255\246\345\217\267 \345\247\223\345\220\215 \347\247\222\346\225\260 "
.LC1:
	.string	"Hello\343\200\200 %s %s n"
	.text
	.globl	main
	.type	main, @function
main:
.LFB5:
	.cfi_startproc
	leal		4(%esp), %ecx
	.cfi_def_cfa 1, 0
	andl		$-16, %esp
	pushl	-4(%ecx)
	pushl	%ebp
	.cfi_escape 0x10,0x5,0x2,0x75,0
	movl	%esp, %ebp
	pushl	%esi
	pushl	%ebx
	pushl	%ecx
	.cfi_escape 0xf,0x3,0x75,0x74,0x6
	.cfi_escape 0x10,0x6,0x2,0x75,0x7c
	.cfi_escape 0x10,0x3,0x2,0x75,0x78
	subl		$28, %esp
	call		__x86.get_pc_thunk.bx
	addl		$_GLOBAL_OFFSET_TABLE_, %ebx
	movl	%ecx, %esi
	cmpl	$4, (%esi)
	je		.L2
	subl		$12, %esp
	leal		.LC0@GOTOFF(%ebx), %eax
	pushl	%eax
	call		puts@PLT
	addl		$16, %esp
	subl		$12, %esp
	pushl	$1
	call		exit@PLT
.L2:
	movl	$0, -28(%ebp)
	jmp		.L3
.L4:
	movl	4(%esi), %eax
	addl		$8, %eax
	movl	(%eax), %edx
	movl	4(%esi), %eax
	addl		$4, %eax
	movl	(%eax), %eax
	subl		$4, %esp
	pushl	%edx
	pushl	%eax
	leal		.LC1@GOTOFF(%ebx), %eax
	pushl	%eax
	call		printf@PLT
	addl		$16, %esp
	movl	4(%esi), %eax
	addl		$12, %eax
	movl	(%eax), %eax
	subl		$12, %esp
	pushl	%eax
	call		atoi@PLT
	addl		$16, %esp
	subl		$12, %esp
	pushl	%eax
	call		sleep@PLT
	addl		$16, %esp
	addl		$1, -28(%ebp)
.L3:
	cmpl	$7, -28(%ebp)
	jle		.L4
	call		getchar@PLT
	movl	$0, %eax
	leal		-12(%ebp), %esp
	popl		%ecx
	.cfi_restore 1
	.cfi_def_cfa 1, 0
	popl		%ebx
	.cfi_restore 3
	popl		%esi
	.cfi_restore 6
	popl		%ebp
	.cfi_restore 5
	leal		-4(%ecx), %esp
	.cfi_def_cfa 4, 4
	ret
	.cfi_endproc
.LFE5:
	.size	main, .-main
	.section	.text.__x86.get_pc_thunk.bx,"axG",@progbits,__x86.get_pc_thunk.bx,comdat
	.globl	__x86.get_pc_thunk.bx
	.hidden	__x86.get_pc_thunk.bx
	.type	__x86.get_pc_thunk.bx, @function
__x86.get_pc_thunk.bx:
.LFB6:
	.cfi_startproc
	movl	(%esp), %ebx
	ret
	.cfi_endproc
.LFE6:
	.ident	"GCC: (Ubuntu 7.5.0-3ubuntu1~18.04) 7.5.0"
	.section	.note.GNU-stack,"",@progbits
Hello的编译结果解析
(1)伪操作
汇编程序中以.开头的名称并不是指令的助记符，不会被翻译成机器指令，而是给汇编器一些特殊指示，称为汇编指示或伪操作。由于它不是真正的指令所以加个“伪”字。.section指示把代码划分成若干个段（Section），程序被操作系统加载执行时，每个段被加载到不同的地址，操作系统对不同的页面设置不同的读、写、执行权限。.data段保存程序的数据，是可读可写的，相当于C程序的全局变量。
.file：源文件”hello.c”；
.text：代码节；
.rodata：只读数据节；
.align：数据和指令的地址按4字节进行对齐；
.string：声明一个字符串(LC0,LC1)；
.global：声明全局符号main；
.type：声明一个符号是数据类型还是函数类型；
(2)数据
-字符串
printf 函数的参数：
.LC0:
	.string	"\347\224\250\346\263\225: hello \345\255\246\345\217\267 \345\247\223\345\220\215 \347\247\222\346\225\260 "
.LC1:
	.string	"Hello\343\200\200 %s %s n"
(2). 局部变量i
局部变量i存放在栈上，距离%ebp-4的地址的内存中。
(3). 常量
4和8在汇编语言中为立即数。
(4). int argc
main函数中的参数argc直接被存储到了-20(%ebp)的位置。
(5). char *argv[]
由程序可以看出argv的起始地址被保存在了-32(%ebp)的位置。通过相对寻址的方式，获取需要的字符串的地址，获取的是argv[1]的地址。
(3)赋值
源程序中设计一个赋值,将局部变量i初始化为0。这种赋值我们主要是按照这个变量的类型的长度，通过mov赋值。
1 byte：movb；
1 word：movw；
2 words：movl；
4 words：movq；

(4)Sizeof
i、argc均为int类型大小为4字节，argv为指针类型大小8字节。
(5)atoi
C源文件中调用了atoi()函数将字符串argv[3]转变成整型变量。
(6)算术操作
i++：利用addl，给i加1。
汇编中，主要有以下算术运算：ADD(加)、SUB(减)、INC(加1)、DEC(减1)、AND(并)、XOR(异或)、NEG(取反)、MUL(乘)、DIV(除)等等。
(7)关系操作
在C语言文件中,关系操作主要有两个，一个是 if(argc!=4)，另外一个是i<8。关系操作主要有两种比较方式test(类似and)和cmp(类似sub)，设置条件码。根据条件码，选择跳转的位置，通过jcc(ja、je、jne、js、jns、jae、jbe、jb、jl、jle、jg、ge)进行跳转。
(1). argc!=4：利用cmpl对比立即数4与agrc进行比较；
(2). i<8：利用cmpl对比立即数8与i进行比较；
(8)数组/指针/结构操作
(1). argv[2]：由于argv存在-32(%rbp)中，第一步利用movq取到argv[0]，然后argv[]为指针类型大小为8位，所以%rax加16得到argv[2]，再将其传给%rdx作为printf函数的第三个参数。
(2). argv[1]：由于argv存在-32(%rbp)中，第一步利用movq，取到argv[0]，然后argv[]为指针类型大小为8位，所以%rax加8得到argv[1]，再将其传给%rsi作为printf函数的第二个参数。
(3). argv[3]：由于argv存在-32(%rbp)中，第一步利用movq取到argv[0]，然后argv[]为指针类型大小为8位，所以%rax加24得到argv[3]，再将其传给%rdi作为atoi函数的第一个参数。
(9)控制转移
(1). if(argc!=4){}
利用cmpl对比立即数4与agrc进行比较，若等于就跳过{}跳转到.L2的位置，也就是创立局部变量i并初始化为0，以及之后的操作；若不等就进行{}中的操作比较argc与4的大小，打印提示信息。
(2). for(i=0;i<8;i++){} 
通过比较局部变量i与7的大小。如果小于等于，则跳转到.L4的位置，继续执行printf()和sleep()函数；否则，继续向下执行。
(10)函数操作
调用call指令，会将返回地址先压栈。进入函数中，我们要保存被调用者保护的寄存器，使用 push，在结束的时候pop，并ret返回到我们之前压入栈中的返回地址。
-调用exit
用%edi作为传入的参数，然后调用exit。
-调用printf
用%edi、%esi、%edx作为传入的三个参数，然后调用printf。
-调用atoi
用%edi作为传入的参数，然后调用atoi，返回值存在%eax中。 
-调用sleep
用%edi作为传入的参数，然后调用sleep。

2.8 实验：IA32基本汇编指令
2.8.1 汇编语言-常用指令
阅读以下汇编程序4-1.s：
.text					
.global _start			
_start:
	movl 	$0x100,%eax		
	movl 	$0x200,%ecx
	leal 	0x12(%esp,%eax),%ebx	
	movl 	0x12(%esp,%eax),%ebx	
	incl 	%eax					
	decl 	%ecx			
	movl	$0xFFFF,%eax
	neg 	%eax				
	not 	%eax					
	movl 	$0x100,%eax
	movl 	$0x200,%ecx
	addl 	%ecx,%eax		
	subl 	%eax,%ecx		
	movl 	$100,%eax
	movl 	$200,%ebx
	imul 	%ebx,%eax		
	movl 	$0xffffffff,%eax
	xorl 	$0xffffffff,%eax
	orl  	$0xffffffff,%eax	
	andl 	$0,%eax				
	movl 	$0x1,%eax
	sal  	$2,%eax				
	sar  	$2,%eax				
	shr  	$2,%eax				
	movl 	$0,%ebx			
	movl 	$1,%eax			
	int  	$0x80				
(1) 为每行代码添加注释，说明每条语句功能。
(2) 用gdb进行调试程序，注意下划线语句对EFLAG寄存器中的OF/CF/SF/ZF等标志位的影响。
  

作业截图1 EFLAG寄存器中的OF/CF/SF/ZF标志位变化
(3)解释EFLAG寄存器中的OF/CF/SF/ZF标志位的变化。

2.8.2 汇编语言-常用指令
(1)编程实现以下各种操作：
-给定一个short型数据-12345，分别转换为int、unsigned short、unsigned int、float类型的数据。
-给定一个int型数据2147483647，分别转换为short、unsigned short、unsigned int、float类型的数据；
-给定一个float型数据123456.789e5，转换成double型数据；
-给定一个double型数据123456.789e5，转换成float型数据；
-按short和unsigned short类型分别对-12345左移2位和右移2位；

(2)试解释：在1)中，short转换为unsigned int，16进制输出为什么是0xffffcfc7；在2)中，int转换为short后，16进制输出为什么是0x ffffffff?
#include <stdio. h>
int main( ) {
short s = - 12345;
int i = (int)s;
unsigned short us = (unsigned short)s;
unsigned int u = (unsigned int)s;
float	 f = (float)s;
printf(" int:			%10d \t %#10x\n",i,i) ;
printf ("unsigned short :		%10hu t%#10hx\n",us,us) ;
printf("unsigned int :	%10u \t %#10x\n",u,u) ;
printf("float :	%10d \t%#10x\n" , *(unsigned int*)&f, *(unsigned int*)&f) ;
return 0;
}
 作业截图2 测试程序截图
运行结果：
[root@localhost ex05 ]# ./test51
int：	-12345	0xffffcfc7
unsigned short： 	53191	0xcfc7
unsigned int：    	4294954951	0xffffcfc7
float：	-968825850	0xc640e400
 作业截图3 运行结果截图
运行结果的解释：
(3)调试程序，查看对应的位扩展、位截断与移位运算汇编指令。
#include <stdio. h>
int main(){
short a =-12345;
int b=2147483647;
float c=123456.789e5;
float d=123456789.e5;
short e =-12345;
unsigned short f =-12345;
printf("short to int: 0x%x,%d\n", (int)a,(int)a);
printf("short to unsigned short:0x%x,%u\n”,(unsigned short)a, (unsigned short)a);
printf("short to unsigned int 0x%x, %u\n", (unsigned int)a,(unsigned int)a);
float x =(float)a;
printf("short to float:0x%x,%d\n”,*(unsigned int*)(&x),*(unsigned int*)(&x));
printf("\n");
printf("int to short：0x%x,%d\n",(short)b,(short)b)；
printf("int to unsigned short：0x%x,%u\n",(unsigned short)b,(unsigned short)b)；
printf("int to unsigned int：0x%x,%u\n",(unsigned int)b,(unsigned int)b)；
x=(float)b；
printf("int to float：0x%x,%d\n",*(unsigned int*)(&x),*(unsigned int*)(&x))；
printf("\n")；
double y=(double)c；
printf("float to double：0x%x,%d\n"，*(unsigned int*)(&y),*(unsigned int*)(&y))；
printf("\n");
x=(float)d；
printf("int to float：0x%x,%d\n"，*(unsigned int*)(&x),*(unsigned int*)(&x))；
printf("\n")；
short e1=e<<2；
shorte2=e>>2；
printf("short<<2：0x%x,%d\n",e1,e1)；
printf("short>>2：0x%x,%d\n",e2,e2)；
printf("\n")；
unsigned short f1=f<<2；
unsigned short f2=f>>2；
printf("unsigned short<<2：0x%x,%d\n"，f1,f1)；
printf("unsigned short>>2：0x%x,%d\n"，f2,f2)；
printf("\n")；
}
作业截图4 位扩展、位截断与移位运算测试程序截图
$ ./test2
short to int：0xffffcfc7，-12345
short to unsigned short：0xcfc7，53191
short to unsigned int：0xffffcfc7，4294954951
short to float：0xc640e400，-968825856
int to short：0xffffffff，-1
int to unsigned short：0xffff，65535
int to unsigned int：0x7fffffff，2147483647
Int to float：0x4f000000，1325400064
float to double：0xe0000000，-536870912
int to float：0x5533a73d，1429448509
short<<2：0x3f1c，16156
short>>2：0xfffff3f1，-3087
unsigned short<<2：0x3f1c，16156
unsigned short>>2：0x33f1，13297
作业截图5 位扩展、位截断与移位运算测试结果截图

2.8.3 汇编语言-移位运算指令
阅读以下程序代码4-2，左侧为test函数的C代码，右侧为对应的汇编代码，横线处为缺少的汇编语句，为右侧已有的汇编语句添加注释，并补充缺少的语句，请使用算术右移操作。注意参数x和n分别存放在存储器中相对于寄存器EBP中地址偏移8和12的地方。
用gcc对C代码进行汇编，进行验证（给出汇编代码截图，注意编译器优化选项用-O1）

作业截图6 汇编语言源程序

2.8.4 汇编语言-位运算指令
阅读以下程序代码4-3，左侧为suan1函数的C代码，右侧为对应的汇编代码，为右侧已有的汇编语句添加注释。注意参数x、y和z分别存放在存储器中相对于寄存器EBP中地址偏移8、12和16的地方。

2.8.5 汇编程序与C语言程序的对应关系
阅读以下程序代码4-4，左侧为suan2函数的C代码，右侧为对应的汇编代码。根据右侧的汇编，填写左侧缺少的C语言代码。注意参数x，y，z分别存放在存储器中相对于寄存器%ebp中偏移8、12和16的地方。
用gcc对C代码进行汇编，进行验证（给出汇编代码截图，注意编译器优化选项用-O1）

作业截图7 汇编语言源程序
思考题：
(1).你的机器字长多少位？
(2).在C语言编程中，为什么我们以前不了解整数运算的溢出也没有问题？在以后的编程中，应该在什么时候考虑溢出？
(3).为什么[A+B]补=[A]补+[B]补？
(4).为什么A-B=A+B+1=A+[B]补？

APPENIDIX	 G
IA32的常用汇编指令
G.1 数据传输指令组
1.1 MOV传送指令

1.2 XCHG交换指令

1.3 堆栈相关指令
（1）PUSH（进栈）

8086汇编中，push/pop的一律是字，寄存器/存储单元/立即数参数可以直接写而不加word ptr前缀 。386之后支持了双字的push/pop，如果汇编程序中加了.386伪指令，就会默认push/pop双字。对于存储单元/立即数最好加word ptr/dword ptr前缀。

（2）POP（出栈）

（3）PUSHA（16位通用寄存器全进栈指令）

（4）POPA（16位通用寄存器全出栈指令）

（5）PUSHAD（32位通用寄存器全进栈指令）

（6）POPAD（32位通用寄存器全出栈指令）

1.4  符号扩展相关指令
（1）CBW（字节转换为字指令）

（2）CWD（字转换为双字指令）

（3）CWDE（字转换为双字指令）

（4）CDQ（双字转换为四字指令）

1.5 扩展传送相关指令
（1）MOVSX（符号扩展传送）

（2）MOVZX（零扩展传送）

G.2 算数运算指令组
2.1  NEG（取负数指令）

CMP（比较指令）

2.3 加法相关指令
（1）ADD（加法指令）

（2）ADC(带进位加)

2.4 减法
（1）SUB（减法指令）

（2）SBB (带借位减)

2.5  乘法
（1）MUL无符号数乘法

IMUL有符号数乘法(单操作数乘法指令)

注：    
双操作数和三操作数的结果可能溢出，若溢出就截掉高位。
（1）双操作数乘法指令

（2）三操作数乘法指令

2.6 除法
（1）DIV（无符号数除法指令）

（2）IDIV（有符号数除法指令）

2.7  加一减一
（1）INC（加1指令）

DEC（减1指令）

G.3 逻辑运算指令
3.1  NOT（否运算指令）

AND（与运算指令）

3.3  OR（或运算指令）
常用OR EAX,EAX这样的方法判断是否为0。

XOR（异或运算指令）

3.5 TEST（按位测试指令）
test指令一般用来检测指定位上字符是否都为0。

G.4 移位指令组

4.1  SAL / SHL / SAR / SHR（一般移位指令）
4.2  ROR / ROL / RCR / RCL（(带进位)循环移位指令)

SHLD / SHRD （双精度移位指令）


G.5 转移指令组
5.1  JMP（无条件转移）
5.2 Jcc（条件转移）

5.3 循环相关指令
（1）LOOP（计数循环指令）


（2）LOOPE/LOOPZ（等于/全零循环指令）

（3）LOOPNE/LOOPNZ（不等于/全1循环指令）

先减1比0，再比ZF。把ecx设-1，退出时not ecx值会比预期的小1。比如，用这个来算字符串长度，用 ‘\0’ 判断退出循环，长度会把 ‘\0’ 也算上 。

（4）JECXZ/JCXZ（计数器转移指令）

CALL（过程调用指令）


RET（返回指令）


G.6 字符串操作指令组
串地址：
DS:ESI指向源串；
ES:EDI指向目的串；
操作方向：
DF=0，低地址 → 高地址；
DF=1，高地址 → 低地址；

6.1  LODSB/LODSW/LODSD（字符串装入指令）



STOSB/STOSW/STOSD（字符串存储指令）



6.3  MOVSB/MOVSW/MOVSD（字符串传送指令）



6.4  SCASB / SCASW / SCASD（字符串扫描指令）

6.5  CMPSB/ CMPSW/ CMPSD（字符串比较指令）
6.6  REP/REPE(REPZ)/REPNE(REPNZ)（重复操作前缀）
REPE(REPZ) / REPNE(REPNZ)的退出时机：以下这两组指令，当以ZF为基准退出时，会把最后使ZF改变的那次比较也计数（因为这次比较后ZF才改变）。比如，用这个来算字符串长度，用 ‘\0’ 判断退出循环，长度会把 ‘\0’ 也算上。


G.7 位操作指令组
7.1  位测试指令组
（1）BT（位测试指令）

（2）BTC（位测试并取反指令）

（3）BTR（位测试并复位指令）

（4）BTS（位测试并置位指令）
7.2  BSF / BSR （顺向/逆向位扫描指令）
G.8 条件设置指令组
8.1  SETcc（条件设置字节指令）

cc的取值如下：

G.9 其他指令
9.1  LEA（取有效地址指令）
LAHF/SAHF（状态标志操作指令）

CLC / STC / CMC（进位标志CF设置指令）

G10 CLD /STD（方向标志DF操作指令）



3.C语言程序的机器级表示
用任何汇编语言或高级语言编写的源程序最终都必须翻译（汇编、解释或编译）成以指 令形式表示的机器语言，才能在计算机上运行。本节简单介绍高级语言源程序转换为机器代码 过程中涉及的一些基本问题。为方便起见，本节选择具体语言进行说明，高级语言和机器语言 分别选用 C 语言和 IA-32 指令系统。其他情况下，其基本原理不变。
3.1过程调用的机器级表示
程序员可使用参数将过程与其他程序及数据进行分离。调用过程只要传送输入参数给被调 用过程， 最后再由被调用过程返回结果参数给调用过程。引入过程使得每个程序员只需要关注 本模块中函数或过程的编写任务。本书主要介绍 c 语言程序的机器级表示，而 c 语言用函数来 实现过程，因此，本书中的过程和函数是等价的。
将整个程序分成若干模块后，编译器对每个模块可以分别编译。为了彼此统一，并能配合操 作系统工作，编译的模块代码之间必须遵循一些调用接口约定，这些约定由编译器强制执行，汇 编语言程序员也必须强制按照这些约定执行，包括寄存器的使用、栈帧的建立和参数传递等。

3.1.1.IA-32 中用于过程调用的指令
在 3. 3.4 节中提到的调用指令 CALL 和返回指令 RET 是用于过程调用的主要指令，它们都 属于一种无条件转移指令，都会改变程序执行的顺序。为了支持嵌套和递归调用，通常利用栈 来保存返回地址、入口参数和过程内部定义的非静态局部变量，因此，CALL 指令在跳转到被调 用过程执行之前先要把返回地址压栈，RET 指令在返回调用过程之前要从栈中取出返回地址。

3.1.2.过程调用的执行步骤
假定过程 P 调用过程 Q,则 P 称为调用者,Q 称为被调用者。过程调用的执行步骤如下。
P将入口参数（实参）放Q能访问到的地方。P将返回地址存到特定的地方，然后将控制转移到 Q。Q 保存 P 的现场，并为自己的非静态局部变量分配空间。执行Q 的过程体（函数体）。Q 恢复P现场，并释放局部变量所占空间。Q 取出返回地址，将控制转移到 P。
上述步骤中，第①~②步是在过程 P 中完成的，其中第②步是由 CALL 指令实现的，通过 CALL 指令， 将控制从过程 P 转移到了过程 Q。第③~⑥步都在被调用过程 Q 中完成，在执行 Q 过程体之前的第③步通常称为准备阶段，用于保存 P 的现场并为 Q 的非静态局部变量分配空 间，在执行 Q 过程体之后的第⑤步通常称为结束阶段，用于恢复 P 的现场并释放 Q 的局部变 量所占空间，最后在第⑥步通过执行 RET 指令返回到过程 p。每个过程的功能主要是通过过程 体的执行来完成的。如果过程 Q 有嵌套调用的话，那么在 Q 的过程体和被 Q 调用的过程函数 中又会有上述 6 个步骤的执行过程。

小贴士
因为每个处理器只有一套通用寄存器，所以通用寄存器是每个过程共享的资源，当从 调用过程跳转到被调用过程执行时，原来在通用寄存器中存放的调用过程的内容，不能因 为被调用过程要使用这些寄存器而被破坏掉，因此，在被调用过程使用这些寄存器前，在 准备阶段先将寄存器中的值保存到栈中，用完以后，在结束阶段再从栈中将这些值重新写 回到寄存器中，这样，回到调用过程后，寄存器中存放的还是调用过程中的值。通常将通 用寄存器中的值称为现场。并不是所有通用寄存器中的值都由被调用过程保存，通常调用过程保存一部分，被调 用过程保存一部分。每个 ISA 都会有一个寄存器使用约定,其中会规定哪些寄存器由调用 者保存，哪些由被调用者保存。

3.1.3.过程调用所使用的栈
从上述执行步骤来看，在过程调用中，需要为入口参数、返回地址、调用过程执行时用到 的寄存器、被调用过程中的非静态局部变量、过程返回时的结果等数据找到存放空间。如果有足够的寄存器，最好把这些数据都保存在寄存器中，这样，CPU 执行指令时，可以快速地从寄 存器取得这些数据进行处理。但是，用户可见寄存器数量有限，并且它们是所有过程共享的， 某时刻只能被一个过程使用；此外，对于过程中使用的一些复杂类型的非静态局部变量（如数 组和结构等类型数据）也不可能保存在寄存器中。因此，除了寄存器外，还需要有一个专门的 存储区域来保存这些数据，这个存储区域就是建（stack）o 那么，上述数据中哪些存放在寄存 器，哪些存放在栈中呢？寄存器和栈的使用又有哪些规定呢？

3.1.4.IA-32 的寄存器使用约定
尽管硬件对寄存器的用法几乎没有任何规定，但是，因为寄存器是被所有过程共享的资 源，若一个寄存器在调用过程中存放了特定的值％,在被调用过程执行时，它又被写入了新的 值 y,那么当从被调用过程返回到调用过程执行时，该寄存器中的值就不是当初的值 x,这样， 调用过程的执行结果就会发生错误。因而，在实际使用寄存器时需要遵循一定的惯例，使机器 级程序员、编译器和库函数等都按照统一的约定处理。
1A-32 规定，寄存器 EAX、ECX 和 EDX 是调用者保存寄存器。当过程 P 调用过程 Q 时，Q 可以直接使用这三个寄存器，不用将它们的值保存到栈中，这也意味着，如果 P 在从 Q 返回后 还要用这三个寄存器的话，P 应在转到 Q 之前先保存它们的值，并在从 Q 返回后先恢复它们的 值再使用。寄存器 EBX、ESI、EDI 是被调用者保存寄存器,Q 必须先将它们的值保存到栈中 再使用它们，并在返回 P 之前先恢复它们的值。还有另外两个寄存器 EBP 和 ESP 则分别是帧 指针寄存器和栈指针寄存器，分别用来指向当前栈帧的底部和顶部。

3.1.5.IA-32 的栈、栈帧及其结构
IA-32 使用栈来支持过程的嵌套调用,过程的入口参数、返回地址、被保存寄存器的值、 被调用过程中的非静态局部变量等都会被压入栈中。IA-32 中可通过执行 MOV、PUSH 和 POP 指令存取栈中元素，用ESP 寄存器指示栈顶，栈从高地址向低地址增长。
每个过程都有自己的栈区，称为栈帧処（stack frame）,因此，一个栈由若干栈帧组成，每个 栈帧用专门的帧指针寄存器 EBP 指定起始位置。因而，当前栈帧的范围在帧指针 EBP 和栈指 针 ESP 指向区域之间。过程执行时，由于不断有数据入栈，所以栈指针会动态移动，而帧指针 可以固定不变。对程序来说，用固定的帧指针来访问变量要比用变化的栈指针方便得多，也不 易出错，因此，在一个过程内对栈中信息的访问大多通过帧指针 EBP 进行。
假定 P 是调用过程，Q 是被调用过程。图 3. 10 给出了 IA-32 在过程 Q 被调用前、过程 Q 执行中和从 Q 返回到过程 P 这三个时点栈中的状态变化。
在调用过程 P 中遇到一个函数调用（假定被调用函数为 Q）时，在调用过程 P 的栈帧中保 存的内容。如图 3. 10a 所示。首先，P 确定是否需要将某些调用者保存寄存器保存到自己的栈帧 中；然后，将入口参数按序保存到 P 的栈帧中，参数压栈的顺序是先右后左；最后执行 CALL 指令，先将返回地址保存到 P 的栈帧中，然后转去执行被调用过程 Q。在执行被调用函数 Q 的准备阶段，在 Q 的栈帧中保存的内容如图 3. iOb 所示。首先，Q 将 EBP 的值保存到自己的栈帧（被调用过程 Q 的栈帧）中，并设置 EBP 指向它，即 EBP 指向当 前栈帧的底部；然后， 根据需要确定是否将被调用者寄存器保存到 Q 的栈帧中；最后在栈中为 Q 中的非静态局部变量分配空间。器，则编译器会将通用寄存器分配给局部变量，但是，对于非静态局部变量是数组或结构等复 杂数据类型的情况，则只能在栈中为其分配空间。在 Q 过程体执行后的结束阶段，Q 会恢复被调用者保存寄存器和 EBP 寄存器的值，并使 ESP 指向返回地址，这样，栈中的状态又回到了开始执行 Q 时的状态，如图 3. 10c 所示。这 时，执行 RET 指令便能取出返回地址，以回到过程 P 继续执行。
图 3-1 过程调用过程中栈和栈帧的变化
从图 3-1 可看出，在 Q 的过程体执行时，入口参数 1 的地址总是 R[ebp]+8,后面若干 入口参数的地址只要在此地址基础上加上相应数据类型对应的字节数即可。

变量的作用域和生存期
从图 3. 10 所示的过程调用前、后栈的变化过程可以看出，在当前过程 Q 的栈帧中保存的 Q 内部的非静态局部变量只在 Q 执行过程中有效，当从 Q 返回到 P 后，这些变量所占的空间全 部被释放，因此， 在 Q 过程以外，这些变量是无效的。了解了上述过程，就能很好地理解 C 语 言中关于变量的作用域和生存期的问题。C 语言中的 auto 型变量就是过程（函数）内的非静态 局部变量，因为它是通过编译器动态、自动地在栈中分配并在过程结束时释放，因而其作用域 仅限于过程内部且具有的仅是“局部生存期”。此外，auto 型变量可以和其他过程中的变量重名, 因为其他过程中的同名变量实际占用的是自己栈帧中的空间或静态数据区，也就是说，变量名虽 相同但实际占用的存储单元不同，它们分别在不同的栈帧中， 或一个在栈中另一个在静态数据区 中。C 语言中的外部参照型变量和静态变量被分配在静态数据区，而不是分配在栈中，因而这些 变量在整个程序运行期间一直占据着固定的存储单元，它们具有“全局生存期”。

3.1.7.一个简单的过程调用例子
下面以一个最简单的例子来说明过程调用的机器级实现。假定有一个过程 add 实现两个数 相加，另一个过程 caUer 调用 add 以计算 125 +80 的值，对应的 C 语言程序如下。

经 GCC 编译后 caller 过程对应的代码如下(〃后面的文字是注释)。

图3-2，假定 caller 被过程 P 调用。图中 ESP 的位置是执 行了第 4 条指令后 ESP 的值所指的位置，可以看出 GCC 为 caller 的参数分配了 24 字节的空间。 从汇编代码中可以看出，caller 中只使用了调用者保存寄存器 EAX,没有使用任何被调用者保 存寄存器，因而在caller 栈帧中无需保存除 EBP 以外的任何寄存器的值；caller 有三个局部变量 tempi , tempi 和 sizm,皆被分配在栈帧中；在用call 指令调用 add 函数之前，caller 先将入口参数，从右向左依次将 tempi 和 tempi 的值（即 80 和125）保存到栈中。在执行 call 指令时再把返回地址压入栈中。此外，在最初进入 caller 时，还将EBP 的值压入了栈中，因此 caller 的栈帧中用到的空间占 4 +12+8+4 =28 字节。但是，caller 的栈帧总共有 4 +24+4 =32 字节，其中浪费了 4 字节空间（未使用）。这是因为 GCC 为保证 x86 架构中数据的严格对齐而规定每个函数的栈帧大小必须是 16 字节的倍数。有关对齐规则，在后续的章节中介绍。

图3-2 caller和add的栈
call 指令执行后，add 函数的返回参数存放在EAX 中，因而 call 指令后面的两条指令中，序号为 12 的 movl 指令用来将 add 的结果存入 sum 变 量的存储空间，其变量的地址为 R[ebp]-4;序号为 13 的 movl 指令用来将 sum 变量的值送返回 值寄存器 EAX 中。
      在执行 ret 指令之前，应将当前栈帧释放掉并恢复旧 EBP 的值，上述序号为 14 的 leave 指 令实现了这个功能，leave 指令功能相当于以下两条指令的功能。其中，第一条指令使 ESP 指 向当前 EBP 的位置，第二条指令执行后，EBP 恢复为 P 中的旧值，并使 ESP 指向返回地址。

执行完 leave 指令后，ret 指令就从 ESP 所指处取返回地址，以返回 P 执行。当然，编译器 也可通过 pop 指令和对 ESP 的内容做加法来进行退栈操作，而不一定要使用 leave 指令。
add 过程比较简单，经 GCC 编译并进行链接后对应的代码如下。

通常，一个过程对应的机器级代码都有三个部分：准备阶段、过程体和结束阶段。
上述序号 1 和 2 的指令构成准备阶段的代码段，这是最简单的准备阶段代码段，它通过将 当前栈指针 ESP 传送到 EBP 来完成将 EBP 指向当前栈帧底部的任务，如图 3.11 所示，EBP 指 向 add 栈帧底部，从而可以方便地通过 EBP 获取入口参数。这里 add 的入口参数 x 和〉对应的 值（125 和 80）分别在地址为
R[ebp]+8、R[ebp] +12 的存储单元中。
上述序号 3、4 和 5 的指令序列是过程体代码段，过程体结束时将返回值放在 EAX 中。这 里好像没有加法指令，实际上序号 5 的 lea 指令执行的是加法运算 R[edx] +R[eax] *l=x+y。
上述序号 6 和 7 的指令序列是结束阶段代码，通过将 EBP 弹出栈帧来恢复 EBP 在 caUer 过 程中的值， 并在栈中退出 add 过程的栈帧，使得执行到 ret 指令时栈顶中已经是返回地址。这 里的返回地址应该是
caller 代码中序号为 12 的那条指令的地址。
add 过程中没有用到任何被调用者保存寄存器，没有局部变量，此外，add 是一个被调用 过程，并且不再调用其他过程，即它是个叶子过程，因而也没有入口参数和返回地址要保存, 因此，在 add 的栈帧中除了需要保存 EBP，以外，无需保留其他任何信息。

3.1.8.按值传递参数和按地址传递参数
使用参数传递数据是 C 语言函数间传递数据的主要方式。C 语言中的数据类型分为基本数据类型和复杂数据类型,而复杂数据类型中又分为构造类型和指针类 型。C 语言的数据类型如图 3.12 所示。





图 3. 12 C 语言中的数据类型
C 函数中的形式参数可以是基本类型变量名、构造类型变量名和指针类型变量名。对于不 同类型的形式参数，其传递参数的方式不同，总体来说分为两种：按值传递和按地址传递。当 形参是基本类型变量名时，采用按值传递方式；当形参是指针类型变量名或构造类型变量名 时，釆用按地址传递方式。显然，上面的 add 过程采用的是按值传递方式。
下面通过例子说明两种方式的差别。图 3.3 给出了两个相似的程序。
图 3. 3 按值传递参数和按地址传送参数的程序示例
上述图 3. 3 中两个程序的输出结果如图 3. 14 所示
图 3. 4 图 3. 3 中程序的输出结果
从图 3. 4 可看出，程序一实现了 a 和 3 的值的交换，而程序二并没有实现对 a 和 6 的值进 行交换的功能。下面从这两个程序的机器级代码来分析为何它们之间有这种差别。
首先，看一下这两个程序栈帧内容有何差别，图 3. 5 中的粗体字处给出了它们之间的 差别。

                      图 3. 5 执行 swap 之前 main 的栈帧状态
如图 3.5 所示，它们在栈中的状态仅在于压入栈中的参数不同。在图 3.15a 所示的程序 一中，main 函数把变量 a 和 3 的地址作为实参压入了栈中，而在图 3.15b 所示的程序二中，则 把变量 a 和 b 的值作为实参压入了栈中。
程序一和程序二对应的 swap 函数的机器级代码也不同。图 3. 16 中给出两个程序对应的参 数传递代码和 swap 函数的汇编代码（AT&T 格式），不同之处用粗体字表示。给出的代码假定 swap 函数的局部变量 t 分配在 EDX 中

图 3. 6 两个程序对应的汇编代码片段
从图 3. 6 可看出，在给 swap 过程传递参数时，程序一用了 leal 指令，而程序二用的是 movl 指令，因而程序一传递的是 a 和 8 的地址，而程序二传递的是。和、的内容。
从图 3. 6 可看出，程序一的 swap 过程体比程序二的 swap 过程体多了三条指令。而且，由 于程序一的 swap 过程体更复杂，使用了较多的寄存器，除了三个调用者保存寄存器外，还使 用了被调用者保存寄存器 EBX,它的值必须在准备阶段被保存到栈中，而在结束阶段从栈中恢 复。因而它比程序二又多了一条 push 指令和一条 pop 指令。
图 3. 7 反映了执行 swap 过程后 main 的栈帧中的状态，与图 3.15 中反映的执行 swap 前的 情况进行对照发现，粗体字处发生了变化。
因为程序一的 swap 函数的形式参数，和 y 用的是指针型变量名，相当于间接寻址，需要先 取出地址，然后根据地址再存取*和，的值，因而改变了调用过程 main 的栈帧中局部变量 a 和3 所在位置的内容，如图 3. 17a 中粗体字所示；而程序二中的 swap 函数的形参 x 和 y 用的是基 本数据类型变量名，直接存取，和 y 的内容，因而改变的是 swap 函数的入口参数，和 y 所在位 置的值，如图3. 7b 中粗体字所示。

图 3. 7 执行 swap 之后 main 的栈帧状态
至此，我们分析了程序一和程序二之间明显的差别。由这些差别造成的最终结果的不同是重要的。这个不同就是，程序一中调用 swap 后回到 main 执行时，a 和的值已经交换过了， 而在程序二的执行中，swap 过程实际上交换的是其两个入口参数所在位置上的内容，并没有真正交换 a 和 6 的值。由此，也就不难理解为什么会出现如图 3. 4 所示的两个程序的执行结果了。
从上面对例子的分析中可以看出，编译器并不为形式参数分配存储空间，而是给形式参数对应的实参分配空间，形式参数实际上只是被调用函数使用实参时的一个名称而已。不管是按值传递参数还是按地址传递参数，在调用过程用 CALL 指令调用被调用过程时，对应的实参应该都已有具体的值，并已将实参的值存放到调用过程的栈帧中作为入口参数，以等待被调用过程中的指令所用。例如，在图 3. 13 所示的程序一中，main 函数调用 swap 函数的实参是&a 和&b,在执行 CALL 指令调用 swap 之前，&a 和歸的值分别是 R[ebp]-4 和 R[ebp]-8。在如图 3. 3 所示的程序二中，main 函数调用 swap 函数的实参是 a 和虹 在执行 CALL 指令调用
swap 之前，a 和 6 的值分别是 15 和 22o
需要说明的是，在 IA-32 中，若栈中存放的参数的类型是 char、unsigned char 或 short、unsigned short,也都分配 4 个字节。因而，在被调用函数的执行过程中，可以使用 R[ebp]+8、R[ebp]+12、R[ebp]+16、……作为有效地址来访问函数的入口参数。
例  下是两个 C 语言函数：

假定调用 caller 的过程为 P, P 中给出的对应 caller 中形参 a 和 y 的实参分别是常数 100 和 200,对于上述两个 C 语言函数，画出相应的栈帧中的状态，并回答下列问题。
test 的形参是按值传递还是按地址传递？ test 的形参 ptr 对应的实参是一个什么类型 的值？ test中被改变的*ptr的结果如何返回给它的调用过程caller? caller 中被改变的丁的结果能否返回给过程 P?为什么？
O P、caller 和 test 对应的栈帔状态如图 3. 8 所示。根据图 3. 8 中所反映的栈帧状态， 可以比较容易地给出以下答案。

图 3. 8 执行 caUer 之前和执行 test 之前的栈帧状态
test 的两个形参中，前者是基本数据类型变量名，后者是指针类型变量名，因此前者按 值传递，后者按地址传递。形参 P"是指向血型的一个指针，因而对应的实参一定是一个地 址。形参 ptr 对应的实参的值反映了实参所指向的目标数据所在的存储地址。若这个地址是栈 区的某个地址，则说明这个目标数据是个非静态局部变量；若是静态数据区的某个地址，则说 明这个目标数据是个全局变量或静态变量。此例中，形参 ptr 对应的实参所指目标数据就是栈 中的 y （即 200）,即实参为 y 所在的存储单元地址，因而在 caller 中用一条取地址指令 lea 可以 得到这个地址，这个地址就是&y。test 执行的结果反映在对形参ptr 对应实参所指向的目标单元进行的修改，这里是将200 修改为300。因为所修改的存储单元不在 test 的栈帧内，不会因 test 栈帧的释放而丢失，因而 y 的值可在 test 执行结束后继续在 caller 中使用。也即第 10 行语句执行后，y 的值为 300。
caller 执行过程中对'所在单元内容的改变不能返回给它的调用过程 P。caller 执行的结 果就是调用 test 后由 test 留下的对地址&y 处所做的修改，也即 200 被修改为 300 ,虽然这个修 改结果不会因为 caller 栈帧的释放而丢失，似乎在过程 P 中可以访问到这个结果，但是，当从caller 回到过程 P 后，caller 的形参 y 并不能被 P 所用。P 中无法通过 y 对存储单元&y 进行引 用。因而 y的值 300 不能在 caller 执行结束后继续传递到 P 中。

3.1.9  递归过程调用
过程调用中使用的栈机制和寄存器使用约定，使得可以进行过程的嵌套调用和递归调用。 下面用一个简单的例子来说明递归调用过程的执行。
以下是一个计算自然数之和的递归函数（自然数求和可以直接用公式计算，这里的程序仅 是为了说明问题而给出的）。

上述递归函数对应的汇编代码（AT&T 格式）如下。图 3. 19 给岀了第 3 次进入递归调 用（即第三次执行完“callnn_sum”指令）时栈帧中的状态，假定最初调用 nn_sum 函数的是过程 P。


图 3. 9 递归过程 nn_sum 的栈
递归过程 nn_sum 对应的汇编代码中，用到了一个被调用者保存寄存器 EBX,所以其栈帧 中除了保存常规的 EBP 外，还要保存 EBX。过程的入口参数只有一个，因此，序号 5 对应的指 令“subl$4, %esp” 实际上是为参数 n-l（或 n-2 或…或 1 或 0）在栈帧中申请了 4 字节的空 间，递归过程直到参数为。时才第一次退出 nn_sum 过程，并回到序号为 12 的指令 call nn_sum 的后面一条指令（序号为 13 的指令）执行。在递归调用过程中，应该每次都回到同样的地方 执行，因此，图 3. 19 中的返回地址 2 和返回地址 3 是相同的，但不同于返回地址 1,因为返回 地址 1 是过程 P 中指令 call nn_sum 的后面一条指令的地址。

图 3. 10 递归过程 nn_sum 的执行流程
从图 3. 10 可看出，递归调用过程的执行一直要等到满足跳出过程的条件时才结束，这里 跳出过程的条件是入口参数为 0,只要入口参数不为 0,就一直递归调用 nn_sum 函数自身。因 此，在递归调用 nn_sum 的过程中，栈中最多会形成 n + 1 个 nn_sum 栈帧。每个 nn_sum 栈帧占 用了 16 字节的空间，因而 nn_sum 过程在执行中最多占用（16n + 12）字节的栈空间（以入口 参数为。调用 nn_sum 时，没有返回地址入栈，故只分配 12 字节）。虽然占用的栈空间都是临 时的，过程执行结束后其所占的所有栈空间都会被释放，但是，如果递归深度非常大的时候, 栈空间的开销还是比较大的。此外，过程调用的时间开销也不得不考虑。虽然过程的功能由过 程体中的指令来实现，但是，为了支持过程调用，每个过程中还包含了准备阶段和结束阶段。 每增加一次过程调用，就要增加许多条包含在准备阶段和结束阶段的额外指令，这些额外指令 的执行时间开销对程序的性能影响很大，因而，应该尽量避免不必要的过程调用，特别是递归调用。

3.1.10.原码

·容易理解,  但是：
 0 的表示不唯一，故不利于程序员编程
 加、减运算方式不统一
 需额外对符号位进行处理，故不利于硬件设计
 特别当 a<b时，实现 a-b比较困难
3.1.11.移码
·什么是移码
   将每个数值加上一个偏置常数（Excess/biase）
• 当编码位数为n时，通常Excess/biase取2n-1或2n-1-1（IEEE 754）
EX n=4: Ebiased=E+23(biase=23=1000B)
-8(+8)~0000B
-7(+8)~0001B
……
0(+8)~1000B
……
7(+8)~1111B
·0的移码表示唯一；
·当biase取2n-1，移码与补码仅第一位不同；
·移码表示浮点数的指数（阶码）
-便于浮点数加减运算时的对阶操作
-EX    1.01×2-1+1.11×23 
-==>>0.0000101×2-1+4+1.11×23
-补码: 111(-1)<011(3)
-移码: 011(3)<111(7)

3.1.12.补码
·重要概念：在一个模运算系统中，一个数与它除以“模”后的余数等价。
·时钟是一种模12系统
    假定钟表时针指向10点，要将它拨向6点，则有两种拨法：
     ① 倒拨4格：10- 4 = 6
     ② 顺拨8格：10+8 = 18 ≡ 6       (mod 12)
     模12系统中：       10- 4 ≡ 10+8 (mod 12) 
                                      - 4 ≡ 8       (mod 12) 
     称8是- 4对模12的补码 (即：- 4的模12补码等于8）。
                           同样有 -3 ≡ 9     （mod 12）
                                       -5 ≡ 7     （mod 12）等
·结论1：一个负数的补码等于模减该负数的绝对值。
·结论2：对于某一确定的模，某数减去小于模的另一数，总可以用该数加上另一数负数的补码来代替。
补码（modular运算）：+ 和– 的统一
·补码的表示
现实世界的模运算系统举例
例1：“钟表”模运算系统
   假定时针只能顺拨，从10点倒拨4格后是几点？
10- 4 = 10+(12- 4) = 10+8 = 6   （mod 12）

例2：“4位十进制数” 模运算系统
    假定算盘只有四档，且只能做加法，则在算盘上计算
    9828-1928等于多少？
9828-1928=9828+(104-1928)
                   =9828+8072
                   = 1 7900  
        	        =7900（mod 104）
·计算机中的运算器是模运算系统

结论1： 一个负数的补码等于对应正数补码的“各位取反、末位加1”
·运算器适合用补码表示和运算
-运算器只有有限位，假设为n位，则运算结果只能保留低n位，故可看成是个只有n档的二进制算盘，因此，其模为2n 。
-补码的定义    假定补码有n位，则：
[X]补= 2n + X   （-2n-1≤X＜ 2n-1 ，mod 2n）
-X是真值，[x]补是机器数
·求特殊的补码

32位机器中，int、short、char型数据的机器数各占几位？
·变形补码
变形补码：双符号位的补码表示，也称模４补码。其中左符是真正的符号位，右符用来指示溢出。
假定变形补码有n+1位(其中符号２位，数值n-1位):
                                   [XT]补＝2n+1+XT       (-2n-1≤XT<2n-1，mod 2n+1）
      
·补码与真值之间的简便转换
例: 设机器数有8位，求123和-123的补码表示，如何快速得到123的二进制表示？
简便求法：从右向左，第１个“１”不变，前面各位取反。
当机器数为16位时，结果怎样？


·真值与补码之间的简便转换
[A]补= an-1an-2…… a1a0
则： A= -an-1×2n-1+an-2×2n-2+ …… a1×21+ a0×20
-例如： 补码“1101 0110”的真值为
　　-27+26+24+22+2=-128+64+16+4+2=-42
-补码“0101 0110”的真值为
      -0×27+26+24+22+2=64+16+4+2=86
-简便求法：符号为0，则为正数，数值部分相同；
　　　　  符号为1，则为负数，数值各位取反，末位加1
     
·C语言支持的基本数据类型

整数类型分：无符号整数和带符号整数
3.2 PUSH和POP指令


3.2.1.控制转移指令
call指令和ret指令详细参见教材P113-114。
call指令：
(1).返回地址入栈（相当于PUSH EIP）；
(2).转到指定位置（相当于JMP Label）；
leave指令：
(1).movl %ebp，%esp
(2).popl %ebp
ret指令：将返回地址从栈顶取出送到EIP(POP EIP)。
            

图1栈中的帧结构（每个帧6个子部分）
3.2.2 过程与栈帧结构
一个过程调用包括将数据（以过程参数和返回值的形式）和控制从代码的一部分传递到另一部分。另外，它还必须在进入时为过程的局部变量分配空间，并在退出时释放这些空间。大多数机器，包括IA32，只提供转移控制到过程和从过程中转移出控制这种简单的指令。数据传递、局部变量的分配和释放通过操纵程序栈来实现。栈帧结构如图1所示。
3.2.4 寄存器使用惯例
寄存器%eax、%ecx、%edx被划分为调用者保存寄存器，%ebx、%esi、%edi被划分为被调用者保存寄存器。
3.2.5 过程调用的执行步骤
假定过程P调用过程Q，则P称为调用者，Q称为被调用者。过程调用的执 行步骤：
(1).P将入口参数（实参）放到Q能访问到的地方；
(2).P将返回地址存到特定的地方，然后将控制转移到Q；
(3).Q保存P的现场，并为自己的非静态局部变量分配空间；
(4).执行Q的过程体（函数体）；
(5).Q恢复P的现场，并释放局部变量所占空间；
(6).Q取出返回地址，将控制转移到P。
过程调用过程中栈和栈帧的变化如图2所示。 

图2 过程调用过程中栈和栈帧的变化
3.2.6 一个C过程的大致结构
(1)准备阶段
(1).形成帧底：push指令和mov指令；
(2).生成栈帧（如果需要的话）：sub指令或and指令；
(3).保存现场（如果有被调用者保存寄存器）：push指令；
(2)过程（函数）体
(4).分配局部变量空间，并赋值；
(5).具体处理逻辑，如果遇到函数调用时；
准备参数：将实参送栈帧入口参数处；
CALL指令：保存返回地址并转被调用函数；
(6).在EAX中准备返回参数；
(3)结束阶段
(7).恢复现场（如果保存了被调用者保存寄存器）：pop指令；
(8).退栈：leave指令或pop指令；
(9).取返回地址返回：ret指令。
3.2.7.gdb中查看栈帧信息-info frame解析
(gdb) info frame
stack level 0      						##跟踪的桢序号 
frame at 0xb75f7390						##当前栈桢的起始地址
eip = 0x804877f in base::func() (testing.cpp:16); saved eip 0x804869a
##当前eip内容，指令地址，也就是被调用函数中将要执行的下一条指令地址，testing.cpp中的第16行。调用函数的返回地址。从本栈桢退出后的指令位置。调用函数call被调用函数时入栈。
0x804845d为被调用的函数地址，0x8048524为调用函数的代码的地址
也就是：
0x804869a: call 0x804877f 
called by frame at 0xb75f73b0			##调用函数的栈桢
source language c++						##源程序的编程语言
Arglist at 0xb75f7388, args: this=0x0	##实参的起始地址
Locals at 0xb75f7388,					##局部变量的地址
Previous frame's sp is 0xb75f7390		##前一栈桢(调用者栈桢)的栈顶地址，也是被调用者栈桢的栈底地址
Saved registers: 						##被调用者保存的寄存器

3.3实验：过程的机器级表示
3.3.1. 汇编程序与C语言程序的对应关系-过程调用参数
假设某个C语言函数func的原型声明如下：
void func(int *xptr，int *yptr，int *zptr);
函数func的过程体对应的机器级代码用AT&T汇编形式表示如下：
movl 8(%ebp),%eax
movl 12(%ebp),%ebx
movl 16(%ebp),%ecx
movl (%ebp),%edx
movl (%ecx),%esi
movl (%eax),%edi
movl %edi,(%ebx)
movl %edx,(%ecx)
movl %esi,(%eax)

(1)根据上述机器级代码写出函数func的C语言代码。（给出函数func的C代码。提示：参数xptr、yptr、zptr分别存储在相对与寄存器EBP中的地址偏移是8、12和16的地方）
void func(int *xptr,int *yptr, int *zptr){
	int tempx = *xptr;
	int tempy = *yptr;
	int tempz = *zptr;
	*yptr = tempx;
	*zptr = tempy;
	*xptr = tempz;
}


(2)写出对应的C代码5-1.c之后，再用gcc -S -O1 5-1.c -o 5-1.s命令产生对应的汇编代码进行验证。（给出5-1.s代码截图）

作业截图1 C语言编译后汇编程序代码

3.3.2.观察栈帧-一般调用
阅读以下C程序代码：
//5-2.c
int swap_add(int *xp,int *yp){
int x = *xp;
int y = *yp;
*xp = y;
*yp = x;
return x + y;
}

int caller(){
int arg1 = 123;
int arg2 = 456;
int sum = swap_add(&arg1,&arg2);
int diff = arg1 - arg2;
return sum*diff;
}

int main(){
caller();
return 0;
}

（1）采用以下命令编译该程序并反汇编，结果输出到5-2.s。
$gcc -O1 5-2.c -o 5-2
$objdump -d 5-2>5-2.s
（2）为以下反汇编代码添加注释（用红色字体注释）：
08048393 <swap_add>:
8048393:	55        	push   	%ebp  		//保护ebp
8048394:	89 e5    	mov    %esp,%ebp		//设置新的ebp
8048396:	53       	push   	%ebx  		//保护ebx
8048397:	8b 5d 08  	mov    0x8(%ebp),%ebx  		//xp->ebx
804839a:	8b 4d 0c 	mov    0xc(%ebp),%ecx  		//yp->ecx
804839d:	8b 03   		mov    (%ebx),%eax  		//*xp->eax(x)
804839f:	8b 11		mov    (%ecx),%edx		//*yp->edx(y)
80483a1:	89 13   		mov    %edx,(%ebx)		//*xp=y
80483a3:	89 01   		mov    %eax,(%ecx)		//*yp=x
80483a5:8d 04 02		lea    	(%edx,%eax,1),%eax	//eax = x + y
80483a8:	5b     		pop    	%ebx	//恢复ebx
80483a9:	5d    		pop    	%ebp	//恢复ebp
80483aa:	c3  		ret				//函数返回
    
080483ab <caller>:
80483ab:	55		push   	%ebp		//保护ebp
80483ac:	89 e5  		mov    %esp,%ebp		//设置新的ebp
80483ae:	83 ec 18  	sub    	$0x18,%esp    //设置新的栈顶为esp<-0x18
80483b1:	c7 45 fc 7b 00 00 00  movl $0x7b,0x4(%ebp)	//arg1=123
80483b8:	c7 45 f8 c8 01 00 00  movl $0x1c8,-0x8(%ebp)	//arg2=456
80483bf:	8d 45 f8   	lea    	-0x8(%ebp),%eax		//eax=&arg2
80483c2:	89 44 24 04 	mov   	%eax,0x4(%esp)		//设置实参&arg2
80483c6:	8d 45 fc   	lea    	-0x4(%ebp),%eax		//eax=&arg1
80483c9:	89 04 24   	mov    %eax,(%esp)		//设置实参&arg1
80483cc: e8 c2 ff ff ff 	call 	8048393 <swap_add>		//调用swap_add函数
80483d1: 8b 55 fc 	mov    -0x4(%ebp),%edx		//edx=arg1
80483d4:	2b 55 f8  	sub    -0x8(%ebp),%edx		//edx=arg1-arg2
80483d7:	0f af c2  	imul   %edx,%eax		//sum*diff
80483da:	c9     		leave  			//恢复ebp、esp
80483db:	c3     		ret    			//返回
（3）编译得到汇编程序：
#gcc -S 5-2.c -o 5-2.s
由于C源程序默认的程序入口是main，而汇编程序默认入口是_start，用sed命令把test1.s的入口从main改到_start：
#sed -i -e “s#main#_start#g” 5-2.s
将test1.s汇编成可重定位文件test1.o：
#as -gstabs 5-2.s -o 5-2.o
链接生成可执行文件：
#ld 5-2.o -o 5-2
启动gdb调试：
#gdb 5-2
调试中可能用到如下命令：
p /x $寄存器名	//以十六进制形式查看寄存内容
p /x ($ebp+8)	//以十六进制输出％ebp的内容加上8
p * (int*) ($ebp+8)	//输出位于地址％ebp+8处的整数
break行号	//设置断点
run	//执行程序，遇到断点会停下来
x 内存地址	//检查从指定地址开始的4字节内存单元内容
x /x $ebp-4	//以十六进制输出%ebp-4地址的数据
info registers	//查看所有寄存器的信息
step	//单步执行，遇到函数进入
next	//单步执行，但是以函数调用为单位的
backtrace(bt)	//打印全部的过程调用栈帧信息，每帧显示一行
frame n	//选择显示栈帧n的简单信息
info frame	//显示指定的或者当前的栈帧的详细信息
caller调用swap_add前的栈帧信息：
swap_add函数执行执行到第9句movl 8(% ebp),%edx时(该句未被执行)的栈帧信息：
swap_add函数执行到第18句ret时（该句未被执行）的栈帧信息：
caller调用swap_add后的栈帧信息

3.3.3.观察栈帧-参数传递
阅读以下C程序代码：
#include <stdio.h>
swap1(int *x, int *y ){
	int t=*x;
	*x=*y;
	*y=t;
}
swap2 (int x, int y){
	int t=x;
	x=y;
	y=t;
}
main( ){ 
   int a=15, b=22;
   printf(“a=%d\tb=%d\n”, a, b);
   swap1(&a, &b);swap2(a, b);
   printf(“a=%d\tb=%d\n”, a, b);
}
（1） 编译程序，反汇编程序并截图；
（2）找到swap1、swap2函数机器语言级别上的不同；
（3）调试程序，填写下表：

3.3.4.观察栈帧-递归调用
调试以下C程序代码：
#include <stdio.h>
int  nn_sum ( int n) 
{
	int result;	
	if  (n<=0)
	    result=0;   
	else	
	    result=n+nn_sum(n-1); 
	return  result；
}
void main ( void){ 
   nn_sum ( 5); 
   nn_sum ( 131072);
   nn_sum ( 131073);
}
（1）用gdb跟踪语句1的执行，填写下表；
（2）画出n=3时的栈帧中变量位置示意图；
（3） 执行语句2、3，找到系统不报错的最大栈层次，计算此时的栈空间尺寸。
3.3.5.汇编语言与C语言的对应关系
int fun(unsigned x){
if (		)
return			;
unsigned z =			;
int result = fun(z); 
return			;
}

int main(){
	unsigned x = 0x1234;
	int r = fun(x);
	return 0;
}
func函数部分的汇编代码
fun:
pushl	%ebp
movl	%esp,%ebp
pushl	%ebx
subl		$4,%esp
movl	8(%ebp),%ebx
movl	$0,%eax
testl		%ebx,%ebx	#test指令的作用：两个操作数按位与，根据与的结果设置相应的标志位，但是相与的结果并不保留。
je 		.L4			#结果等于0，则跳转到L4
movl	%ebx,%eax
shrl 	%eax
movl	%eax,(%esp)
call  	fun
movl	%ebx,%edx
andl		$1,%edx
leal  	(%edx,%eax), %eax
.L4:
addl		$4,%esp
popl		%ebx
popl		%ebp
ret
（1）填写上述C代码中缺失的表达式（提示：func是一个递归程序）。
（2）用如下命令生成汇编代码test2.s进行验证：
#gcc -S -O1 test2.c -o test2.s
（3）用如下指令调试验证你对上述程序的理解：
#gcc -S -O1 test2.c -o test2.s
#sed -i -e “s#main#_start#g” test2.s
#as -gstabs test2.s -o test2.o
#ld  test2.o -o test2
#gdb test2

思考题：
(1).上述第5题进入main函数后第一行，esp、ebp值是多少？
(2).main函数有没有栈帧?
(3).栈帧中是什么内容？

3.4选择语句的机器级表示
C 语言主要通过选择结构（条件分支）和循环结 构语句来控制程序中语句的执行顺序，有 9 种流程控 制语句， 分成三类：选择语句、循环语句和辅助控制 语句，如图 3.21 所示。
3.4.1.if ~ else 语句的机器级表示
if ~ （then）、if ~ （ then ） - else 选择结构
根据判定 条件来控制一些语句是否被执行。其通用形式如下。

其中，cond_expi 是条件表达式，根据其值为非 0（真）或 0（假），分别选择 then_statement或else_statement 执行。通常，编译后得到的对应汇编代码可以有如下两种不同的结构，如 图 3. 11 所示。

图 3. 11  if-else 语句对应的汇编代码结构
图 3.11 中的“if()goto…”语句对应条件转移指令，“goto…”语句对应无条件转移指令。 编译器可以使用在底层 ISA 中提供的各种条件标志设置功能、条件转移指令、条件设置指令、 条件传送指令、无条件转移指令等相应的机器级程序支持机制(参见 3.3.4 节有关内容)来实 现这类选择语句。
以下是一个 c 语言函数：

已知形式参数 pl 和 p2 对应的实参已被压入调用函数的栈帧，pl 和 p2 对应实参的存储地 址分别为R[ebp]+8、R[ebp] +12,这里，EBP 指向当前栈帧底部。返回结果存放在 EAX 中。 请写出上述函数体对应的汇编代码，要求用 GCC 默认的 AT&T 格式书写。
因为 pl 和 p2 是指针类型参数，所以指令助记符中的长度后缀是 1,比较指令 cmpl 的 两个操作数应该都来自寄存器，故应先将 pl 和 p2 对应的实参从栈中取到通用寄存器中，比较 指令执行后得到各个条件标志位，程序需要根据条件标志的组合条件值选择执行不同的指令, 因此需要用到条件转移指令，转移目标地址用标号丄 1 和.12 等标识。
以下汇编代码能够正确完成上述函数的功能(不包括过程调用的准备阶段和结束阶段)。

上述汇编代码中，〃后面的文字给出的是对指令的功能说明，其中的 pl 和 p2 实际上是函 数的形式参数 pl 和 p2 对应的实参。本例中函数的形式参数 pl 和 p2 都是指针型变量，因此是 按地址调用的情况。序号为 3 的 cmpl 指令实际上是两个地址大小的比较，随后序号 4 对应的 指令应该使用无符号整数比较转移指令。参照表 3. 6 中的条件转移指令可知，其对应的条件转移指令是 jbe。
·3.4.2 条件运算表达式的机器级表示                                                     
 C 语言中唯一的三目运算符是由符号“？”和“：”组成的，它可以构成一个条件运算表 达式，这
个条件运算表达式的值可以赋值给一个变量。其通用形式如下：
x = cond_expr ? then_expr : else_expr；
对应的机器级代码可以编译成如图 3.22 所示的两种结构，只要将图 3. 22 中的 then_statement 改成“x = then_expr;”,将 else_statement 改成“x = else_expr；"即可。如果机器级代码用这两种 结构来实现的话，与 if-else 语句一样，要用到比较指令、条件转移指令以及无条件转移指令。
对于条件转移指令，它在条件满足时会跳转到其他地方执行，因而会破坏程序既定的执行 流程，这在用流水线方式执行程序的情况下，就会破坏流水线的执行，导致流水线停顿，从而 影响程序执行的性能。那么，用条件传送指令来代替条件转移指令是否更好呢？
在 3.3.4 节中介绍过条件传送指令 CMOVcc,该指令的功能是，在满足指定条件时，将源 数据送到目的地，否则什么也不做。也就是说，该指令执行完后，CPU 还是继续执行它后续的 指令，不会改变程序既定的执行流程，因而不会破坏指令流水线的执行，这样看来好像使用条 件传送指令比使用条件转移指令更好。
实际上，条件传送指令并不比条件转移指令更好，不建议使用条件传送指令来代替条件转 移指令。这是因为 CMOVcc 指令会使指令之间的依赖性加大，因此在乱序执行指令时使用 CMOVcc 指令反而会降低程序执行效率。此外，在基于条件传送指令实现的机器级代码中，由 于两个分支表达式的值都需要计算， 特别是当运算表达式比较复杂时，计算量会增加较多，因 而也不宜用条件传送指令。

·3.4.3 以下是两个 c 语言函数：

对于上述两个 c 语言函数，完成下列任务(汇编代码用 AT&T 格式)。写出函数 test 的
过程体对应的汇编代码。
基于条件传送指令写出行号为 9 的语句对应的汇编代码(假定，被分配在寄存器 EAX 中)。以下给出能正确完成 test 函数体功能的汇编代码(不包括过程调用的准备阶段和 结束阶段)。

这里有两条条件转移指令，分别用来判断条件表达式“(x>0&& *ptr>0)"分解出来的两 个结果为“假” 的条件“x < = 0"和"*ptr< = 0”,在这两个条件下，都不会执行“*ptr+=x” 的功能。
行号为 9 的语句“x = a>0 ?a ： a + 100；”对应的汇编代码如下，其中第 5 条为条件传 送指令。


3.5循环结构的机器级表示 
图 3.21 中总结了 C 语言中的所有程序控制语句，其中循环结构有三种：for 语句、while 语句和 do~ while 语句。大多数编译程序将这三种循环结构都转换为 do- while 形式来产生机 器级代码，下面按照与 do - while 结构相似程度由近到远的顺序来介绍三种循环语句的机器 级表示。
do  ~  while循环的机器级表示C 语言中的 do ~ while 语句形式如下。

该循环结构的执行过程可以用以下更接近于机器级语言的低级行为描述结构来描述。

上述结构对应的机器级代码中，loop_body_statement 用一个指令序列来完成，然后用一个 指令序列实现对 cond_expr 的计算，并将计算或比较的结果记录在标志寄存器中，然后用一条 条件转移指令来实现“if(c) goto loop；"的功能。

while循环的机器级表示C 语言中的 while 语句形式如下。

该循环结构的执行过程可以用以下更接近于机器级语言的低级行为描述结构来描述。

从上述结构可看出，与 do-while 循环结构相比，while 循环仅在开头多了一段计算条件 表达式的值并根据条件选择是否跳出循环体执行的指令序列，其余地方与 do - while 语句 一样。

for循环的机器级表示C 语言中的 for 语句形式如下。
for (beg1n_expr； cond_expr； update_expr) 1oop_body_statement
·for 循环结构的执行过程大多可以用以下更接近于机器级语言的低级行为描述结构来描述。

从上述结构可看出，与 while 循环结构相比，for 循环仅在两个地方多了一段指令序列。一 个是开头多了一段循环变量赋初值的指令序列，另一个是循环体中多了更新循环变量值的指令 序列，其余地方与 while 语句一样。
在 3. 4. 1 节中，我们以计算自然数之和的递归函数为例说明了递归过程调用的原理，这个 递归函数仅是为了说明原理而给出的，实际上可以直接用公式计算。同样，这里为了说明循环 结构的机器级表示，我们用 for 语句来实现这个功能。

从上述汇编代码可以看出,过程 nn_sum 中的非静态局部变量 i 和 result 被分别分配在寄存 器 EDX 和 EAX 中，ECX 中始终存放入口参数 n,返回参数在 EAX 中。这个过程体中没有用到 被调用过程保存寄存器。因而，可以推测在该过程的栈帧中仅保留了 EBP 的原值，即其栈帧 仅占用了 4 字节的空间，而 3.4. 1 节给出的递归方式则占用了 (16n + 12)字节的栈空间，多 用了 (16n+8)字节的栈空间。特别是每次过程调用都要执行 16 条指令，递归情况下一共多 了口次过程调用，因而，递归方式比非递归方式至少多执行了 16□条指令。由此可以看出，为 了提高程序的性能，可能的话最好用非递归方式。
·一个 c 语言函数被 GCC 编译后得到的过程体对应的汇编代码如下。
该 C 语言函数的整体框架结构如下。
int function_test(unsigned x)
{
int result -0 ；
1nt 1 ；
for ( 	; 	②	; 	®	) (
I
return result;
}
根据对应的汇编代码填写函数中缺失的①、②、③和④部分。
从对应汇编代码来看，因为 ECX 初始为 0,在比较指令 cmpl 之前 ECX 做了 一次加 1 操作后，再与
32 比较，最后根据比较结果选择是否转到.L12 继续执行，所以，可以很明显地 看出循环变量 i 被分配在ECX 中，①处为“i=0”，②处为“i!=32”，③处为“i++”。
第 5 条指令 leal 实现“2 * result",相当于将 result 左移一位；第 6 和第 7 条指令则实现 “x&OxOl”；
第 8 条指令实现“ result = (result «1) | (x&OxOl)”；第 9 条指令实现 “x»=l"。 综上所述，
④处的两条语句是“result = ( result << 1) | (x & 0x01 ) ； x >>= 1 ；"。
因为本例中循环终止条件是“i! = 32”，而循环变量 i 的初值为 0,可以确定第一次终止条 件肯定不满足，所以可以省掉循环体前面一次条件判断。从本例中给出的汇编代码来看，它确 实只有一个无符号整数条件转移指令，而不像最初给出的 for 循环对应的低级行为描述结构那 样有两处条件转移指令。显然，本例中给出的结构更简洁。
3.6  控制结构
C语言中的某些结构，比如条件语句、循环语句和分支语句，要求有条件的 执行，根据数据测试的结果来决定操作执行的顺序。机器代码提供两种基本的低 级机制来实现条件的行为：测试数据值，然后根据测试的结果来改变控制流或者 数据流。
3.6.1 控制结构用到的比较测试指令
3.6.2 控制结构用到的跳转指令
3.6.3 分支、循环结构对应的汇编翻译伪代码
if-else结构

          (a)简单if-else结构			              (b)对应的汇编实现翻译
图1. if-else结构
do-while循环

           (a)do-while循环语句			       	(b)对应的汇编实现翻译
图2. do-while结构
while循环

(a)while循环				  (b)对应的汇编实现翻译
图3. while结构
for循环

(a)for循环				  (b)对应的汇编实现翻译
图4. for结构

3.7实验：分支与循环的机器级表示
3.7.1. 三元操作机器级实现
（1）编译程序6-1.c；
 void test ( int x, int *ptr ) {  
     if  ( x>0 && *ptr>0 )  
    	*ptr+=x;
}	
				  
void caller (int a, int y ){
     int x = a>0 ? a : a+100;  
     test (x, &y)；
}
（2）找到三元操作对应的汇编指令，并解释。
3.7.2.汇编语言与C语言的对应关系-条件语句
阅读以下6-2.c代码。
void cond(int a, int *p){
if(p&&a>0)
	*p += a;
}

int main(){
int a=5,x=6;
cond(5,&x);
}
cond函数对应汇编代码部分：
cond:
	pushl	%ebp				#保护main的ebp
	movl	%esp,%ebp			#设置cond的ebp
	movl	8(%ebp),%edx		#edx = a
	movl	12(%ebp),%eax		#eax=p
	testl		%eax,%eax			#p&p
	je		.L3					#p=0则跳到L3
	testl		%edx,%edx			#a&a
	jle		.L3					#a<=0则跳到L3
	addl		%edx,(%eax)			#*p += a
.L3:
	popl		%ebp				#恢复ebp
	ret							#函数返回
（1）为汇编代码每行添加注释，说明每条语句的功能。
（2）汇编指令程序命令如下：（直接注释在上面的代码右边，在下方给出调试截图）
# gcc -S -fno-stack-protector -O1 -o 6-2.s 6-2.c
# sed -i -e "s#main#_start#g" 6-2.s 
# as -gstabs -o 6-2.o 6-2.s 
# ld -o 6-2 6-2.o 
# gdb 6-2
（3）在调试状态下逐条运行汇编指令，观察指令结果。

作业截图3 调试截图
（4）请说明为什么C语言代码中只有一个if语句，而汇编代码包含两个条件分支。（直接在下方输入）
因为C语言代码中的if是两个条件的逻辑与，所以在汇编代码中包含两个分支。

3.7.3.汇编语言与C语言的对应关系-条件语句
已知函数func的C语言代码如下：
int func(int x, int y){
int z=     ;
if (     ){
if (     ){
z=     ;
else
z=     ;
}else if (     ){
z=     ;
return z;
}
其对应的汇编代码如下所示：

（1）根据对应的汇编代码填写C代码中缺失的表达式：
（2）编译C代码后反汇编，对照汇编代码查看差异，截图并解释。
3.7.4.跳转表
已知C语言代码6-4.c如下：
#include<stdio.h>
#include<stdlib.h>
int sw(int a, int b, int c){
	int result;
	switch(a)
	{
		case 15:b=c+10;
		case 10:result=c+20;break;
		case 12:
		case 17:result=c+40;break;
		case 14:result=b;break;
		default:result=a;
	}
	return result;
}
int main(){
	int a=14, b=12, c=4;
	sw(a, b, c);
	return 0;
}
（1）标号怎么取值会执行default分支？
（2）编译6-4.c得到汇编程序，命令如下：
$gcc -g -S 6-4.c -o 6-4.s
（3）查看6-4.s的内容，定位到跳转表，注意跳转表所在的节(section)，划上横线：
	.file	"6-4.c"
	.text
	.globl	sw
	.type	sw, @function
sw:
.LFB2:
	.cfi_startproc
	pushl	%ebp
	.cfi_def_cfa_offset 8
	.cfi_offset 5, -8
	movl	%esp, %ebp
	.cfi_def_cfa_register 5
	subl		$16, %esp
	movl	8(%ebp), %eax
	subl		$10, %eax
	cmpl	$7, %eax
	ja		.L2
	movl	.L4(,%eax,4), %eax
	jmp		*%eax
	.section	.rodata
	.align 4
	.align 4
.L4:
	.long	.L3
	.long	.L2
	.long	.L5
	.long	.L2
	.long	.L6
	.long	.L7
	.long	.L2
	.long	.L5
	.text
.L7:
	movl	16(%ebp), %eax
	addl		$10, %eax
	movl	%eax, 12(%ebp)
.L3:
	movl	16(%ebp), %eax
	addl		$20, %eax
	movl	%eax, -4(%ebp)
	jmp		.L8
.L5:
	movl	16(%ebp), %eax
	addl		$40, %eax
	movl	%eax, -4(%ebp)
	jmp		.L8
.L6:
	movl	12(%ebp), %eax
	movl	%eax, -4(%ebp)
	jmp		.L8
.L2:
	movl	8(%ebp), %eax
	movl	%eax, -4(%ebp)
.L8:
	movl	-4(%ebp), %eax
	leave
	.cfi_restore 5
	.cfi_def_cfa 4, 4
	ret
	.cfi_endproc
.LFE2:
	.size	sw, .-sw
	.globl	main
	.type	main, @function
main:
.LFB3:
	.cfi_startproc
	pushl	%ebp
	.cfi_def_cfa_offset 8
	.cfi_offset 5, -8
	movl	%esp, %ebp
	.cfi_def_cfa_register 5
	subl		$16, %esp
	movl	$14, -12(%ebp)
	movl	$12, -8(%ebp)
	movl	$4, -4(%ebp)
	pushl	-4(%ebp)
	pushl	-8(%ebp)
	pushl	-12(%ebp)
	call		sw
	addl		$12, %esp
	movl	$0, %eax
	leave
	.cfi_restore 5
	.cfi_def_cfa 4, 4
	ret
	.cfi_endproc
.LFE3:
	.size	main, .-main
	.ident	"GCC: (Ubuntu 5.4.0-6ubuntu1~16.04.12) 5.4.0 20160609"
	.section	.note.GNU-stack,"",@progbits
作业截图5 汇编代码查看差异截图
（4）编译6-4.c得到可执行程序，命令如下：
$gcc -g 6-4.c -o 6-4
（5）对可执行程序进行反汇编，命令如下：
$objdump -d 6-4>6-4.s
得到函数sw的汇编代码如下：
080483db <sw>:
 80483db:	55                     push   	%ebp
 80483dc:	89 e5                	mov    %esp,%ebp
 80483de:	83 ec 10             	sub    	$0x10,%esp
 80483e1:	8b 45 08             	mov    0x8(%ebp),%eax
 80483e4:	83 e8 0a             	sub    	$0xa,%eax
 80483e7:	83 f8 07             	cmp    $0x7,%eax
 80483ea:	77 30                  ja     	804841c <sw+0x41>
 80483ec:	8b 04 85 e0 84 04 08 	    mov    0x80484e0(,%eax,4),%eax
 80483f3:	ff e0                	jmp    	*%eax
 80483f5:	8b 45 10             	mov    0x10(%ebp),%eax
 80483f8:	83 c0 0a             	add    	$0xa,%eax
 80483fb:	89 45 0c             	mov    %eax,0xc(%ebp)
 80483fe:	8b 45 10             	mov    0x10(%ebp),%eax
 8048401:	83 c0 14             	add    	$0x14,%eax
 8048404:	89 45 fc             	mov    %eax,-0x4(%ebp)
 8048407:	eb 19                	jmp    	8048422 <sw+0x47>
 8048409:	8b 45 10             	mov    0x10(%ebp),%eax
 804840c:	83 c0 28             	add    	$0x28,%eax
 804840f:	89 45 fc             	mov    %eax,-0x4(%ebp)
 8048412:	eb 0e                	jmp    	8048422 <sw+0x47>
 8048414:	8b 45 0c             	mov    0xc(%ebp),%eax
 8048417:	89 45 fc             	mov    %eax,-0x4(%ebp)
 804841a:	eb 06                	jmp    	8048422 <sw+0x47>
 804841c:	8b 45 08             	mov    0x8(%ebp),%eax
 804841f:	89 45 fc             	mov    %eax,-0x4(%ebp)
 8048422:	8b 45 fc             	mov    -0x4(%ebp),%eax
 8048425:	c9                   	leave  
 8048426:	c3                   	ret    
作业截图6 函数sw的汇编代码
注释以上各行。
（6）在反汇编程序中找到跳转表。
找不到。
（7）用gdb调试程序，查看0x80484e0附近的内容：

作业截图7 跳转表的内存映像
（8）绘制可执行程序中的跳转表：
0x80484e0：
0x80483fe
0x804841c
0x8048409
0x804841c
0x8048414
0x80483f5
0x804841c
0x8048409
（9）为什么4.2中汇编程序都是标号，4.5中可执行程序都是地址？
（10）哪些标号的取值会执行同一个case分支？
（11）查看可执行程序6-4中.rodata节的内容，并解释这些内容。
$objdump -s -j .rodata 6-4

作业截图8 可执行程序6-4中.rodata节的内容
3.7.5.汇编语言与C语言的对应关系-循环语句
以下包含6-5.c的C代码和编译器经过一级优化O1生成的对应的汇编代码中的dw_loop函数部分。
//6-5.c
int dw_loop(int x， int y， int n){
	do{
		x += n;
		y *= n;
		n--;
	}
	while((n>0)&&(y<n));
	return x;
}

int main(){
	dw_loop(5，4，3);
}
采用以下命令生成汇编代码：gcc 
# gcc -S -O1 -o 6-5.s 6-5.c
# sed -i -e "s#main#_start#g" 6-5.s 
# as -gstatbs -o 6-56.o 6-5.s 
# ld 6-5.s -o 6-5.o 
# gdb 6-5
dw_loop:
	pushl	%ebp				#保护main的ebp
	movl	%esp,%ebp			#设置dw_loop的ebp
	movl	8(%ebp),%eax		#eax=x
	movl	12(%ebp), %ecx		#ecx=y
	movl	16(%ebp),%edx		#edx=n
.L2:
	addl		%edx,%eax			#x=x+n
	imull	%edx,%ecx			#y=y*n
	subl		$1, %edx				#n--
	testl		%edx,%edx			#n&n
	jle		.L5					#n<=0则跳转到L5
	cmpl	%edx,%ecx			#y-n
	jl		.L2					#y<n则跳转到L2
.L5:
	popl		%ebp				#恢复ebp
	ret	
（1）阅读以上程序，填写如下寄存器使用表。
（2）指出以上C代码中的test-expr（测试条件表达式）和body-statement（循环体），以及在汇编代码中相应的行。
（3）为每条汇编指令添加注释，并通过调试进一步理解循环的机器级表示。（直接注释在上面的代码右边，在下方给出调试截图）

作业截图9 调试过程截图

思考题：
以下两段C语言代码，函数arith()是直接用C语言写的，而optarith()是对arith() 函数以某个确定的M和N编译生成的机器代码反编译生成的。根据optarith()，可以推断函数arith()中M和N的值各是多少？
#include <stdio.h>
#define M       
#define N       
int arith(int x， int y)
{
	int result = 0;
	result = x*M + y/N;
	return result;
}

int optarith(int x， int y)
{
	int t = x;
	x <<= 4;
	x -= t;
	if(y<0)
		y += 3;
	y >>= 2;
	return x+y;
}

4.复杂数据类型的分配和访问
本节以 c 语言为例说明复杂类型数据在机器级的处理，包括在寄存器和存储器中的存储与 访问。在机器级代码中，基本类型对应的数据通常通过单条指令就可以访问和处理，这些数据 在指令中或者是以立即数的方式出现，或者是以寄存器数据的形式出现，或者是以存储器数据 的形式岀现；而对于构造类型的数据，由于其包含多个基本类型数据，因而不能直接用单条指 令来访问和运算，通常需要特定的代码结构和寻址方式对其进行处理。本节主要介绍构造类型 和指针类型的数据在机器级程序中的访问和处理。

4.1数组的分配和访问 
数组可以将同类基本类型数据组合起来形成一个大的数据集合。数组是一个数据集合，因 而不可能放在一个寄存器中或作为立即数存放在指令中，它一定被分配在存储器中，数组中的 每个元素在存储器中连续存放，可以用一个索引值来访问数据元素。对于数组的访问和处理, 编译器最重要的是要找到一种简便的数组元素地址的计算方法。

4.1.1.数组元素在存储空间的存放和访问
在程序中使用数组，必须遵循定义在前，使用在后的原则。一维数组定义的一般形式 如下。
存储类型数据类型数组名[元素个数 1；
其中，存储类型可以缺省。例如，定义一个具有 4 个元素的静态存储型 short 数据类型 数组 A,可以写成“static short A[4]；”。这 4 个数组元素为 4[0]、4[1]、4[2]和 A[3], 它们连续存放在静态数据存储区中，每个数组元素都为 short 型数据，故占用 2 个字节， 数组 4 共占用 8 个字节，数组首地址就是第一个元素 4[0]的地址，因而通常用&矶 0] 表示，也可简单以彳表示数组 A 的首地址，第 i(0wiW3) 个元素的地址计算公式为 &4[0] +2 * io
假定数组 4 的首地址存放在 EDX 中，i 存放在 ECX 中，现需要将 4[订 取到 AX 中， 则可用以下汇编指令来实现。
movw (%edx , %ecx, 2), %ax
图4-1 给出了若干数组的定义以及它们在内存中的存放情况的说明。
图 4-1 数组定义及其内存存放情况示例

图4-1给出的 4 个数组定义中，数组釦和以中每个元素都是一个指针，SA 中每个元素 指向一个 char型数据，DA 中每个元素指向一个 double 型数据。

4.1.2.数组的存储分配和初始化
数组可以定义为静态存储型(static)、外部存储型(extern)、自动存储型(auto),或者定 义为全局静态区数组，其中，只有 auto 型数组被分配在栈中，其他存储型数组都分配在静态数 据区。
数组的初始化就是在定义数组时给数组元素赋初值。例如，以下声明可以对数组 M 的 4 个 元素进行初始化。
static short A[4] ={3,80 ,90 ,65 };
因为在编译、链接时就可以确定在静态区中的数组的地址，所以在编译、链接阶段就可将 数组首地址和数组变量建立关联。对于分配在静态区的已初始化的数组，机器级指令中可通过 数组首地址和数组元素的下标来访问相应的数组元素。例如，对于下面给出的例子：
int buf[2] = (10, 20}； int main()
(
1nt 1 , sum =0 ;
for (1 =0; i <2; 1 ++ )
sum -H= buf [ 1 ]; return sum；
}
该例中，如 f 是一个在静态区分配的可被其他程序模块使用的全局静态区数组，编译、链 接后 buf 在可执行目标文件的数据段中分配了相应的空间。假定分配给 buf 的地址为 0x8048908,则在该地址开始的 8 个字节空间中存放数据的情况如下：
1 08048908 < buf > :
2 08048908： 0A 00 00 00 14 00 00 00
编译器在处理语句"sum+=buf[i]；”时，假定 i 分配在 ECX 中，sm 分配在 EAX 中，则 该语句可转换为指令“addl buf( , %ecx, 4) , %eax”，其中 W 的值为 0x8048908。
对于 auto 型数组，因为被分配在栈中，因此数组首地址通过 ESP 或 EBP 来定位，机器级 代码中数组元素地址由首地址与数组元素的下标值进行计算得到。例如，对于下面给出的 例子：
int adder()
{
int buf[2] = {10, 20};
1 nt 1, sum = 0 ；
f or (i = 0 ; i <2; 1 ++ ) sum += buf [ 1 ]； return sum；

该例中，64 是一个在栈区分配的局部数组， 在栈中分配了相应的 8 字节空间。假定调用 adder 的函数为 P,并且在 adder 中没有使用被调用者保存寄存器 EBX、ESI、EDI,局部变量 2 和 sum 分别分配在寄存器 ECX 和 EAX 中，则函数 adder 对应的栈帧中的情况如图 3. 24 所示。
在处理 auto 型数组赋初值的语句"int buf[2]=110,20!；"时，编译器可以生成以下指令序列：

执行完上述指令序列后，数组弛 f 的首地址在 EDX 中，在处理语句"sum+=buf[i]；”时, 编译器可以将该语句转换为机器级指令“addl (%edx, %ecx, 4) , %eax”。






图4-2 adder的栈帧

4.1.3.数组与指针
C 语言中指针与数组之间的关系十分密切，它们均用于处理存储器中连续存放的一组数据，因而在访问存储器时两者的地址计算方法是统一的，数组元素的引用可以用指针来实现。












图 4-3 用指针和数组表示连续存放的一组数据

在指针变量的目标数据类型与数组的数据类型相同的前提条件下，指针变量可以指向数组或者数组中的任意元素。例如，对于存储器中连续的 10个 int 型数据，可以用数组 a 来说明，也可以用指针变量 ptr 来说明。以下两个程序段的功能完全相同，都是使指针 P"指向数组 a 的第 0 个元素 a[0]。同时数组变量 a 的值就是其首地址，即 a = &a[0], 因而 a = ptr,从而有&a [订=ptr + i = a + i 以及a[i] = ptr[i] = * (ptr + i) = * (a +i)。
〃代码段 1 int a[10];
int *ptr = &a[0]；
〃代码段 2
int a[10], *ptr;
ptr = &a[0];
假定 0x8048A00 处开始的存储区有 10 个 int 型数据，部分内容如图 3. 25 所示，以小端方式存放。图 3. 25 给出了用数组和指针表示的内存中连续存放的数据，以及指针和数组元素之间的关系。图中 a[0] =OxABCDEFOO、"1]= 0x1234567、a[9]=0xl256FF00。数组首地址 0x8048A00 存放在指针变量 ptr 中，从图中可以看 出，ptr + i 的值并不是用 0x8048A00 加 i 得到，而是等于 0x8048A00 +4*io表 3. 8 给出了一些数组元素或指针变量的表达式及其计算方式。假定 sizeof(int) =4,表中 数组 4为 int 型，其首地址 S4 在 ECX 中，数组的下标变量 i 在 EDX 中，表达式的结果在 EAX 中。

图4-4  关于数组元素和指针变的表达式计算示例
图4-4中序号为 2、3、6 和 7 的表达式都是引用数组元素，其中 3 和 6 是等价的。对应的 汇编指令都需要有访存操作，指令中源操作数的寻址方式分别是“基址”、“基址加比例变 址”、“基址加比例变址”和“基址加比例变址加位移”的方式，因为数组元素的类型为而 型，故比例因子为 4。
序号为 1、4 和 8 的表达式都是有关数组元素地址的计算，都可以用取有效地址指令 leal 来实现， 对于序号为 1 的表达式，也可以用指令“movl%ecx, %eax"实现。
序号为 5 的表达式则是计算两个数组元素之间相差的元素个数，也即两个指针之间的运 算，因此， 表达式的值的类型应该是 int，运算时应该是两个数组元素地址之差再除以 4。

4.1.4.指针数组和多维数组
由若干个指向同类目标的指针变量组成的数组称为指针数组。在 C 程序中使用指针数组必 须事先定义，其定义的一般形式如下。
存储类型数据类型*指针数组名[元素个数];
指针数组中每个元素都是指针，每个元素指向的目标数据类型都相同，就是上述定义中的 数据类型， 存储类型通常是缺省的。例如，“int *a[10];”定义了一个指针数组 a,它有 10 个 元素，每个元素都是一个指向 int 型数据的指针。
一个指针数组可以实现一个二维数组。以下用一个简单的例子来说明指针数组和二维数组 之间的关联，并说明如何在机器级程序中访问指针数组元素所指的目标数据和二维数组元素。
以下是一个 C 语言程序，用来计算一个两行四列整数矩阵中每一行数据的和。

#1nclude < stdlo.h >
mai n()
3 (
4	static short num[ ][4]={ {2,9, -1,5), {3,8,2, -6 H;

该例中，是一个在静态区分配的静态数组，因而在可执行目标文件的数据段中分配了 相应的空间。假定分配给 num 的地址为 0x8049300,则在该地址开始的一段存储区中存放数据 的情况如下。
1 08049300 < num > :
2 08049300 : 02 00 09 00 ff ff 05 00 03 00 08 00 02 00 fa ff
3 08049310 <pn > :
4 08049310： 00 93 04 08 08 93 04 08
因此，num - num [ 0 ] = &num [ 0 ] [ 0 ] = 0x8049300, pn = &pn [ 0 ] = 0x8049310, pn[0 ]= num[0] = 0x8049300,	1 ] = num [ 1 ] = 0x8049308o  编译器在处理第 10 行语句"s [ i ] +=*pn[i]++；"时，若 i 在 ECX, s[i]在 AX,则可通过指令“movl pn( ,%ecx,4) ,%edx” 先将 pnli]送到 EDX 中，再通过以下两条指令实现其功能。
addw(edx), %ax
addl $2 , pn(, %ecx, 4)
执行上述第一条加法指令 addw 时,pn[i]已在 EDX 中，因为是 short 型数据，所以数据宽 度为 16 位，即指令助记符长度后缀为 w；因为 pn 为指针数组，所以在引用烈的元素时其比例 因子为 4。例如， 当 i = l 时，pn[i] = *(pzi + i)=M[pzi+4*i] = 0x8049308 o
第二条加法指令 addl 用来实现“所[订+l「pn[i]”的功能，因为 p"[i]是指针，故“pn[门+1-所[订” 是指针运算，因此，操作数 k 度为 4B,助记符长度后缀为 1,实际应加指 针变量的目标数据长度，即 short 型数据的宽度，也就是指令中的立即数 2。

4.2实验：数组和指针的机器级表示
4.2.1.全局变量、静态变量和局部变量
阅读以下7-1.c程序：
#include <stdio.h>
int init_global_20[2]={10,20}; 
int init_global_0[2]={0,0} 
int uninit_global[2]; 
int main(){
  static int init_static_20[2]={10,20}; 
  static int init_static_0[2]={0,0}; 
  static int uninit_static; 
int init_local_20[2]={10,20};
int uninit_local;
printf(“address of init_global_20[0]:%x\n ”， &init_global_20[0]);
printf(“address of init_global_20[1]:% x \n ”， &init_global_20[1]);
printf(“address of init_global_0[0]:% x \n ”， &init_global_0[0]);
printf(“address of init_global_0[1]:%x\n”， &init_global_0[1]);
printf(“address of uninit_global[0]:%x\n”， &uninit_global[0]);
printf(“address of uninit_global[1]:%x\n”， &uninit_global[1]);
printf(“address of init_static_20[0]:%x\n”， &init_static_20[0]);
printf(“address of init_static_20[1]:%x\n”， &init_static_20[1]);
printf(“address of init_static_2[1]:%x\n”， &init_static_0[0]);
printf(“address of uninit_static:%x\n”， &uninit_static);
printf(“address of init_local[0]:%x\n”， &init_local[0]);
printf(“address of init_local[1]:%x\n”， &init_local[1]);
printf(“address of uninit_local:%x\n”， &uninit_local);
return 0;
}
运行并调试程序，查看变量地址，并解释为什么。

4.2.2.数组和指针
阅读以下7-2.c程序：
#include <stdio.h>
char a,b,c,d,e,f,g,h;
int main(){
  int z[5]={1,2,3,4,5}; 
int *ptr=z;
printf(“address of a:%x\n”,&a);
printf(“address of b:%x\n”,&b);
printf(“address of c:%x\n”,&c);
printf(“address of d:%x\n”,&d);
printf(“address of e:%x\n”,&e);
printf(“address of f:%x\n”,&f);
printf(“address of g:%x\n”,&g);
printf(“address of z[0]:%x\n”,&z[0]);
printf(“address of z[1]:%x\n”,&z[1]);
printf(“address of z[2]:%x\n”,&z[2]);
printf(“address of z[3]:%x\n”,&z[3]);
printf(“address of z[4]:%x\n”,&z[4]);
printf(“address of z[4]:%x\n”,&(p+1));
printf(“address of z[4]:%x\n”,&(p+2));
printf(“address of z[4]:%x\n”,&(p+3));
printf(“address of z[4]:%x\n”,&(p+4));
return 0;
}
（1）在gdb里调试程序，查看变量ptr和z的内容及地址。
答：在C语言中所谓的“指针”其实就是地址。间接引用指针就是将该指针放在一个寄存器中，然后在存储器引用中使用这个寄存器。

（2）运行并调试程序，查看变量地址，并解释为什么。

4.2.3.存储方式-指针
阅读以下代码（假设该代码在7-3.c中）：
int exchange(int *xp, int y){
	int x=*xp;
	*xp=y;
	return x;
}
（1） 用gcc –S 7-3.c –o 7-3.s命令编译的汇编代码如下所示，为每行代码添加注释，说明每条语句功能。
（2）用一级优化汇编命令gcc –S –O1 7-3.c –o 7-3.s重新编译7-3.c，并解释7-3.s中每句汇编代码的功能。（将代码写入表格并解释功能）

答：在C语言中所谓的“指针”其实就是地址。间接引用指针就是将该指针放在一个寄存器中，然后在存储器引用中使用这个寄存器。其次，像x这样的局部变量通常是保存在寄存器中，而不是存储器中。寄存器的访问比存储器访问要快得多。当过程体开始执行时，过程参数xp和y存储在相对于寄存器％ebp中地址值偏移8和12的地方。

4.2.4.存储方式-二维数组
阅读7-4.c程序：
#include <stdio.h>
int main(){
static short num[][4]={{1,2,3,4},{-1,-2,-3,-4}};
static short *pn[]={num[0],num[1]};
static short s[2]={0,0};
for (int i=0;i<2;i++){
    for (int j=0;j<4;j++)
         s[i]+=*pn[i]++;
    printf(“sum of line %d: %d. \n”, i, s[i]);
}
return 0;
}

（1）用gdb观察num存储的数据；
（2）用gdb观察pn存储的数据；
（3）反汇编程序，观察s[i]+=*pn[i]++对应的语句，解释其中3个操作的次序，尤其是++操作的对象和每次加法的数值。
4.2.5.存储方式-观察栈帧
阅读7-5.c代码：
int buffer[2]={10,20};

int addbuf(){
	int buf[2]={10，20};
	int i,sum=0;
	for(i=0;i<2;i++){
		sum += buf[i];
	}
	return sum;
}

int addbuffer(){
	int i,sum=0;
	for(i=0;i<2;i++){
		sum += buffer[i];
	}
	return sum;
}

int main(){
	int sum1 = addbuf();
	int sum2 = addbuffer();
	return 0;
}
（1）采用以下命令编译调试程序。
# gcc -S 7-5.c -o 7-5.s
# sed -i -e “s#main#_start#g” 7-5.s
# as –gstabs 7-5.s –o 7-5.o
# ld test2.o –o 7-5
# gdb 7-5
（2）画出调用过程中addbuf函数执行到leave指令前main和addbuf的栈帧。
（3）画出调用过程中addbuffer函数执行到leave指令前main和adderbuffer的栈帧。
（4）采用以下命令查看对应的可执行程序中的代码段和数据段，理解静态存储数组buffer的存储，反汇编代码与汇编代码的区别。（给出两个命令运行后的截图）
# objdump –d –j .text test2

作业截图2 addbuf函数汇编程序截图

作业截图2 addbuffer函数汇编程序截图
# objdump –d –j .data test2

作业截图3 数据节截图

思考题：
考虑以下代码，其中M和N是用#define声明的常数：
int mat1[M][N];
int mat2[N][M];

int sum_element(int i， int j){
	return mat1[i][j]+mat2[j][i];
}
编译以上函数，GCC产生如下汇编代码：
sum_element:
	pushl	%ebp				//调用者ebp入栈保护
	movl	%esp,%ebp			//设置sum_element的ebp
	movl	8(%ebp),%eax		//eax=i
	movl	12(%ebp),%edx		//edx=j
	leal		0(,%eax,8),%ecx		//ecx=8*i
	subl		%eax,%ecx			//ecx=8*i-i=7*i
	addl	%edx,%ecx			//ecx=7*i+j
	leal		(%edx,%edx,4),%edx	//edx=5*j
	leal		(%edx,%eax),%eax	//eax=5*j+i
	movl	mat1(,%ecx,4),%edx	//edx=mat1[i][j]=(mat1+4*(7*i+j))
	addl		mat2(,%eax,4),%edx	//edx += mat2[j][i]=(mat2+4*(5*j+i))
	movl	%edx,%eax			//结果放入eax返回
	popl		%ebp				//恢复ebp
	ret							//函数返回
确定M和N的值。
M=5，N=7


4.3结构体数据的分配和访问 
c 语言的结构体(也称结构)可以将不同类型的数据结合在一个数据结构中。组成结构体 的每个数据称为结构体的成员或字段。

4.3.1.结构体成员在存储空间的存放和访问
结构体中的数据成员存放在存储器中一段连续的存储区中，指向结构的指针就是其第一个 字节的地址。编译器在处理结构型数据时，根据每个成员的数据类型获得相应的字节偏移量， 然后通过每个成员的字节偏移量来访问结构成员。
例如，以下是一个关于个人联系信息的结构体：
struct cont_1nfo ( char 1d[8]; char name[ 12]; unsigned post；
char address[100]; char phone[20]；
}
该结构体定义了关于个人联系信息的一个数据类型 struct contjnfo,可以把一个变量*定 义成这个类型，并赋初值，例如，在定义了上述数据类型 struct cont_info 后，可以对变量 x 进 行如下声明。
struct cont_1nfo x=("0000000" , "ZhangS", 210022,
"273 long street, High Building #3015", "12345678");
与数组一样，分配在栈中的 aut。型结构类型变量的首地址由 EBP 或 ESP 来定位，分配在 静态存储区的静态和外部型结构体变量首地址是一个确定的静态存储区地址。
结构体变量 x 的每个成员的首地址等于 x 加上一个偏移量。假定上述变量 x 分配在地址 0x8049200
开始的区域，那么，x = &(x.id) =0x8049200,其他成员的地址计算如下。
&(x.name) =0x8049200 +8 =0x8049208
& (x.post) =0x8049200+8 + 12 =0x8049214 &(/.address) =0x8049200+8 + 12 +4 =0x8049218
& (x.phone) = 0x8049200 + 8+12 + 4+100 = 0x804927C
可以看出 x 初始化后，对于 name 字段，在地址 0x8049208 ~0x804920D 处存放的是字符串“ZhangS”， 0x804920E 处存放的是字符'\0',在地址 0x804920F - 0x8049213 处存放的都是空 格字符。
访问结构体变量的成员时，对应的机器级代码可以通过“基址加偏移量”的寻址方式来 实现。例如， 假定编译器在执行语句 uunsigned xpost = x.post；"时，*被分配在 EDX 中，xpost 被分配在 EAX 中，则对应的汇编指令为“movl20(%edx), %eax”。这里的基址就是 0x8049200, 它被存放在 EDX 中，偏移量为 8+ 12 =20。

4.3.2.结构体数据作为入口参数
当结构体变量需要作为一个函数的形式参数时，形式参数和调用函数中的实参应该具有相 同的结构。和普通变量传递参数的方式一样，它也有按值传递和按地址传递两种方式。如果采 用按值传递方式，则结构的每个成员都要被复制到栈中参数区，这既增加时间开销，又增加空 间开销，因而对于结构体变量通常釆用按地址传递的方式。也就是说，对于结构类型参数，通 常不会直接作为参数，而是把指向结构的指针作为参数。这样，在执行 call 指令之前，就无需 把结构成员复制到栈中的参数区，而只要把相应的结构体首地址送到参数区，也就是说，仅传 递指向结构体的指针而不复制每个成员。
例如，以下是处理学生电话信息的两个函数：
1 void stu_phonel(struct cont_info *stu_1 nfo_ptr)
2	{
3	printf("%s phone number： %s", ( *stu_1 nf o_ptr) .name, (*stu_i nf o_ptr ). phone );
4	}
5
5	void stu_phone2(struct cont_1nfo stu_info)
6	{
7	printf("%s phone number： %sM, stu_info. name, stu_1 nf o. phone )；
8 }
函数 stu_phonel 按地址传递参数，而 stu_phone2 按值传递参数。对于上述结构体变量 x, 若需调用函数 stu_phonel,则调用函数使用的语句应该为 Mstu_phonel ( &x) ；M；若需调用函数 stu_phone2,则调用函数使用的语句应该为“stu_phone2(x)； ”。这两种情况下对应的栈中状态 如图 4-5 所示。

图 4-5 按地址传递和按值传递结构体数据
如图 4-5a 所示，对于按地址传递结构体数据方式，调用函数将会把，的地址 0x8049200 作为实参存到参数区，此时，M[R[ebp] +8] =0x8049200。在函数 stu_phonel 中，使用表达式 (*stu_info).name 来引用结构体成员 name, 也可以将(*stu_info).name 写成  stu_infb - > name0  实现将表达式(*stu_info).name 的结果送 EAX 的指令序列如下：
movl	8(%ebp), edx leal	8(%edx), eax
执行完上述两条指令，EAX 中存放的是字符串"ZhangS”在静态存储区内的首地址 0x8049208。
如图 4-5b 所示，如果是按值传递结构体数据，调用函数将会把％的所有成员值作为实参存 到参数区，此时，形参 stujnfo 的地址为 R[ebp]+8o 在函数 stu_phone2 中，使用表达式 stujnfo. name 来引用结构体成员 name。实现将表达式 stu_info.name 的结果送 EAX 的指令序列如下：
leal	8(%ebp), edx leal	8(%edx), eax
上述两条指令的功能实际上是将 R[ebp] +16 的值送到 EAX 中，EAX 中存放的是字符串 “ZhangS”在栈中参数区内的首地址。
从上述图 4-5 可以看岀，虽然调用 stu_phonel 和 stu_phone2 可以实现完全相同的功能， 但是两种方式下的时间和空间开销都不一样。显然，后者的开销大，因为它需要对结构体成员 整体从静态存储区复制到栈中。

4.4联合体数据的分配和访问 
与结构体类似的还有一种联合体(也称联合)数据类型，它也是不同数据类型的集合, 不过它与结构体数据相比，在存储空间的使用方式上不同。结构体的每个成员占用各自的存储 空间，而联合体的各个成员共享存储空间，也就是说，在某一时刻，联合体的存储空间中仅存 有一个成员数据。因此，联合体也称为共用体。
因为联合体的每个成员所占的存储空间大小可能不同，因而分配给它的存储空间总是按最 大数据长度成员所需空间大小为目标。例如，对于以下联合体数据结构：
uni on uarea (
char c_data； short s_data ；
1   nt i_data；
1 ong l_data:
}；
在 IA-32 ±编译时，因为 long 的长度和 int 的长度一样，都是 32 位，所以数据类型 uarea 所占存储空间大小为 4 字节。而对于与 uarea 有相同成员的结构体数据类型来说，其占用的存 储空间大小至少有 1+2+4+4 = 11 字节，如果考虑数据对齐的话，则占用的空间更多。
联合体数据结构通常用在一些特殊的场合，例如，当事先知道某种数据结构中的不同字段 (成员)的使用时间是互斥的，就可以将这些字段声明为联合，以减少分配的存储空间。但有 时这种做法可能会得不偿失，它可能只会减少少量的存储空间却大大增加处理复杂性。
利用联合体数据结构，还可以实现对相同位序列进行不同数据类型的解释。例如，以下函 数可以对一个 float 型数据重新解释为一个无符号整数。
1 unsigned float2unsign(float f)
2 (
union {
float f ；
unsigned u;
} tmp_union；
tmp_union .f = f;
return tmp_union.u;
9	}
上述函数的形式参数是 float 型，按值传递参数，因而从调用过程传递过来的实参是一个 float 型数据，该数据被赋值给了一个非静态局部变量中的成员 f,由于成员 u 和成员 f 共享同一个存储空间，所以在执行序号为 8 的 return 语句后，32 位的浮点数被转换成了 32 位 无符号整数。函数 Aoat2unsign 的过程体中主要的指令就是“movl 8(%ebp) , %eax”，它实现了 将存放在地址 R[ebp] +8 处的入口参从上述例子可以看出，机器级代码在很多时候并不区分所处理对象的数据类型，不管高级 语言中将其说明成 float 型还是 int 型或 unsigned 型，都把它当成一个 0/1 序列来处理。明白这 一点非常重要！
联合体数据结构可以嵌套，以下是一个关于联合体数据结构 node 的定义：
union node {
struct {
1 nt *ptr ；
int datal
} nodel struct {
int data2; uni on node *next ；
} node2;
)
可以看出数据结构 node 是一个如图 3. 27 所示的链表，在这个链表中除了最后一个节点采 用 nodel结构类型外，前面节点的数据类型都是 node2 结构，其中有一个字段 next 又指向了一 个 node 结构。
图 4-6  node 数据结构示意图
有一个处理 node 数据结构的过程 node_proc 如下：
1 void node_proc(un1 on node *np)
2 (
3	np -> next -> datal =*(np -> next -> ptr) + np -> data2
过程 node_proc 中的形式参数是一个指向 node 联合数据结构的指针，显然，它釆用按地 址传递参数方式，因此，在调用程序栈帧的参 数区存放的实参是一个地址，这个地址是一个 node 型数据（即链表）的首地址°假定处理的 链表被分配在某个存储区（通常像链表这种动 态生成的数据结构都被分配在动态的堆区），其 首地址为 0xf0493000。根据过程 node_proc 中第 3 行语句可知，所处理的链表共有两个节点， 其中第一个节点是 node2 型结构，第二个节点 是 nodel 型结构，图 3.28 给出了其存放情况 示意。
过程 node_proc 的过程体对应的汇编代码 如下。
movl 8(%ebp), %ecx	〃将实参(链表首址 0 xf0493000)送 ECX
movl 4(%ecx), %edx 〃将地址 0xf0493004 中的 next 送 EDX
显然，执行完上述机器级指令后，ECX 中存放的内容是链表首地址 0xf0493000, EDX 中存 放的是指针 next0

4.5复杂数据类型的数据对齐 
可以把存储器看作由连续的位(cell)构成，每 8 位为一个字节，每个字节有一个地址编 号，称为按字节编址。假定计算机系统中访存机制限制每次访存最多只能读写 64 位，即 8 个 字节，那么，第 0~7 字节可以同时读写，第 8~15 字节可以同时读写，以此类推，这种称为 8 字节宽的存储机制。因此，如果一条指令要访问的数据不在地址为 8i~8i+7(i=0,l,2,…) 之间的存储单元内，那么就需要多次访存，因而延长了指令的执行时间。例如，若访问的数据 在第 6、7、8、9 这四个字节中，则需要访问存储器两次。因此，数据在存储器中存放时需要 进行对齐，以避免多次访存而带来指令执行效率的降低。
当然，对于底层机器级代码来说，它应该能够支持按任意地址访问存储器数据的功能，因 此，无论数据是否对齐，IA-32 都能正确工作，只是在对齐方式下程序的执行效率更高。为此， 操作系统通常按照对齐方式分配管理内存，编译器也按照对齐方式转换代码。
最简单的对齐策略是，要求不同的基本类型按照其数据长度进行对齐，例如，int 型数据 长度是 4 个字节，因此规定 int 型数据的地址是 4 的倍数。同理，short 型数据的地址是 2 的倍 数，double 和 long long 型数据的地址是 8 的倍数，float 型数据的地址是 4 的倍数，char 型数据 则无需对齐。微软 Windows 采用的就是这种对齐策略。这种情况下，对于 8 字节宽的存储机制 来说，所有基本类型数据都仅需访存一次。Linux 的对齐策略更为宽松一点，它规定：short 数 据的地址是 2 的倍数，其他的如 int、float、
double 和指针等类型数据的地址都是 4 的倍数。这 种情况下，对于 8 字节宽的存储机制来说，double 型数据就可能需要访问两次。对于扩展精度 浮点数，IA-32 中规定长度是 80 位，即 10 个字节，由于操作系统规定至少是 4 字节对齐，所 以，GCC 对于 long double 型数据分配了 12 个字节，以使随后的相同类型数据能够落在 4 字节 地址边界上。
对于由基本数据类型构造而成的 stmct 结构体数据，编译器为了保证其中每个字段都满足 对齐要求， 它首先使结构体数据的首地址按 4 字节对齐，同时，根据基本数据类型对齐要求， 在各字段中插入相应的空间，以使每个字段的成员变量满足对齐要求。
例如，考虑下面的结构定义：
struct SD (
1 nt 1 ; short si; char c ； double d ；
}
如果不按照对齐方式分配空间，那么，SD 所占的存储空间大小为 4+2+ 1+8 =15 字节, 每个字段的首地址偏移如图 3. 29a 所示，字段 i、si、c 和 d 的偏移地址分别是 0、4、6 和 7,因 此，即使 SD 的首地址按 4 字节边界对齐，字段 d 也不满足 4 字节或 8 字节对齐要求。为此, 需要在字段 c 后面插入一个空字节，以使字段 d 的偏移从 8 开始，此时，每个字段的首地址偏 移如图 3. 29b 所示。这种情况下，只要 SD 首地址按 4 字节边界对齐，那么所有字段都能按要 求对齐。而且，因为 SD 所占空间大小为 16 字节，因此， 当定义一个数据元素为 SD 类型的结 构数组时，每个数组元素也都能在 4 字节边界上对齐。

图4-7  结构 SD 的存储分配情况
为了使结构数组中的每个元素都能满足对齐要求，编译器有时需要在结构的最后字段后面 插入空间， 例如，对于下面的结构数组定义：
struct SDT {
int j ; short s1 ；
double d； char c;
} sa[10]；
如果按照图 3. 30a 的方式在字段中插空，那么对于第一个元素 sa[0]来说，则能够保证每 个字段的对齐要求，但是，因为 SDT 所占总长度为 17 字节，所以，对于 sa[l]来说，其首地 址就不是按 4 字节方式对齐，因而导致 sa[l]中各字段不能满足对齐要求。此时，编译器将在 SDT 结构的最后字段后面插入 3 个字节的空间，如图 3.30b 所示。此时，SDT 总长度为 20 字 节，保证了结构数组中所有元素的首地址都是 4 的倍数。
图 4-8 结构 SDT 的存储分配情况

4.6实验：结构体、联合体和数据存储
4.6.1.数据存储－简单变量的存储位置
编写简单变量的程序8-1.c，查看变量的存储位置：
#include "stdio.h" 
void main( ) { 
char a=100 ; 
short b=100 ; 
int c=100 ; 
int d =100; 
long e =100; 
float f =100; 
double g =100; 
int *h =&a; 
int *i =&b; 
int *j =&c; 
int *k =&f; 
printf("a=%0xH, b=%0xH, c=%0xH, d=%0xH, e=%0xH, f=%f, g=%f \n",a,b,c,d,e,f,g); 
printf("h=%0xH, i=%0xH, j=%0xH, k=%0xH,\n", h,i,j,k); 
printf("h=%0xH, i=%0xH, j=%0xH, k=%0xH,\n", *h, *i, *j, *k); 
} 
（1） a、b、c、d、e、f、g的真值都是100，但都属于不同的数据类型，它们在存储器中是否占用相同的存储空间呢？查看其存储空间。
（2）一个变量有多个字节时，多个字节在存储器中是按什么顺序排列存放的？截图并解释。
（3）变量a、b、c是否可以存放在存储器中任意开始的地址？查看并解释。
4.6.2.数据存储－结构体变量的存储
编写以下结构体的程序8-2.c，查看结构中成员的存储结构：
#include "stdio.h" 
void main( ) { 
struct record{ 
char a ; 
int b ; 
short c ; 
char d ; 
} R[2] ; 
R[0].a=1; R[0].b=2; R[0].c=3; R[0].d=4; 
R[1].a=5; R[1].b=6; R[1].c=7; R[1].d=8; 
printf("数据存储时的边界对齐"); 
} 
（1）查看结构record中成员变量a、b、c和d的边界对齐方式，并画出示意图。 
（2）查看数组元素R[0]和R[1]的边界对齐方式，并画出示意图。 
（3）计算数组R占用的字节数。record的定义是否可以优化？给出优化后的record定义，并计算record优化定义后数组R占用的字节数。画出示意图。
4.6.3.复杂数据类型-结构体
阅读8-3.c代码：
struct cont_info {
char id[8];
char name [12];
unsigned post;
char address[100];
char phone[20];
 };
struct cont_info x={“0000000”, “ZhangS”, 210022, “273 long street, High Building #3015”, “12345678”};
struct cont_info y={“0000001”, “WangG”, 210021, “272 long street, High Building #3016”, “12345679”};
int exchange(struct cont_info *xp, struct cont_info y){
printf(“address of variables in the exchange function: \n”);
printf(“address of y: %x\n”, &y);
printf(“address of y.id: %x\n”, &y.id);
printf(“address of y.name:%x\n ”, &y.name);
printf(“address of y.post:%x\n”, &y.post);
printf(“address of y.address:%x\n”, &y.address);
printf(“address of y.phone:%x\n”, &y.phone);

struct cont_info x=*xp;
*xp=y; 
return x;
}
int main(){
printf(“address of variables in the main function: \n”);
printf(“address of x: %x\n”, &x);
printf(“address of x.id: %x\n”, &x.id);
printf(“address of x.name:%x\n ”, &x.name);
printf(“address of x.post:%x\n”, &x.post);
printf(“address of x.address:%x\n”, &x.address);
printf(“address of x.phone:%x\n”, &x.phone);
printf(“address of y: %x\n”, &y);
printf(“address of y.id: %x\n”, &y.id);
printf(“address of y.name:%x\n ”, &y.name);
printf(“address of y.post:%x\n”, &y.post);
printf(“address of y.address:%x\n”, &y.address);
printf(“address of y.phone:%x\n”, &y.phone);
exchange(&x,y);
return 0;
}
（1）编译并运行程序8-3.c，解释每行输出。
（2）画图解释函数exchange和main中的不同。
4.6.4.数据存储－联合体变量的存储
（1）编写程序，采用联合体检查你的机器是大端方式还是小端方式。
#include "stdio.h" 
void main( ) { 
union NUM{ 
int a ; 
char b; 
} num ; 
num.a=0x12345678; 
if (num.b==0x12); 
printf("Big Endian\n");
else
printf("Little Endian\n"); 
printf("num.b=0x%x\n", num.b); 
} 

（2）查看联合体中成员变量的边界对齐方式，并画出示意图。
（3）生成联合体数组，查看数组元素的边界对齐方式，并画出示意图。 
#include "stdio.h" 
union{
unsigned long long uni;
unsigned char pos[8];
}gene[3];
void main(){
gene[1].uni=0x0706050403020100;
printf("0x%I64xui64\n",gene[1].uni);
printf("%02x %02x %02x %02x %02x %02x %02x %02x\n",
gene[1].pos[0],
gene[1].pos[1],
gene[1].pos[2],
gene[1].pos[3],
gene[1].pos[4],
gene[1].pos[5],
gene[1].pos[6],
gene[1].pos[7]);
}
作业截图8 联合存体储示意图


作业截图9 运行结果截图

4.6.5.数据存储－大端和小端、机器值
编译运行下面给出的程序8-5.c，观察并解释程序的执行结果。
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
typedef unsigned char *byte_pointer;
void show_bytes(byte_pointer start, int len) {
	int i;
	for (i = 0; i < len; i++) 
		printf("%2x\n", start[i]); 
	printf("\n");
}
void show_int(int x) {
	show_bytes((byte_pointer) &x,sizeof(int));
}
void show_float(float x) {
	show_bytes((byte_pointer) &x,sizeof(float));
}
void show_pointer(void *x) {
	show_bytes((byte_pointer) &x, sizeof(void *));
}
void test_show_bytes(int val) { 
	int ival = val; 
	float fval = (float) ival; 
	int *pval = &ival; 
	show_int(ival); 
	show_float(fval); 
	show_pointer(pval);
}
void simple_show_a() {
	int val = 0x87654321;
	byte_pointer valp = (byte_pointer) &val;
	show_bytes(valp,1);
	show_bytes(valp,2);
	show_bytes(valp,3);
}
void simple_show_b() {
	int val = 0x12345678;
	byte_pointer valp = (byte_pointer) &val;
	show_bytes(valp, 1);
	show_bytes(valp,2);
	show_bytes(valp,3);
}
void float_eg() { 
	int x = 3490593; 
	float f = (float) x; 
	printf("For x = %d\n",x); 
	show_int(x); 
	show_float(f);
	
	x = 3510593; 
	f = (float) x;
	printf("For x = %d\n", x);
	show_int(x);
	show_float(f);
}
void string_ueg() {
	const char *s ="ABCDEF";
	show_bytes((byte_pointer) s,strlen(s));
}
void string_leg() {
	const char *s ="abcdef";
	show_bytes((byte_pointer) s,strlen(s));
}
void show_twocomp(){
	short x = 12345; 
	short mx = -x;
	show_bytes((byte_pointer) &x,sizeof(short)); 
	show_bytes((byte_pointer) &mx, sizeof(short));
}
int main(int argc, char *argv[]){
	int val = 12345;
	if (argc>1) { 
		if (argc>1) {
			val = strtol(argv[1],NULL,0);
		}
		printf("calling test_show_bytes\n"); 
		test_show_bytes(val);
	} else {	
		printf("calling show_twocomp\n"); 
		show_twocomp(); 
		printf("Calling simple_show_a\n");
		simple_show_a();
		printf("Calling simple show_b\n"); 
		simple_show_b(); 
		printf("Calling float_eg\n"); 
		float_eg();
		printf("Calling string_ueg\n");
		string_ueg();
		printf("Calling string_leg\n");
		string_leg();
	}
	return 0;
}						
（1）手工计算int型数据3490593和3510593的机器码，以及对应的float型数据 3490593和3510593的机器码，写出完整的计算转换过程，并与8-5.c中的实验结果对照。
（2）手工计算int型数据12345和-12345对应的机器码，写出完整的计算转换过程，并与8-5.c实验中的结果对照。
思考题：
数据对齐规范要求：


APPENIDIX	H
HEXDUMP工具
hexdump主要用来查看“二进制”文件的十六进制编码。
*注意：它能够查看任何文件，不限于与二进制文件。*
选项：
-n length：格式化输出文件的前length个字节
-C：输出规范的十六进制和ASCII码
-b：单字节八进制显示
-c：单字节字符显示
-d：双字节十进制显示
-o：双字节八进制显示
-x：双字节十六进制显示
-s：从偏移量开始输出
-e 指定格式字符串，格式字符串由单引号包含，格式字符串形如：’a/b “format1” “format2”。每个格式字符串由三部分组成，每个由空格分割，如a/b表示，b表示对每b个输入字节应用format1格式，a表示对每个a输入字节应用format2，一般a>b，且b只能为1,2,4，另外a可以省略，省略a=1。format1和format2中可以使用类似printf的格斯字符串。
%02d：两位十进制
%03x：三位十六进制
%02o：两位八进制
%c：单个字符等
%_ad：标记下一个输出字节的序号，用十进制表示
%_ax：标记下一个输出字节的序号，用十六进制表示
%_ao：标记下一个输出字节的序号，用八进制表示
%_p：对不能以常规字符显示的用.代替同一行显示多个格式字符串，可以跟多个-e选项

5.越界访问和缓冲区溢出
在 3.4.1 节中我们介绍了有关 C 语言过程调用的机器级代码表示，在 C 语言程序执行过程 中，当前正在执行的过程（即函数）在栈中会形成本过程的栈帧，一个过程的栈帧中除了保 存 EBP 和被调用者保存寄存器的值外，还会保存本过程的非静态局部变量和过程调用的返回 地址。
在 3. 5.1 节中我们介绍了 C 语言中数组的分配和访问，C 语言中的数组元素可以使用指针 来访问， 因而对数组的引用没有边界约束，也即程序中对数组的访问可能会有意或无意地超越数组存储区范围而无法发现。可以把这种数组存储区看成是一个缓冲区，这种超越数组存储区 范围的访问称为缓冲区溢出。例如，对于一个有 10 个元素的 char 型数组，其定义的缓冲区有 10 个字节。如果写一个字符串到这个缓冲区，那么只要写入的字符串多于 9 个字符(结束符 '\0'占一个字节)，则这个缓冲区就会发生“写溢出”。

5.1缓冲区溢出攻击
缓冲区溢出是一种非常普遍、非常危险的漏洞，在各种操作系统、应用软件中广泛存在。 缓冲区溢出攻击是利用缓冲区溢出漏洞所进行的攻击行动。缓冲区溢出攻击可以导致程序运行 失败、系统关机、重新启动等后果。如果有人恶意利用在栈中分配的缓冲区的写溢出，悄悄地 将一个恶意代码段的首地址作为“返回地址”覆盖地写到原先正确的返回地址处，那么，程 序就会在执行 ret 指令时悄悄地转到这个恶意代码段执行，从而可以轻易取得系统特权，进而 进行各种非法操作。
造成缓冲区溢岀的原因是程序没有对栈中作为缓冲区的数组进行越界检査。下面用一个简 单的例子说明攻击者如何利用缓冲区溢出跳转到自己设定的程序 hacker 去执行。
以下是在文件 testx 中的三个函数，假定编译、链接后的可执行代码为 test。
"include < stdio.h >
#1nclude "string.h" 3
void outputs(char *str)
4 (
char buffer[ 16 J ;
strcpyCbuffer, str)；
prlntf("%s \n", buffer)；
8 }
10
9	void hacker(void)
10	(
11	printf("being hacked\n");
12	}
15
13	int main( int argc, char *argv[])
14	{
outputs(argv[l]);
return 0 ；
17	}
21
上述函数 outputs 是一个有漏洞的程序，当命令行中给定的字符串超过 15 个字符时，使用 strcpy函数就会使缓冲区造成写溢出。首先来看一下使用反汇编工具得到的 outputs 汇编代码。
0x080483e4	< outputs + 0 > : push	%ebp
0x080483e5	< outputs +1 > :  mov	%esp,%ebp
3    0x080483e7	< outputs +3 > :  sub	$0x18,%esp
0x080483ea	< outputs + 6 > :  mov	0x8(%ebp),%eax
0x080483ed	< outputs +9 > :  mov	%eax,0x4(%esp)
0x080483fl	< outputs +13	>: lea	0xfffffff0(%ebp),%eax
7    0x080483f4	< outputs +16	>: mov	%eax,(%esp)
OxO8O483fc < outputs +24 > : lea	0xfffffff0(%ebp),%eax
0x080483ff < outputs +27 > : mov	%eax,0x4(%esp)
11   0x08048403	< outputs  +31 > : movl	$0x8048500 , (%esp)
12   0x0804840a	< outputs + 38 > : call	0x8048310
13   0x0804840f	< outputs +43 >: 1 eave
14   0x08048410	< outputs +44 > : ret
第 3 行指令说明编译器在栈帧中分配了 0x18 =24 个字节空间；在第 8 行 call 指令调用 strcpy 函数之前，栈中存放了两个参数，一个是 outputs 函数的入口参数 str(存放在栈中地址为 R[ebp]+8 之处)， 另一个是 buffer 数组在栈中的首地址 R[ebp]-16,可以看出第 6 行指令中 的偏移量为真值为-16);第 12 行用 call 指令调用 printf 函数。根据上述分析，可以 画出如图 3.31 所示的 outputs 的栈帧状态。

图 5-1  outputs 栈帧中的内容
图 5-1 中传递给 strcpy 的实参 M [ R[ ebp] + 8 ] 实际上就是在 main 函数中指定的命令行参数首地址，它是一个字符串的首址，此程序中函数 strcpy 实现的功能就是，将命令行中指定的字符串复制到缓冲区buffer 中，如果攻击者在命令行中构造一个长度为16+4+4+ 1 =25 个字符的字符串，并将 hacker 函数的首地址置于结束符'\0'前面的 4 个字节，则在执行完 strcpy 函数后 hacker 代码段首地址被置于过程main 栈帧最后的返回地址处，当执行到 outputs 代码的第 14 行 ret 指令时，便会转到 hacker 函数实施攻击。这里，25个字符中的前16个字符填满buffer区，4 个字符覆盖掉 EBP 的旧值，4 个字节的 hacker 函数首地址覆盖返回地址，还有一个是字符串结束符。
·假定 hacker 代码首地址为 0x08048411,则可编写如下的攻击代码实施攻击。

#include "stdio.h" 2
char code[]-
3 "0123456789ABCDEFXXXX"
4    ,,\xll\x84\x04\x08n
5    M\x00";
6 int main(void)
7 {
8	char *arg[3];
9	arg[0] ="./test";
arg[l]=code;
arg[2] =NULL;
execve(arg[0], arg, NULL);
return 0;
14 }
执行上述程序时，通过系统调用 execve。可装入 test 可执行文件，并将 code 中的字符串作 为命令行参数来启动执行 test。因此，字符串中前 16 个字符’0'、’1'、'2，、’3，、 '5'、'6'、'7'、
'8'、‘9‘、'A'、'B'、'C'、'D'、'E'、'F'被复制到 buffer 中，4 个字符'X'覆盖掉 EBP 的旧值，地址 0x08048411 覆盖掉返回地址。执行上述攻击程序后的输岀结果为：
 ••0123456789ABCDEFXXXX □□□□
being hacked Segmentation fault
输岀结果中第一行为执行。utputs 函数后的结果，其中后面 4 个为不可显示字符(对应 ASCII 码 11H、84H、xO4H 和 08H)；执行完 outputs 后程序被恶意地跳转到 hacker 函数执行, 因此会显示第二行字符串； 最后一行显示“Segmentation fault (段错误)”，其原因是在调用 hacker 函数时并没有保存其调用函数的返回地址，所以在执行到 hacker 过程的 ret 指令时取到 的“返回地址”是一个不确定的值，因而可能跳转到数据区或系统区或其他非法访问的存储 区去执行，造成段错误。
   上面的错误主要是 strcpy()函数没有进行缓冲区边界检查而直接把 str 中的内容复制到 buffer 造成的。存在像 strcpy 这样问题的标准函数还有 s treat。、sprintf。、vsprintf。、gets。、 scanf() 等。
缓冲区溢出攻击有多种英文名称：buffer overflow, buffer overrun, smash the stack, trash the stack, scribble the stack, mangle the stack, memory leak, overrun screw 等。第一个缓冲区溢出攻 击是 Morris 蠕虫，发生在 20 年前，它曾造成全世界 6000 多台网络服务器瘫痪。
随便往缓冲区中填东西造成它溢出一般只会出现段错误，而不能达到攻击的目的。最常见 的手段是通过制造缓冲区溢出使程序运行一个用户 shell,再通过 shell 执行其他命令。如果该 程序属于 root 且有 suid 权限的话，攻击者就获得了一个有 root 权限的 shell,就可以对系统进行 任意操作了。
缓冲区溢出攻击之所以成为一种常见安全攻击手段，其原因在于缓冲区溢出漏洞太普遍 了，并且易于实现。而且，缓冲区溢出成为远程攻击的主要手段，其原因在于缓冲区溢出漏洞 使攻击者能够植入并且执行攻击代码。被植入的攻击代码以一定的权限运行有缓冲区溢出漏洞 的程序，从而得到被攻击主机的控制权。

5.2缓冲区溢出攻击的防范
缓冲区溢出攻击的存在给计算机的安全带来了很大的威胁，对于缓冲区溢出攻击，主要可 以从两个方面来釆取相应的防范措施，一个是从程序员角度，另一个是从编译器和操作系统 方面。
对于程序员来说，应该尽量编写出没有漏洞的正确代码。当然，对于编写像 C 这种语法灵 活、风格自由的高级语言程序，如果要编写出正确代码，通常需要花费较多的时间精力。为了 帮助经验不足的程序员编写安全、正确的程序，人们开发了一些辅助工具和技术。最简单的方 法就是用 grep 来搜索源代码中容易产生漏洞的库函数的调用，比如对 Strcpy 和 sprintf 的调用， 这两个函数都不会检査输入参数的长度；此外，人们还开发了一些高级的查错工具，如 fault injection 等，这些工具的目的在于通过人为随机地产生一些缓冲区溢出来寻找代码的安全漏洞； 还有一些静态分析工具用于侦测缓冲区溢出的存在。虽然这些工具能帮助程序员开发更安全的程序，但是.由于 C 语言的特点，这些工具不一定能找出所有缓冲区溢出漏洞，只能用来减少 缓冲区溢出的可能。
对于编译器和操作系统来说，应该尽量生成没有漏洞的安全代码。现代编译器和操作系统 已经釆用了多种机制来保护缓冲区免受缓冲区溢出的攻击和影响，例如，有地址空间随机化、 栈破坏检测和可执行代码区域限制等方式。

5.2.1.地址空间随机化
地址空间随机化(Address Space Layout Randomization,简称 ASLR)是一种比较有效的防 御缓冲区溢出攻击的技术，目前在 Linux、FreeBSD 和 Windows Vista 等主流操作系统中都使用 了该技术。
基于缓冲区溢出漏洞的攻击者必须了解缓冲区的起始地址，以便将一个"溢出”的字符 串以及指向攻击代码的指针植入具有漏洞的程序的栈中。对于早先的系统，每个程序的栈位置 是固定的，在不同机器上生成和运行同一个程序时，只要操作系统相同，则栈的位置就完全一 样。因而，程序中函数的栈帧首地址非常容易预测。如果攻击者可以确定一个有漏洞的常用程 序所使用的栈地址空间，就可以设计一个针对性的攻击，在使用该程序的很多机器上实施 攻击。
   地址空间随机化的基本思路是，将加载程序时生成的代码段、静态数据段、堆区、动态库 和栈区各部分的首地址进行随机化处理(起始位置在一定范围内是随机的)，使得每次启动执 行时，程序各段被加载到不同的地址起始处。由此可见，在不同机器上运行相同的程序时，程 序加载的地址空间是不同的， 显然，这种不同包括了栈地址空间的不同，因此，对于一个随机 生成的栈起始地址，基于缓冲区溢出漏洞的攻击者不太容易确定栈的起始位置。通常将这种使 程序加载的栈空间的起始位置随机变化的技术称为栈随机化。
如果攻击者使用蛮力多次反复使用不同的栈地址进行试探性攻击，那随机化防范措施还是 有可能被攻破。这时就要用到下一步的栈破坏检测措施。

5.2.2.栈破坏检测
如果在程序跳转到攻击代码执行之前，能够检测出程序的栈已被破坏，就可避免受到严重 攻击。新的 GCC 版本在产生的代码中加入了一种栈保护者(stack protector)机制，用于检测 缓冲区是否越界。主要思想是，在函数的准备阶段，在其栈帧中的缓冲区底部与保存的寄存器 状态之间(例如，图 3.31 中
outputs 栈帧中的 buffer[l5]与保留的 EBP 之间)加入一个随机生 成的特定值；在函数的恢复阶段，在恢复寄存器并返回到调用函数前，先检査该值是否被改 变。若值发生改变，则程序异常终止。因为插入在栈帧中的特定值是随机生成的，所以攻击者 很难猜测出它是什么。

5.2.3.可执行代码区域限制
通过将程序的数据段地址空间设置为不可执行，从而使得攻击者不可能执行被植入在输入 缓冲区的代码，这种技术也被称为非执行的缓冲区技术。早期 UNIX 系统只允许程序代码在代 码段中执行，也即只有代码段的访问属性是可执行，其他区域的访问属性是可读或可读可写。 但是，近来 UNIX 和 Windows 系统由于要实现更好的性能和功能，往往允许在数据段中动态地 加入可执行代码，这是缓冲区溢出的根源。当然，为了保持程序的兼容性，不可能使所有数据段都设置成不可执行。不过，可以将动态的栈段设置为不可执行，这样可以既保证程序的兼容 性，又可以有效防止把代码植入栈(自动变量缓冲区)的溢出攻击。因为除了信息传递等少 数情况下会使栈中存在可执行代码外，几乎没有任何合法的程序会在栈中存放可执行代码，因 此这种做法几乎不产生任何兼容性问题。
不幸的是，栈的“不可执行”保护对于将攻击代码植入堆或者静态数据段的攻击没有效 果，通过引用一个驻留程序的指针，就可以跳过这种保护措施。

6.x86-64架构
6.1X86-64的基本特点
对于编译器来说，对高级语言程序进行编译可以有两种选择，一种是按 IA-32 指令集将目标 编译成LA-32 代码，一种是按 x86-64 指令集将目标编译成 x86-64 代码。通常，在 IA-32 架构上运 行的是 32 位操作系统，GCC 默认生成 IA-32 代码；在 x86-M 架构上运行的是 64 位操作系统，GCC 默认生成 x86-M 代码。Linux 和 GCC 将前者称为*i386"平台，将后者称为“x86-64”平台。
与 IA-32 代码相比，x86-64 代码主要有以下几个方面的特点。
IA-32 具有更多的通用寄存器个数。新增的 8 个 64 位通用寄存器名称分别为 R8、R9、 RIO、Rll、R12、R13、R14 和 R15。它们可以作为 8 位寄存器（R8B~R15B）、16 位寄存器 （R8W-R15W）或 32位寄存器（R8D-R15D）使用，以访问其中的低 8 位、低 16 位或低 32 位。
IA-32 具有更长的通用寄存器位数，从 32 位扩展到 64 位。在 x86-64 中，所有通用寄 存器（GPR）都从 32 位扩充到了 64 位，名称也发生了变化。8 个 32 位通用寄存器 EAX、EBX、ECX、EDX、EBP、ESP、ESI 和 EDI 对应的扩展为 64 位的寄存器分别被命名为 RAX、RBX、RCX、RDX、RBP、RSP、RSI 和 RDI。在 IA-32 中，四个寄存器 EBP、ESP、ESI 和 EDI 的低 8 位不能使用，而在 x86-64 架构中， 可以使用这些寄存器的低 8 位，其对应的寄存器名称为 BPL、SPL、SIL 和 DIL。
整数操作不仅支持 8、16、32 位数据类型，还支持 64 位数据类型。所有算术逻辑运算、 寄存器与内存之间的数据传输，都能以最多 64 位为单位进行操作。栈的压入和弹出操作都以 8 字节为单位进行。
字长从 32 位变为 64 位，因而逻辑地址从 32 位变为 64 位。指针（如 char,型）和长整 型（long 型）数据从 32 位扩展到 64 位，与 IA-32 平台相比，理论上其数据访问的空间大小从 2%=4GB 扩展到了 2"B= 16EB。不过，目前仅支持 48 位逻辑地址空间，即逻辑地址从 4GB 增加到了 256TB。
对于 long double 型数据，虽然还是采用与 IA-32 相同的 80 位扩展精度格式，但是，所 分配的存储空间从 IA-32 的 12 字节扩展为 16 字节。也即，此类数据的边界从 12B 对齐改为 16B 对齐，不管是分配 12 字节还是分配 16 字节，都只会用到低 10 个字节。
过程调用时，对于入口参数只有 6 个以内的整型变量和指针型变量的情况，通常就用 通用寄存器而不是栈来传递，因而，很多过程可以不用访问栈，这样，使得大多数情况下执行 时间比 IA-32 代码更短。
128 位的 MMX 寄存器从原来的 8 个增加到了 16 个，浮点操作采用基于 SSE 的面向 XMM 寄存器的指令集，而不采用基于浮点寄存器栈的指令集。

6.2 X86-64的寄存器组织


6.3 x86-64的基本指令和对齐
x86-64 指令集在兼容 1A-32 的基础上，还能支持 64 位数据操作指令，大部分操作数指示 符与 IA-32-样，所不同的是，当指令中的操作数为存储器操作数时，其基址寄存器或变址寄 存器都必须是 64 位寄存器；此外，在运算类指令中，除了支持原来 IA-32 中的寻址方式以外， x86-64 还支持 PC 相对寻址方式，相对地址是一个 32 位补码表示的数。

6.3.1数据传送指令
在 X86-64 中，提供了一些在 IA-32 中没有的新的数据传送指令，例如，movabsq 指令用于将 一个64 位立即数送到一个 64 位通用寄存器中；movq 指令用于传送一个 64 位的四字；movsbq、movswq、movslq 用于将源操作数进行符号扩展并传送到一个 64 位寄存器或存储单元中；movzbq、movzwq 用于将源操作数进行零扩展后传送到一个 64 位寄存器或存储单元中；pushq 和 popq 分别是四 字压栈和四字出栈指令。汇编指令中指令助记符结尾处的“q”表示操作数长度为四字（64 位）。
在 x86-64 中，movl 指令的功能与在 IA-32 中有点不同，它在传送 32 位寄存器内容的同时， 还会将目的寄存器的高 32 位自动清 0,因此，在 x86-64 中，movl 指令的功能相当于 movzlq 指 令，因而在 x86-64中不需要 movzlq 指令。
以下是一个 C 语言函数，其功能是将类型为 source_type 的参数转换为 dest_type 类 型的数据并返回。
dest_type convert（source_type x）
 { dest_type y = （dest_type） x;
return y
}
根据过程调用时的参数传递约定可 知，，存放在寄存器 RDI 对应的适合宽度的寄存器（如 RDI、EDI, DI 和 DIL）中，y 存放在 RAX 对应宽度的寄存器（RAX、EAX、AX 或 AL）中。表 3.9 中给出了source_type 和 dest_type 的类型组合，请给出相应的汇编指令，以实现 convert 函数。




根据 x86-64 数据传输指令的功能，得到对应表 3.9 所示类型的汇编指令见表 3.10, 表中汇编指令为AT&T 格式。在表 3. 10 中，将 long 型数据转换为 int 型数据时，可以用两种不 同的指令 movslq 和 movl。虽然执行这两种指令得到的 RAX 中高 32 位内容可能不同，但是, EAX 中的结果是一样的。因为函数返回的是 int 型数据，所以 RAX 中高 32 位的值没有意义, 只要 EAX 中的 32 位值正确即可。

6.3.2 算术逻辑运算指令
在 X86-64 中，增加了操作数长度为四字的运算类指令（长度后缀为 q）,例如，addq（四字 相加）、subq（四字相减）、imulq（带符号整数四字相乘）、orq（64 位相或）、leaq（有效地址加载 到 64 位寄存器）等。
OEKD 以下是 C 语言赋值语句"x = a*b + c*d；"对应的 x86- 64 汇编代码，已知*、 a、b、c 和 d分别在寄存器 RAX、RDI、RSI、RDX 和 RCX 对应宽度的寄存器中。根据以下汇 编代码，推测变量叙 a、b、c 和 d 的数据类型。
movslq %ecx, %rcx
imulq %rdx, %rcx
movsbl %si 1 , %esi
imul1 %edi , %es1
movslq %esi , %rsi
leaq （%rcx, %rs1）, %rax
根据第 1 行可知，在 ECX 中的变量 d 从 32 位符号扩展为 64 位，因此，变量 d 的数 据类型为 int 型；根据第 2 行可知，在 RDX 中的变量 c 为 64 位整型，即 c 的数据类型为 long 型；根据第 3 行可知， 在 SIL 中的变量 6 为 char 型数据；根据第 4 行可知，在 ED1 中的 a 是 int 型数据；根据第 5 行和第 6 行可知，存放在 RAX 中的，是 long 型数据。







6.3.2.1算术逻辑部件（ALU）

进行基本算术运算与逻辑运算
-无符号整数加、减
-带符号整数加、减
-与、或、非、异或等逻辑运算
核心电路是整数加/减运算部件
输出除和/差等，还有标志信息
有一个操作控制端（ALUop），用来决定ALU所执行的处理功能。ALUop的位数k决定了操作的种类，例如，当位数k为3时，ALU最多只有23=8种操作。
    
6.3.2.2 条件标志位

还记得如何得到各个标志位吗？
OF：若A与B’同号但与Sum不同号，则1；否则0。SF：sum符号
ZF：如Sum为0，则1，否则0。CF：Cout 异或 sub
-零标志ZF、溢出标志OF、进/借位标志CF、符号标志SF称为条件标志。
-条件标志（Flag）在运算电路中产生，被记录到专门的寄存器中
-存放标志的寄存器通常称为程序/状态字寄存器或标志寄存器。每个标志对应标志寄存器中的一个标志位。 如，IA-32中的EFLAGS寄存器


6.3.3 过程调用
在 x86-64 中，过程调用通过寄存器传送参数，因而寄存器的功能有一点变化。首先，在 x86-64 中， 无需帧指针寄存器，因而 RBP 可作为普通寄存器使用；其次，传送入口参数的寄 存器依次为 RDI、RSI、RDX、RCX、R8 和 R9,返回参数存放在 RAX 中；第三，调用者保存 寄存器为 R10 和 R11,被调用者保存寄存器为 RBX、RBP、R12、R13、R14 和 R15；第四， RSP 用于指向栈顶元素；第五，RIP 用于指向正在执行或即将执行的指令。
如果入口参数是整数类型或指针类型且少于等于 6 个，则无需用栈来传递参数，如果同时 该过程无需在栈中存放局部变量和被调用者保存寄存器的值，那么，该过程就不需要栈帧。传 递参数时，如果参数是 32 位、16 位或 8 位，则参数被置于对应宽度的寄存器部分。例如，若 第一个入口参数是 char 型，则放在 RD1 中对应字节宽度的寄存器 DIL 中；若返回参数是 short 型，则放在 RAX 中对应 16 位宽度的寄存器 AX 中。表 3. 11 给出了每个入口参数和返回参数所 在的对应寄存器。

在 x86-64 中，最多可以有 6 个整型或指针型入口参数通过寄存器传递，超过 6 个入口参数 时.后面的通过栈来传递.在栈中传递的参数若是基本类型数据，则不管是什么基本类型都被分配 8 个字节。当入口参数少于 6 个或者当入口参数已经被用过而不再需要时，存放对应参数 的寄存器可以被函数作为临时寄存器使用。对于存放返回结果的 RAX 寄存器，在产生最终结 果之前，也可以作为临时寄存器被函数重复使用。
在 X86-64 中，调用指令 call（或 callq）将一个 64 位返回地址保存在栈中并执行 R[rsp] — R[rsp]-8。返回指令 ret 也是从栈中取出 64 位返回地址并执行 R[ rsp] —R[rsp] +8。
·以下是函数 caller 和 test 的 C 语言源程序。

假定上述源程序对应的 x86-64 汇编代码如下。 函数 caller 的汇编代码如下：

函数 test 的汇编代码如下：
要求根据上述汇编代码，分别画出在执行到 caller 函数的 call 指令时、执行到 test 函数的 ret 指令时栈中信息的存放情况，并说明 caller 是如何把实参传递给 test 中的形参的，而 test 执 行时其每个入口参数又是如何获得的。
 从 caller 汇编代码可以看出，栈指针寄存器 RSP 仅在第 2 行做了一次减法，申请了 32 字节的空间， 在最后第 25 行恢复 RSP 之前一直没有变化，说明 caller 栈帧就是 32 字节。第 3 ~6 行用来在栈帧中分配局部变量/>、c 和 d,并将初值存入相应单元。可以看出，这 4 个 变量一共占用了 16 个字节。第 7~15 行用来将实参存入 test 入口参数对应的寄存器中，因为有 8 个入口参数，所以还有两个参数需要通过栈进行传递，其中第 7~8 行用于在栈中存入第 8 个 参数，第 9 行用于在栈中存入第 7 个参数，第 10-15 行分别用于在相应的寄存器中存入第 6、 第 5、第 4、第 3、第 2 和第 1 个参数。因此，在执行到第 16 行 call 指令之时，前 6 个参数分别 在寄存器 DIL、RSI、DX、RCX、R8D 和 R9 中，第 7 和第 8 个参数在栈中的位置分别由 R[rsp] 和 R[rsp]+8 指出。图 3.32a 给出了此时 caller 栈帧中信息的存放情况。
图6-1  caUer 和 test 执行时栈中信息存放情况

在 caller 中的 call 指令执行后，栈指针寄存器 RSP 的内容减 8,并将 call 指令下面一条指令的 地址(第17 行指令所在地址)作为返回地址存入当前 RSP 所指单元，然后跳转到 test 执行。在 test 执行过程中，第 2 行指令用来取出第 8 个参数，第 3~5 行分别用于实现赋值语句"*ap+=a；”、 "*bp+=b;"和"*cp+=c；"。其中，指针类型变量叩、如和 cp 的值各是 caller 中局部变量 a、 6 和 c 在栈中的地址，即*ap = a、*bp=b、*cp=c°执行完第 3 ~ 5 行指令后，栈中 a、'和 c 处的内容为原来内容的两倍。第 6 行指令用来取出第 7 个参数(其值为 4),第 7 行指令用来将 4 加到第 8 个参数所指单元 d 处，使得日处的内容变为 8。综上所述，在执行到 test 的 ret 指令 时，栈中信息存放情况如图 3.32b 所示。
这里要特别说明的是，即使在栈中传递的最后两个参数不是 1。理型或指针类型，也都被分 配 8 个字节。例如，假定上述 test 函数的原型为“void test (char a, char *ap, short b, short *bp, longd, long*dp, intc, int *cp)”，即在栈中传递的最后两个参数类型是 4 字节的 int 型和 8 字 节的指针型，它们在栈中所占的空间都是 8 个字节。



6.3.4浮点操作与 SIMD 指令
在 x86-64 中，浮点运算釆用基于 SSE 的面向 XMM 寄存器的 SIMD 指令，浮点数存放在128 位的 XMM 寄存器中，而不是存放 x87 FPU 的 80 位浮点寄存器栈中。以下是一段 c 语言代码：
#include < stdi o.h > 2
main()
3 {
double a = 10;
printf("a = %d\n", a);
6 }
上述代码在 IA-32 平台上运行时，打印出来的结果总是 a=0,但是在 x86-64 平台上运行时，打印出来的 a 却是一个不确定的值，请问为什么？
本题给出的代码的主要功能是，将一个 64 位双精度浮点数*10'转换为一个 32 位二进制数，然后以十进制数形式打印出来。
IEEE 754 双精度浮点数由 64 位组成，最高位为符号位 s,随后的 11 位为阶码 e,其偏置常
数为 1023,余下 52 位为尾数 f.因为 10 = 1010B = 1.01B x23,因此 s =0, e = 1023 + 3 =
100 0000 0010, f= 0100 --0o  也即 64 位机器数为 0 100 0000 0010 0100 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000,因此，a 的机器数用十六进制形式表示的字节序列为40H、24H、00H、00H、00H、00H、OOH、00H。将其高 32 位转换为十进制数，其值为 1076 101 120,低 32 位的值为 0。在 IA-32 中，过程采用栈传递参数。图 3. 33 给出了在 IA-32 中 printf 的参数在栈中的存放情况。因为 IA-32 是小端方式，所以 a 的高位部分在栈中的髙地址上，低位部分在栈中的低地址上。
当 printf 将变量 a 的值使用“ ％d”
输出时，对应的数据类型是 int 型，因此
取 a 中低 4 字节作为第 2 个参数。显然，
printf 会从栈中 R [ ebp ] + 12 的位置开始
从低地址到高地址读取 4 个字节作为 int             图 6-2 1A-32 平台使用栈进行参数传递型数据来解释并输出，因此，代码打印输出的结果为“a=0”
在 X86-64 中，过程采用通用寄存器传递参数，因为该题 printf 共有两个参数且使用“％d” 输出，因此，这两个参数应该各自通过 RDI 和 ESI 进行传递，其中 RDI 中存放字符串"a = %d\n” 的首地址，而 ESI 中存放 a 的低 32 位，printf 函数会到默认的 RDI 和 ESI 中去取相应的参数进 行处理。但是，因为本题中 a 是一个 double 型的浮点数据，所以，在 x86-64 中会把 a 的值送到浮点寄存器 XMM 中，而不会传到 ESI 中，因此，在 printf 执行时，当从 ESI 中读取要打印的 int 型变量时，实际上不会得到。的低 32 位，而是当时 ESI 寄存器中的内容。每次执行上述代码时，ESI 中的内容都可能发生变化，因而每次打印出来的值都可能不同。以下是在某个 x86-64 平台上对上述源代码进行编译的结果。

从上述汇编代码中可以看出，第 13 行的 movsd 指令用来将标号.LCO 处的双精度浮点数 a 送入 XMM0 寄存器，第 14 行的 movl 指令将标号丄 C1 的值(指向字符串"a=%d\n”)送入 EDI 寄存器，并没有任何指令将 a 的低 32 位送到 ESI 寄存器中。

6.4 x86-64的数据对齐
与 IA-32 -样，x86-64 中各种类型数据应该遵循一定的对齐规则，而且要求更加严格。因 为 x86-64 中存储器的访问接口被设计成以 8 字节或 16 字节为单位进行存取，其对齐规则是, 任何 K 字节宽的基本类型数据和指针类型数据的起始地址一定是 K 的倍数。因此，long 型、 double 型数据和指针型变量都必须按 8 字节边界对齐；long double 型数据必须按 16 字节边界 对齐。

6.5 x86-64的程序例子

