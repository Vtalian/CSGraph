第四章 数据的机器级表示与处理

在高级语言程序中需要定义所处理数据的类型以及存储的数据结构。例如，C 语言程序中 有无符号整数类型（unsigned int）、带符号整数类型（int）、单精度浮点数类型（float）等；此 外，在 C 语言中，多个相同类型数据可以构成一个数组（array）,多个不同类型数据可以构成 结构（struct）。那么，在高级语言程序中定义的这些数据在计算机内部是如何表示的？它们在 计算机中又是如何存储、运算和传送的呢？
本章重点讨论数据在计算机内部的机器级表示和基本处理方式。主要内容包括：进位计数 制、二进制定点数的编码表示、无符号整数和带符号整数的表示、IEEE 754 浮点数表示标准、 西文字符和汉字的编码表示、十进制数的二进制编码表示（即 BCD 码）、C 语言中各种类型数 据的表示和转换、数据的宽度和存放顺序、基本运算及其运算电路。

1.数据表示概述
1.1数据的宽度和单位
计算机内部任何信息都被表示成二进制编码形式。二进制数据的每一位（0 或 1）是组成 二进制信息的最小单位，称为一个“比特” （bit）,或称“位元”，简称“位”。比特是计算机 中存储、运算和传输信息的最小单位。
每个西文字符需要用 8 个比特表示，而每个汉字需要用 16 个比特才能表示。在计算机内 部，二进制信息的计量单位是“字节” （byte）,也称“位组”。一个字节等于 8 个比特。
计算机中运算和处理二进制信息时使用的单位除了比特和字节之外，还经常使用“字” （word）作
为单位。必须注意，不同的计算机，字的长度和组成不完全相同，有的由 2 个字节 组成，有的由 4 个、8个甚至 16 个字节组成。
在考察计算机性能时，一个很重要的指标就是机器的“字长”。平时所说的“某种机器是 16 位机或是 32 位机”，其中的 16、32 就是指字长。所谓“机器字长”通常是指 CPU 内部用于 整数运算的数据通路的宽度。CPU 内部数据通路是指 CPU 内部的数据流经的路径以及路径上 的部件，主要是 CPU 内部进行数据运算、存储和传送的部件，这些部件的宽度基本上要一致 才能相互匹配。因此，“字长”等于 CPU 内部用于整数运算的运算器位数和通用寄存器宽度。
“字”和“字长”的概念不同，这一点请注意。“字”用来表示被处理信息的单位，用来 度量各种数据类型的宽度。通常系统结构设计者必须考虑一台机器将提供哪些数据类型，每种 数据类型提供哪几种宽度的数，这时就要给出一个基本的“字”的宽度。例如，Intel x86 微处 理器中把一个字定义为 16 位。所提供的数据类型中，就有单字宽度的无符号整数和带符号整 数（16 位）、双字宽度的无符号整数和带符号整数（32 位）等。而“字长”表示进行数据运 算、存储和传送的部件的宽度，它反映了计算机处理信息的一种能力。“字”和"字长”的长 度可以一样，也可以不一样。例如，在 Intel 微处理器中，从 80386 开始就至少都是 32 位机器 了，即字长至少为 32 位，但其字的宽度都定义为 16 位，32 位称为双字。
表示二进制信息存储容量时所用的单位要比字节或字大得多，主要有以下几种单位词头。
K（Kilo）： 1KB=210 字节= 1024 字节
M(Mega) : 1MB =220 字节=1 048 576 字节
G( Giga) ： 1GB = 230 字节=1 073 741 824 字节
T(Tera) : 1TB =240 字节=1 099 511 627 776 字节
P( Peta) ： 1PB = 250 字节=1 125 899 906 842 624 字节
E(Exa): 1EB =260 字节 = 1 152 921 504 606 846 976 字节
Z(Zetta): 1ZB=270 字节=1 180 591 620 717 411 303 424 字节
Y(Yotta) : 1YB =280 字节=1 208 925 819 614 629 174 706 176 字节

在描述距离、频率等数值时通常用 10 的慕次表示，因而在由时钟频率计算得到的总线带宽或外设数据传输率中，度量单位表示的也是 10 的蓦次。为区分这种差别，通常用 K 表示1024,用 k 表示 1000,而其他前缀字母均为大写，表示的大小由其上下文决定。经常使用的带宽单位如下。
比特/秒(b/s),有时也写为 bps
千比特/秒(kb/s)： lkb/s = 103b/s = 1000bps
兆比特/秒(Mb/s)： lMb/s = 106b/s = 1000kbps
吉比特/秒(Gb/s) : 1 Gb/s = 109b/s = 1000Mbps
太比特/秒(Tb/s) : ITb/s = 10'2b/s = lOOOGbps
由于程序需要对不同类型、不同长度的数据进行处理，所以，计算机中底层机器级的数据
表示必须能够提供相应的支持。比如，需要提供不同长度的整数和不同长度的浮点数表示，相应地需要有处理单字节、双字节、4 字节甚至是 8 字节整数的整数运算指令，以及能够处理4字节、8 字节浮点数的浮点数运算指令等。
C 语言支持多种格式的整数和浮点数表示。数据类型 char 表示单个字节，能用来表示单个字符，也可用来表示 8 位整数。类型int 之前可加上 long 和 short,以提供不同长度的整数表示。表 1.1 给出了在典型的 32 位机器和 64 位机器上 C 语言中数值数据类方式。


从表 1.1可以看出，短整数为 2 个字节，普通 int 型整数为 4 个字节，而长整数的宽度 与机器字长的宽度相同。指针(例如，一个声明为类型 char•的变量)和长整数的宽度一样，也等于机器字长的宽度。一般机器都支持 float 和 double 两种类型的浮点数，分别对应 IEEE 754 单精度和双精度格式。
由此可见，对于同一类型的数据，并不是所有机器都采用相同的数据宽度，分配的字节数 随处理器和编译器的不同而不同。

1.2数据的存储和排列顺序
任何信息在计算机中用二进制编码后，得到的都是一串 0/1 序列，每 8 位构成一个字节， 不同的数据类型具有不同的字节宽度。在计算机中存储数据时，数据从低位到高位的排列可以

从左到右，也可以从右到左。所以，用“最左位”(leftmost)和“最右位”(rightmost)来表 示数据中的数位时会发生歧义。因此，—般用最低有效位(Least Significant Bit,简称 LSB)和 最高有效位(Most Significant Bit,简称 MSB)来分别表示数的最低位和最高位。对于带符号 数，最高位是符号位，所以MSB 就是符号位。这样，不管数是从左往右排，还是从右往左排， 只要明确 MSB 和 LSB 的位置，就可以明确数的符号和数值。例如，数“5”在 32 位机器上用 int 类型表示时的 0/1 序列为“0000 0000 0000 0000 0000 0000 0000 0101",其中最前面的一位 0 是符号位，即 MSB=0,最后面的 1 是数的最低有效位， 即 LSB = 1。
如果以字节为一个排列基本单位，那么 LSB 表示最低有效字节(Least Significant Byte), MSB 表示最高有效字节(Most Significant Byte)o 现代计算机基本上都采用字节编址方式，即对 存储空间的存储单元进行编号时，每个地址编号中存放一个字节。计算机中许多类型数据由多 个字节组成，例如，int 和 float 型数据占用 4 个字节，double 型数据占用 8 个字节等，而程序中 对每个数据只给定一个地址。例如，在一个按字节编址的计算机中，假定 int 型变量 i 的地址 为 08 00H, £的机器数为 01 23 45 67H, 这 4 个字节 01H、23H、45H、67H 应该各有一个存储 地址，那么，地址 08 00H 对应 4 个字节中的哪个字节的地址呢？这就是字节排列顺序问题。
在所有计算机中，多字节数据都被存放在连续的字节序列中。根据数据中各字节在连续字 节序列中的排列顺序的不同，可有两种排列方式：大端(big endian)和小端(little endian), 如图 1.1 所示。


图 1.1 大端方式和小端方式
大端方式将数据的最高有效字节存放在低地址单元中，将最低有效字节存放在高地址单元 中，即数据的地址就是 MSB 所在的地址。IBM 360/370、Motorola 68k, MIPS、Sparc、HP PA 等 机器都采用大端方式。
小端方式将数据的最高有效字节存放在高地址单元中,将最低有效字节存放在低地址单元 中，即数
据的地址就是 LSB 所在的地址。Intel 80x86、DEC VAX 等都采用小端方式。
有些微处理器芯片，如 Alpha 和 Motorola 的 PowerPC,能够运行在任意一种模式，只要在 芯片加电启动时选择确定采用大端还是小端模式即可。每个计算机系统内部的数据排列顺序都 是一致的，但在系统之间进行通信时可能会发生问题。在排列顺序不同的系统之间进行数据通 信时，需要进行顺序转换。网络应用程序员必须遵守字节顺序的有关规则，以确保发送方机器 将它的内部表示格式转换为网络标准， 而接收方机器则将网络标准转换为自己的内部表示 格式。此外，像音频、视频和图像等文件格式或处理程序也都涉及字节顺序问题。如 GIF、PC、Paintbrush Microsoft RTF 等采用小端方式，Adobe Photoshop、JPEG、MacPaint 等采用大端方式。
了解字节顺序的好处还在于调试底层机器级程序时，能够清楚每个数据的字节顺序，以便 将一个机器数正确转换为真值。例如，以下是一个由反汇编器(反汇编是汇编的逆过程,即将 指令的机器代码转换为汇编表示)生成的一行针对 IA-32 处理器的机器级代码表示文本。
80483 d2: 89 85 a0 fe ff ff mov % eax, OxfffffeaO (% ebp)
该文本行中，“80483d2”代表存储地址，是十六进制表示形式，“89 85 aO fe ff ff”是指令 的机器代码,按顺序存放在地址 0x80483d2 开始的 6 个连续存储单元中，“mov % eax, OxfffffeaO (%ebp)” 是指令的汇编形式。对该指令所指出的第二操作数进行访问时，需要先计算出该操 作数的有效地址，这个有效地址是通过将寄存器％ ebp 的内容与立即数“OxfffffeaO”(字节序列 为 FFH、FFH、FEH 和 A0H)相加得到的。该指令中的立即数是一个补码表示的带符号整数， 补码为“OxfffffeaO”的数的真值为
-101100008= -176,也即第二操作数的有效地址是将寄存 器％ebp 的内容减 176 后得到的值。指令执行时， 可直接取出指令机器代码的后 4 个字节作为 计算有效地址所用的立即数，从指令代码中可看出，立即数在内存存放的字节序列为 A0H、 FEH、FFH、FFH,正好与有效地址计算时实际所用的字节序列相反。显然，该处理器采用的 是小端方式。在阅读这种小端方式计算机的机器代码时，要记住字节是按照相反的顺序显 示的。
例： 以下是一段 C 程序，其中函数 show_int 和 show_float 分别用于显示 int 型和 float 型数据的位序列，show_pointer 用于显示指针型数据的位序列。显示的结果都用十六进制形式 表示，并按照从低地址到高地址的方向显示。
vold test_show_bytes(1nt val )
{
int ival = val；
float fval = (float) 1 val ;
int *pval = &1val;
show_1nt (i val );
show_float (fval);
show_pointer (pval);
}
上述程序在不同系统(Linux 和 NT 运行于 Intel Pentium II)上运行的结果见表 1.2。

表 1.2 程序在不同系统中的运行结果

请回答下列问题。
·十进制数 12 345 用 32 位补码整数和 32 位浮点数表示的结果各是什么？
·十进制数 12 345 的整数表示和浮点数表示中存在一段相同位序列，标记出这段位序列， 并说明为什么会相同。对一个负数来说，其整数表示和浮点数表示中是否也一定会出现一段相 同的位序列？为什么？
·Intel Pentium II 釆用的是小端方式还是大端方式？
·Sun 和 Alpha 之间能否直接进行数据传送？为什么？
·在 Alpha _E ,表中数据字节 30H 所存放的地址是什么？
十进制数 12 345 用 32 位补码整数表示为 0000 0000 0000 0000 0011 0000 0011 1001, 用 32位浮点数表示为 0100 0110 0100 0000 1110 0100 0000 0000o 用十六进制表示分别为 00003039H 和4640E400Ho十进制数 12 345 的整数表示和浮点数表示中相同位序列为 1 0000 0011 1001 o 因为对正 数来说，原码和补码的编码相同，所以其整数（补码表示）和浮点数尾数（原码表示）的有 效数位一样。12 345 的有效数位是 11 0000 0011 1001o 有效数位在定点整数中位于低位数值部 分，在浮点数的尾数中位于高位部分。因为尾数中有一个隐含的 1,所以第一个有效数位 1 在 浮点数中不表示出来，因此，相同的位序列就是后面的 13 位。
因为 IEEE 754 浮点数的尾数用原码表示，而整数用补码表示，负数的原码和补码表示不 同，所以， 对某一个负数来说，其整数表示和浮点数表示中不一定会有一段相同的位序列。Linux 和 NT （运行在 Intel Pentium II）的存放方式与书写习惯顺序相反，故 Intel PentiumII 釆用的是小端方式。Sun 和 Alpha 之间不能直接进行数据传送。因为它们釆用了不同的存放方式，Sun 是大 端方式， 这里 Alpha 设置的是小端方式。
在 Alpha 上数据字节 30H 存放在地址 000000011FFFFC81H 中。因为从 Alpha 输出的 int型指针结果来看，Alpha 的存储地址占 64 位，30H 是 int 型数据 12345 的次低有效字节，小端 方式下数据地址取 LSB 的地址，所以 30H 存放的地址应该是数据地址随后的那个地址。根据小端 方式下存放结果和书写习惯顺序相反的规律，可知数据 12 345 的地址是 000000011FFFFC80H,所 以，随后的地址就是000000011FFFFC81H。

1.3数据的编码
1.3.1 信息的二进制编码
数据是计算机处理的对象。从不同的处理角度来看，数据有不同的表现形态。从外部形式 来看，计算机可处理数值、文字、图、声音、视频以及各种模拟信息，它们被称为感觉媒体。 从算法描述的角度来看，有图、表、树、队列、矩阵等结构类型的数据。从高级语言程序员的 角度来看，有数组、结构、指针、实数、整数、布尔数、字符和字符串等类型的数据。不管以 什么形态出现，在计算机内部数据最终都由机器指令来处理。而从机器指令的角度来看，数据 只有整数、浮点数和位串这几类简单的基本数据类型。
计算机内部处理的所有数据都必须是“数字化编码” 了的数据。现实世界中的感觉媒体 信息由输入设备转化为二进制编码表示，因此，输入设备必须具有“离散化”和“编码”两 方面的功能。因为计算机中用来存储、加工和传输数据的部件都是位数有限的部件，所以，计 算机中只能表示和处理离散的信息。数字化编码过程，就是指对感觉媒体信息进行釆样，将现 实世界中的连续信息转换为计算机中的离散的“样本”信息，然后对样本信息用“0”和“1” 进行数字化编码的过程。所谓编码，就是用少量简单的基本符号，对大量复杂多样的信息进行 一定规律的组合。基本符号的种类和组合规则是信息编码的两大要素。例如，电报码中用 4 位 十进制数字表示汉字，从键盘上输入汉字时用汉语拼音（即 26 个英文字母）表示汉字等，都是编码的典型例子。
在计算机系统内部，所有信息都是用二进制进行编码的。也就是说计算机内部采用的是二 进制表示方式。这样做的原因有以下几点。
二进制只有两种基本状态，使用有两个稳定状态的物理器件就可以表示二进制数的每一 位，而制造有两个稳定状态的物理器件要比制造有多个稳定状态的物理器件容易得多。例如，用 高、低两个电位，或用脉冲的有无、脉冲的正负极性等都可以很方便、很可靠地表示“0”和“1”。
二进制的编码、计数和运算规则都很简单，可用开关电路实现，简便易行。
两个符号“1”和“0”正好与逻辑命题的两个值“真”和“假”相对应，为计算机中 实现逻辑运算和程序中的逻辑判断提供了便利的条件，特别是能通过逻辑门电路方便地实现算 术运算。
釆用二进制编码将各种媒体信息转变成数字化信息后，可以在计算机内部进行存储、运算 和传送。在高级语言程序中，可以用利用图、树、表和队列等数据结构进行算法描述，并以数 组、结构、指针和字符串等数据类型来说明处理对象，但将高级语言程序转换为机器语言程序 后，每条机器指令的操作数就只能是以下 4 种简单的基本数据类型；无符号定点整数、带符号 定点整数、浮点数和非数值型数据（位串），如图 2.1 中虚线框内所示。
图 1.2 计算机外部信息与内部数据的转换
指令所处理的数据类型分为数值数据和非数值数据两种。数值数据可用来表示数量的多 少，可比较其大小，分为整数和实数，整数又分为无符号整数和带符号整数。在计算机内部， 整数用定点数表示，实数用浮点数表示。非数值数据就是一个没有大小之分的位串,不表示数 量的多少，主要用来表示字符数据和逻辑数据。
日常生活中，常使用带正负号的十进制数表示数值数据，例如 6.18、-127 等。但这种形 式的数据在计算机内部难以直接存储、运算和传送，仅用来作为程序的输入或输出形式，以方 便用户从键盘等输入设备输入数据，或从屏幕、打印机等输出设备上输出数据，它不是用于计 算机内部运算和传输的主要表示形式。
在计算机内部，数值数据的表示方法有两大类：第一种是直接用二进制数表示；另一种是 采用二进
制编码的十进制数(Binary Coded Decimal Number,简称 BCD)表示。表示一个数值数据要确定三个要素：进位计数制、定/浮点表示和编码规则。任何给定的 一个二进制0/1 序列，在未确定它采用什么进位计数制、定点还是浮点表示以及编码表示方法 之前，它所代表的数值数据的值是无法确定的。

1.3.2 进位计数制
日常生活中基本上都使用十进制数，其每个数位可用 10 个不同符号 0,1,2,-.9 来表示， 每个符
号处在十进制数中不同位置时，所代表的数值不一样。例如，2585. 62 代表的值是：
(2585. 62) I。= 2 x 103  + 5 x 102  + 8 x 101  + 5 x 10° + 6 x 10'* +2 x 10 2
一般地，任意一个十进制数
D = dndn_x---dYd0. d-2d-2-..-d-m (m,n 为正整数)
其值可表示为如下形式：
V(D) =d  x 10n  + d	x 10"'1  + •- + d, x 101  + d  x 10°
+ d x 10'1  + d_2 x 10-2  + …+ d.  x 10m-

其中 di(j=n,n-l,…,1,0,-I, -2,…，-m)可以是 0,1,2,3,4,5,6,7,8,9 这 10 个数字符号 中的任何一个，“10”称为基数(base),它代表每个数位上可以使用的不同数字符号个数。 10’称为第 i 位上的权。在十进制数进行运算时，每位计满十之后就要向高位进一，即日常所 说的“逢十进一”。
类似地，二进制数的基数是 2,只使用两个不同的数字符号 0 和 1,运算时采用“逢二进 一”的规则，
第財立上的权是 2'。例如，二进制数(100101. 01 )2 代表的值是：
(100101. 01 ) = 1 x 25  + 0 x 24  + 0 x 23  + 1 x 22  + 0 x 2* + 1 x 2° + 0 x 2'1  + 1 x 2-2
=(37. 25)10
一般地，任意一个二进制数
B =dndn_x---dYd0. d-2d-2-..-d-m  (m,zi 为正整数)
其值可表示为如下形式：
V(B) =6„ x 2" + bn_t  x 2n-1  + …+ d1 x 21  + b0  x 2°
+ 6_, x2 ' +b_2  x2'2  + ••• + \ x2~m
其中 bi(i = n,n --1,...,1,0,- 1, -2,…，-m)只可以是 0 和 1 两种不同的数字符号。
扩展到一般情况，在 R 进制数字系统中，应采用 R 个基本符号(0,1,2,“、R-1)表示 各位上的数字， 采用“逢 R 进一”的运算规则，对于每一个数位 i,该位上的权为 R'。R 被称 为该数字系统的基。
在计算机系统中使用的常用进位计数制有下列几种。二进制 A =2,基本符号为 0 和 1。
·八进制 R = 8,基本符号为 0,1,2,3,4,5,6,7。
·十进制 R =10,基本符号为 0,1,2,3 ,4,5 ,6,7,8 ,9。
·十六进制 R = 16,基本符号为 0,l,2,3,4,5,6,7,8,9,A,B,C,D,E,F。
表 1.3列岀了二、八、十、十六进制 4 种进位计数制中各基本数之间的对应关系。
表 1.3 4种进位计数制数之间的对应关系

从表1.3 中可看出，十六进制的前 10 个数字与十进制中前 10 个数字相同， 后6个基本符号 A,B,C,D,E,F 的值分别为十进制的 10,11,12,13,14,15 0 在书写时可使用后缀字母标识该 数的进位计数制，一般用 B(Binaiy)表示二进制，用 0( Octal)表示八进制，用 D( Decimal) 表示十进制(十进制数的后缀可以省略)，而 H( Hexadecimal)则是十六进制数的后缀，有时 也在一个十六进制数之前用 Ox 作为前缀，例如二进制数 10011B,十进制数 56D 或 56,十六进 制数 308FH 或 0x308F 等。
计算机内部所有的信息采用二进制编码表示。但在计算机外部，为了书写和阅读的方便， 大都采用八、十或十六进制表示形式。因此，计算机在数据输入后或输出前都必须实现这些进 位制数和二进制数之间的转换。以下介绍各进位计数制之间数据的转换方法。

1.3.2.1 R 进制数转换成十进制数
任何一个 R 进制数转换成十进制数时，只要“按权展开”即可。
2.0 将二进制数(loioi.oi)2 转换成十进制数。
(10101.01)2  = (1 x24  + 0 x 23  +1 x22  + 0 x 2' +1 x2° +0x2" +1 x2 ) 10  = (21. 25) l0    2.3
将八进制数(307.6),转换成十进制数。
(307.6), = (3 x82  +7 x8° +6 x 8 ') 10  = ( 199. 75)l0
例：将十六进制数(3A.C)16 转换成十进制数。
(3A. C)16  = (3 X161  +10 xl6° +12xl6*')10  = (58. 75)1O


1.3.2.2 十进制数转换成 R 进制数
任何一个十进制数转换成 R 进制数时，要将整数和小数部分分别进行转换。
（1）整数部分的转换
整数部分的转换方法是“除基取余，上右下左”。也就是说，用要转换的十进制整数去除 以基数 A, 将得到的余数作为结果数据中各位的数字，直到余数为 0 为止。上面的余数(先得 到的余数)作为右边低位上的数位，下面的余数作为左边高位上的数位。
側凰動将十进制整数 135 分别转换成八进制数和二进制数。
O 将 135 分别除以 8 和 2,将每次的余数按从低位到高位的顺序排列如下：

所以，(135 儿=(207)8 =(10000111)2。	

（2）小数部分的转换
小数部分的转换方法是“乘基取整，上左下右”。也就是说，用要转换的十进制小数去乘 以基数 A, 将得到的乘积的整数部分作为结果数据中各位的数字，小数部分继续与基数犬相 乘。以此类推，直到某一步乘积的小数部分为 0 或已得到希望的位数为止。最后，将上面的整 数部分作为左边高位上的数位， 下面的整数部分作为右边低位上的数位。
例：将十进制小数 0. 6875 分别转换成二进制数和八进制数。
0.6875 x2 = 1.375	整数部分=1	(高位)
0. 375 x2 =0. 75	整数部分=0	↓

0.75x2 = 1.5	整数部分=1	↓
0.5x2 =1.0	整数部分=1	(低位) 所以，(0. 6875)]0=(0.1011 )2O
0.6875 x8 =5.5	整数部分=5	(髙位)
0.5x8 =4.0	整数部分=4	(低位) 所以，(0.6875)10=(0.54)8。
在转换过程中，可能乘积的小数部分总得不到。，即转换得到希望的位数后还有余数，这 种情况下得到的是近似值。
例：将十进制小数 0.63 转换成二进制数。

x2 =0.08	整数部分=0  (低位) 所以，(0.63)10=(0. 1010....)2。

（3）含整数、小数部分的数的转换
只要将整数部分和小数部分分别进行转换，得到转换后相应的整数和小数部分，然后再将 这两部分组合起来得到一个完整的数。
将十进制数 135.6875 分别转换成二进制数和八进制数。
只要将例 2.4 和例 2.5 的结果合起来就可，即
(135. 6875)10  = (10000111. 1011)2  = (207.54)8

 二、八、十六进制数的相瓦转换
八进制数转换成二进制数
八进制数转换成二进制数的方法很简单，只要把每一个八进制数字改写成等值的 3 位二进 制数即可， 且保持高低位的次序不变。八进制数字与二进制数的对应关系如下。
(0)8  =000	(1)8  =001	(2)g  =010	(3)g  =011
(4)	s=100	(5)8=101	(6)/110	(7)8=111
例：将(13.724).转换成二进制数。
(13. 724)8  = (001 011.111 010 100)2  = (1011. 1110101)2

（2）十六进制数转换成二进制数
十六进制数转换成二进制数的方法与八进制数转换成二进制数的方法类似，只要把每一个 十六进制数字改写成等值的 4 位二进制数即可，且保持高低位的次序不变。十六进制数字与二 进制数的对应关系如下。
(0)16  =0000	(1)16  =0001	(2)16  =0010	(3)16  =0011
(4),6  =0100	(5)16=0101	(6)*0110	(7)i6=0111
(8)16  = 1000	(9),6 = 1001	(A)16  = 1010	(B)16  = 1011 (C),6=1100	(D)16  = 1101	(E)16  = 1110	(F)l6=llll
例：将十六进制数(2B.5E)16 转换成二进制数。
(2B. 5E)16  = (0010 1011.0101 1110)2  = (101011.0101111)2

（3）二进制数转换成八进制数
二进制数转换成八进制数时，整数部分从低位向高位方向每 3 位用一个等值的八进制数来 替换，最后不足 3 位时在高位补 0 凑满 3 位；小数部分从高位向低位方向每 3 位用一个等值的 八进制数来替换，
最后不足 3 位时在低位补 0 凑满 3 位。例如：
(0. 10101 )2  = (000. 101 010)2 = (0. 52)8
(10011.01)2  = (010 011.010)2  = (23.2),

（4）二进制数转换成十六进制数
二进制数转换成十六进制数时，整数部分从低位向高位方向每 4 位用一个等值的十六进制 数来替换， 最后不足 4 位时在高位补 0 凑满 4 位；小数部分从高位向低位方向每 4 位用一个等 值的十六进制数来替
(11001. 11)2  = (0001 1001. 1100)2  = (19. C)16
从以上可以看出，二进制数与八进制数、二进制数与十六进制数之间有很简单直观的对应 关系。二进制数太长，书写、阅读均不方便；八进制数和十六进制数却像十进制数一样简练， 易写易记。虽然计算机中只使用二进制一种计数制，但为了在开发和调试程序、査看机器代码 时便于书写和阅读，人们经常使用八进制或十六进制来等价地表示二进制，所以大家也必须熟 练掌握八进制和十六进制数的表示及其与二进制数之间的转换。

2.整数的表示
2.1 整数的表示
整数的小数点隐含在数的最右边，故无需表示小数点，因而也被称为定点数。计算机中的整 数多用二进制表示，分为无符号整数（unsigned integer）和带符号整数（signed integer）两种。

2.1.1 无符号整数和带符号整数的表示
当一个编码的所有二进位都用来表示数值而没有符号位时，该编码表示的就是无符号整 数。此时， 默认数的符号为正，所以无符号整数就是正整数或非负整数。一般在全部是正数且不出现负值结果的场合下，使用无符号整数。例如，可用无符号整数 进行地址运算，或用来表示指针。通常把无符号整数简单地说成无符号数。由于无符号整数省略了一位符号位，所以在位数相同的情况下，它能表示的最大数比带符号整数所能表示的大，例如，8 位无符号整数的形式为 00000000 -11111111,对应的数的取值 范围为 0 ~（2'-1）,即最大数为 255,而 8 位带符号整数的最大数是 127。
带符号整数也被称为有符号整敏,它必须用一个二进位表示符号，虽然前面介绍的各种二 进制编码表示都可以用来表示带符号整数，但是补码表示有其突出的优点，现代计算机中带符 号整数都用补码表示。n 位带符号整数的表示范围为 2n+1~（2n+1-1）。例如，8 位带符号整 数的表示范围为-128~ +127。

2.1整数加减运算
在程序设计时通常把指针、地址等说明为无符号整数，因而在进行指针或地址运算时需要进行无符
整数的加减运算电路是完全一样的，它们都可以在如图 2. 1 所示的整数加减运算器中实现,图 中加法器中进行的是无符号数加运算，MUX 是一个二路选择器,有关加法器和二路选择器的 功能和结构请参看附录A。

图 2.1 位整数加减运算器
图 2.1 中，X 和 y 是两个 0/1 序列，对于带符号整数 X 和 y 来说，X 和 y 就是 x 和 y 的补码 表示， 对于无符号整数 x 和 y 来说，X 和 y 就是，和 y 的无符号数表示。不管是补码减法还是 无符号数减法，都是用被减数加上减数的负数的补码来实现。根据求补公式，减数 y 的负数的 补码[-y 补=y+1,因此，只要在加法器的*'输入端，加 n 个反向器以实现各位取反的功 能，然后加一个 2 选 I 多路选择器 MUX,用一个控制端 Sub 来控制选择将原码 r 输入到 y'端还 是将 V 各位取反后输入到 Y'端，并将控制端 Sub 同时作为低位进位送到加法器。当 Sub 为 1 时 做减法，即实现 x-y = X +Y + l；当 Sub 为。时做加法，即实现x+y = X+y。
图 2.1 给出了两个输出标志信息：零标志 ZF 和溢出标志 OF. ZF = 1 表示结果为 0,因此 当
结果(result)的所有位都为。时，使 ZF = 1,否则 ZF=0; OF = 1 表示带符号整数的加减运 算发生溢出，因为两个同号数相加其结果的符号一定同两个加数的符号，所以，当 X 和 F 的最 高位相同且不同于结果的最高位时，使 OF = 1,否则 OF=0。
通常，在整数加减运算器的输出中，除了 ZF 和 OF 以外，还有两个常用标志位：符号标志 SF 和进/ 借位标志 CF。其中，SF 表示带符号整数加减运算结果的符号位，因此，可以直接取 result 的最高位作为SF。CF 用来表示无符号数加减运算时的进/借位。加法时，若 CF = 1 表示 加法有进位；减法时，若CF = 1 表示不够减。因此，加法时 CF 就应等于进位输出 C；减法时， 应将进位输出 C 取反来作为借位标志。综合起来，可得：CF = Sub©Co
例：以下是一个 C 语言程序，用来计算一个数组 a 中每个元素的和。当参数 LEN 为 0 时，返回值应该是 0,
但是在机器上执行时，却发生了存储器访问异常。请问这是什么原因造 成的，并说明程序应该如何修改。
 fl oat sum_array(1nt a[], unsigned 1 en)
 {
	1nt 1, sum = 0;
	for( i = 0 ; 1 <= len—1; 1++)
	sum — a[1];

	return sum；
 }
当 len 为 0 时，在图 2.6 的电路中计算 len-1,此时 X 为 00000000H, Y 为 00000001H, Sub = l,因此计算出来的结果是 32 个 1。在对条件表达式“i< = len-l”进行判断时，通过做减 法得到的标志信息来进行比较。开始时 i=0,因此，在图 2.6 的电路中计算 0- FFFFFFFFH,此 时，X 为 00000000H, 丫为 FFFFFFFFH, Sub = 1,显然加法器的输出结果 result 为 00000001H,进位输 出 C=0,因此借/进位标志 CF==Sub©C=l,零标志 ZF=0,符号标志 SF=0,溢出标志 0F=0o
因为中屁是 unsigned 类型，所以对条件表达式“i<=len-l”进行判断时按照无符号数 进行比较（对应的是无符号整数比较并转移指令），即根据 CF 的取值来判断大小，当 CF=1 且 ZF= 0 时表示小于，显然，任何无符号数都比 32 个 1 小，因此循环体被不断执行，最终导 致数组访问越界而发生存储器访问异常。
正确的做法是将参数 Zen 声明为 int 型。这样，虽然加法器中的运算以及生成的所有标志信 息与 len 为无符号数时完全一样，但是，因为条件表达式“i< = len-l”中的 i 和 Zee 都是带符 号整数，因而会按照带符号整数进行比较（对应的是带符号整数比较并转移指令），即根据 OF 和 SF 的值是否相同来判断大小，当 
0 F= SF 且 ZF= 0 时表示大于。因此，当 f=0 时，Zen=0使得“i<=len-l”条件不满足，从而跳出循环执行。
无符号数加减运算在图 2. 6 所示的电路中执行，运算的结果取低 n 位，相当于取模为 2", 也即当两数相加的结果大于 2",则大于 2"的部分将被减掉。因此无符号数加法运算公式如下。

知，［-刃补二 2" -y,因此，result = % + （2n  -y） =x -y + 2n,当 x-y>0 时，2"被减掉。因此, 无符
号数减法运算公式如下

例：假设 8 位无符号整数变量，和 y 的机器数分别是 X 和匕 相应加减运算在 图 2.6 所示电路中执行。若X = A6H, y = 3FH,则，、/、x+/和 x-y 的值分别是多少？若矛= A6H, y = FFH,则 x、y、x+y 和 x-y 的值又分别是多少？（说明：这里的 x+y 和/-y 的值是 指经过运算电路处理后得到的 result 对应的值。）
若 X = A6H, y = 3FH,则 x+y 的机器数 X + 7 = 10100110 + 00111111 =11100101 = E5H, x-y 
的机器数 X-7=10100110 +11000001 =01100111 =67HO  因此，叭 y, x+y 的 result 和 x-y 的 result 分别是 166、63、229 和 103,显然运算结果符合上述公式（2.1）和（2.2）。
验证如下：因为 x+y= 166 +63 <28  =256,因而 x+y 的 result 应该等于 x + y = 166 +63 = 229；因为 x-, = 166 -63 >0,因而 x-y 的 result 应该等于 x-y- 166 -63 = 103 ,验证正确。若 X = A6H, Y=FFH,则 X + y=10100110 + llllllll =10100101 =A5H, X-y=10100110 + 00000001=1010 0111 =A7HO  因此，X、y、x +y 的 result 和 x-y 的 result 分别是 166、255、165和 167,运算结果符合上述运算公式(2.1)和(2.2)。
验证如下：因为 x+y = 166 + 255 >2'=256,因而，X+y 的 result 应该等于 x+y-28 = 166 +255-256 = 165 ；因为 x-y = 166 -255 <0,因而 x -y 的 result 应该等于 X-y+28= 166 -255 +256 = 167,验证正确。
带符号整数加法运算也在图 2. 6 所示电路中执行。如果两个 n 位加数 X 和 y 的符号相反， 则一定不会溢出，只有两个加数的符号相同时才可能发生溢出。两个加数都是正数时发生的溢 出称为正溢出；两个加数都是负数时发生的溢出称为负溢出。图 2. 6 中实现的带符号整数加法 运算公式如下：

与无符号整数减法运算类似，带符号整数减法也通过加法来实现，同样也是用被减数加上 减数的负数的补码来实现。图 2. 6 中实现的带符号整数减法运算公式如下：

例：假设 8 位带符号整数变量，和 y 的机器数分别是 X 和 Y,相应加减运算在 图 2.6 所示电路中执行。若 X = A6H, y = 3FH,则，、y、x+y 和 x-y 的值分别是多少？若 X = A6H, y=FFH,则％、>、x+y 和 x-y 的值又分别是多少？（说明：这里的 x+y 和 x-y 的值是 指经过运算电路处理后得到的 result 对应的值。）
若 X = A6H, y = 3FH,则 x+y 的机器数 X + Y= 10100110 +00111111 =11100101 = E5H, x-y 的
机器数 X-F= 10100110+ 11000001 =01100111 =67H.因为带符号整数用补码表 示，所以，X、y、x+y 的
result 和 x-y 的 result 分别是-90、63、-27 和 103,经验证，运算 结果符合上述公式（2.3）和（2.4）。验证如下：因为-2’ ≤x + y = - 90 + 63 < 27,因而 x+y 的 result 应该等于 x +y = - 90 + 63= -27；因为 X-y=-90 -63 <-27,即负溢出，因而 x-y 的 result 应该等于 x-y+2g = -90 -63 +256 =103,验证正确。
若 X=A6H, Y = FFH,则 X + 7= 10100110 + 11111111 = 10100101 = A5H, X - 7= 10100110 + 00000001
=10100111 =A7 Ho %、y、x+y 的 result 和 x-y 的 result 分别是-90、-1、-91 和 -89,经验证，运算结果符合上述运算公式（2.3）和（2.4）。
验证如下：因为-2’≤x+y = -90 + （ - 1） <2‘，因而，x+y 的 result 应该等于 x+y= -90 + （-1）
= -91；因为-2’≤x-y = -90 - （ -1） <2,,因而 x-y 的 result 应该等于 x-y= - 90 - （-1）=-89,验证正确。
例：给出的机器数 X 和 Y 完全相同，在同样的电路中计算，因而得到的和 （差） 的机器数也完全相同。对于同一个机器数，作为无符号整数解释和作为带符号整数解释时 的值不同，因而例 2. 29 和例 2. 30 中得到的和（差）的值完全不同。从这里可以看出，在电路中执行运算时所有的数都只是一个 0/1 序列，在底层机器级这个层次上，并不区分操作数是什么类 型。因而， 在一些指令集体系结构中，加法指令和减法指令并不区分是无符号整数加（减）指令 还是带符号整数的加（减）指令，例如 Intel x86 就是如此。但是，有些处理器指令系统，也会提供 专门的带符号整数加（减） 指令和专门的无符号整数加（减）指令，例如 MIPS 架构就是如此。
在 Intel x86 架构中，不管高级语言程序中定义的变量是带符号整数还是无符号整数类型， 对应的加（减）指令都一样，都是在如图 2.6 所示的电路中执行。每条加（减）指令执行以 后，总是把运算电路中结果的低 n 位（insult）送到目的寄存器，同时根据运算结果产生相应的 进/借位标志 CF、符号标志SF、溢出标志 OF 和零标志 ZF 等，并保存到标志寄存器（FLAGS/ EFLAGS）中。
在 MIPS 架构中，提供了专门的带符号整数的加（减）指令（如 add、sub 指令）和无符号 整数的加
（减）指令（如 addu、subu 指令），因而在 MIPS 处理器的运算电路中会区分是带符 号整数还是无符号整数运算。不过，它们之间的不同也仅在于是否判断和处理溢出，带符号整 数加减时会判断溢出并对溢出进行处理，而无符号整数加减时不判断溢出，对于其余部分的处 理两者完全一样。
由于在底层的机器级层次对无符号整数和带符号整数的运算不加区分，因而，在高级语言 程序执行过程中，带符号整数隐式地转换为无符号整数运算时，会出现像例 2. 21 和例 2. 28 中 那样的意想不到的错误或存在漏洞。杜绝使用无符号整数可以避免这类问题。也有一些语言为 避免这类问题，釆用不支持无符号整数的方式，例如，Java 语言就不支持无符号整数。

2.3整数乘除运算
高级语言中两个 n 位整数相乘得到的结果通常也是一个 n 位整数，也即结果只取 2n 位乘 积中的低 n 位。例如，在 C 语言中，参加运算的两个操作数的类型和结果的类型必须一致，如 果不一致则会先转换为一致的数据类型再进行计算。
根据二进制运算规则，在计算机算术中存在以下结论：假定两个几位无符号整数、和九 对应的机器数为 Xu 和 Yu，Pu=xuxyu，Pu 为 n 位无符号整数且对应的机器数为 Pu；两个 n 位 带符号整数 xS 和 xS 对应的机器数为 xs 和 Ys, Ps=xsxys, Ps 为 n 位带符号整数且对应的机器 数为 Ps。若且匕=匕，则 Pu=Pa.表 2.8 中给出了 4 位无符号整数和 4 位带符号整数 乘法的部分例子，显然这些例子符合上述结论。

表 2.1 4 位无符号整数和 4 位带符号整数乘法示例

根据上述结论，带符号整数乘法运算可以采用无符号整数乘法器实现,只要最终取 M 位 乘积中的低 n 位即可。送到无符号整数乘法器中的两个乘数 X 和 y 是两个 0/1 序列，对于带符 号整数'和，来说，X 和丫就是，和〉的补码表示，对于无符号整数％和 y 来说，X 和 y 就是 X 和，的无符号整数表示。不管在无符号整数乘法器中进行的是补码乘还是无符号数乘，在没有 溢出的情况下，最终得到的&位乘积中的低 n 位总是正确的。因此，需要能够判断是否发生 了溢出。
对于 n 位无符号整数，和 y 的乘法运算，结果只取低"位，相当于取模为 2*。若丢弃的高 n 位是非 0
数，则发生溢出。用公式表示如下，式中 P 是指取低几位乘积时对应的值。
X x y(x x y < 2n)正常 P =
x X y mod 2n  (x X y ≥ 2n) 溢出
如果无符号数乘法指令能够将高 n 位保存到一个寄存器中，则编译器可以根据该寄存器的 内容采用相应的比较指令来进行溢出判断。例如，在 MIPS 处理器中，无符号数乘法指令 multu 会将两个 32 位无符号数相乘得到的 64 位乘积置于两个 32 位内部寄存器 Hi 和 Lo 中，因此，可 以根据 Hi 寄存器是否为全。来进行溢出判断。有些指令系统中的乘法指令并不保留高 n 位， 此时可根据两个乘数*、，与结果 P=xxy 的关系来判断。判断规则为：若满足，x=0 且 p/x=y, 则没有发生溢出；否则溢出。例如，对于表 2. 8 中序号为 7 的例子，x=2, y=12, p=8,显然 8/2=12,因此，发生了溢出。
对于 n 位带符号整数乘法运算，若釆用上述所说的无符号整数乘法器实现，则得到的乘积 高几位并不一定是乘积的补码表示的高 n 位，例如，对于表 2. 8 中序号为 6 的例子，当％ = -3, /= -2 时，在无
符号整数乘法器中得到的M 位乘积的机器数为1011 0110,而不是真正 的2 儿位乘积的补码表示00000110, 因此，无法根据高 n 位为全 0 或全 1 来判断是否溢出。带 符号整数乘法运算与无符号整数乘法运算一样， 也可根据两个乘数，、y 与结果 p=xxy 的关系 来判断。判断规则为：若满足，x=0 且 P/x=y,则没有发生溢出；否则溢出。例如，对于表 2. 8 中序号 8 的例子，x=2, y= -4, p= -8,显然-8/2= -4,因此，没有发生溢出。对于序号 为 2 的例子，x=6, y = -6, p = -4,显然-4/6# -6,因此，发生了溢出。
有些处理器中会使用专门的补码乘法器来进行带符号整数乘法运算，一位补码乘法称为布 斯(Booth) 乘法,两位补码乘法称为改进的布斯乘法(Modified Booth Algorithm, MBA),也称 为基 4 布斯乘法。采用专门的补码乘法器实现带符号整数运算得到的结果是 2n 位乘积的补码 表示。例如，对于表 2. 8 中序号为 2 的例子，x=6, y= -6,若采用专门的补码乘法器，则得 到的乘积的&位机器数为 1101 1100,而不是无符号整数乘法器的结果 0011 1100；对于表 2. 8 中序号为 6 的例子，若采用专门的补码乘法器，则得到的乘积的 2n 位机器数为 0000 0110,而 不是 1011 0110o 在这种釆用专门的补码乘法运算的情况下，可以通过高 n 位和低 n 位之间的 关系来进行溢出判断。判断规则是：若高 n 位中每一位都与低 n 位的最高位相同，则不溢出； 否则溢出。例如，在 MIPS 处理器中，带符号整数乘法指令 mult 会将两个 32 位带符号整数相 乘，得到的 64 位乘积置于两个 32 位内部寄存器 Hi 和 LO 中，因此，可以根据 Hi 寄存器中的每一位是否等于 Lo 寄存器中的第一位来进行溢出判断。
通常乘法指令没有判断溢出的功能，如果程序本身不采用防止溢出的措施，而且编译器也
不生成相应的用于溢出处理的代码的话，就会发生一些由于整数溢出而带来的问题。因此，在 现实世界中的结论在计算机世界并不一定成立。例如，在 C 语言中，若 X 和 y 为 int 型, x=65 535,则 y=x*x= -131
071,，的机器数为 0000FFFFH, y 的机器数为 FFFE0001H。
例：以下程序段实现数组元素的复制，将一个具有 count 个元素的 int 型数组复制到 堆中新申请的一块内存区域中，请说明该程序段存在什么漏洞，引起该漏洞的原因是什么。
/*复制数组到堆中，count 为数组元素个数*/
Int copy_array(int *array, 1nt count) (
i nt 1 ;
/*在堆区申请一块内存*/
int *myarray = (1nt *) malloc(count*sizeof(1nt));
1f (myarray == NULL)
return -1 ；
	for (1 = 0 ; 1 < count; 1 ++)
	myarray[1] = array[1]；
	return count ；
	)
该程序段存在整数溢出漏洞，当 couni 的值很大时，第 5 行 malloc 函数的参数 count * sizeof( int) 会发生溢出，例如，在 32 位机器上实现时，sizeof ( int) = 4,若参数 count = 230  + 1 , 因为(230+1) x4=232+4(mod232) =4,因此 malloc 函数只会分配 4 个字节的空间，而在后面 的 for 循环执行时，复制到堆中的数组元素实际上有(232  +4) =4 294 967 300 个字节，远超过 4 个字节的空间，从而会破坏在堆中的其他数据，导致程序崩溃或行为异常，更可怕的是，如 果攻击者利用这种漏洞，以引起整数溢出的参数来调用函数，
通过数组复制过程把自己的程序 置入内存中并启动执行，就会造成极大的安全问题。
2002 年，Sun Microsystems 公司的 RPC XDR 库中所带的 xdr_array()函数发生整数溢出漏 洞，攻击者可以利用这个漏洞从远程或本地获取 root 权限。xdr_airay()函数中需要计算 nodesize 变量的值， 它采用的方法可能会由于乘积太大而导致整数溢出，使得攻击者可以构造一个特殊 的参数来触发整数溢出，以一段事先预设好的信息覆盖一个已经分配的堆缓冲区，造成远程服 务崩溃或者改变内存数据并执行任意代码。由于很多厂商的操作系统都使用了 Sun 公司的 XDR 库或者基于 XDR 库进行开发，因此很多厂商的程序也受到此问题影响。
对于整数除法,因为商的绝对值不可能比被除数的绝对值更大，因而肯定不会发生溢出， 也就不会像整数乘法运算那样发生漏洞。但是，在不能整除时需要进行舍入，通常按照朝 0 方 向舍入，即正数商取比自身小的最接近整数，负数商取比自身大的最接近整数。除数不能为 0,否则会发生“异常”，需要调出操作系统中的异常处理程序来处理。

2.4 变量与常数之间的乘除运算 
由于整数乘法运算比移位和加法等运算所用时间长得多，通常一次乘法运算需要 10 个左 右的时钟周期，而一次移位、加法和减法等运算只要一个或更少的时钟周期，因此，编译器在 处理变量与常数相乘时， 往往以移位、加法和减法的组合运算来代替乘法运算。例如，对于表 达式 8*20,编译器可以利用 20 = 16+4
=2,+2、将 X * 20 转换为(x<<4) +(X<<2),这 样，一次乘法转换成了两次移位和一次加法。不管是无符号整数还是带符号整数的乘法，即使乘积溢出时，利用移位和加减运算组合的方式得到的结果都和釆用直接相乘的结果是一样的。
对于整数除法运算，由于计算机中除法运算比较复杂，而且不能用流水线方式实现，所以 一次除法运算大致需要 30 个或更多时钟周期。为了缩短除法运算的时间，编译器在处理一个 变量与一个 2 的皋次形式的整数相除时，常采用右移运算来实现。无符号整数除法釆用逻辑右 移方式，带符号整数除法采用算术右移方式。两个整数相除，结果也一定是整数，在不能整除 时，其商釆用朝 0 方向舍入的方式，也就是截断方式，即将小数点后的数直接去掉，例如，7/ 3 =2, -7/3 = -2。
对于无符号整数来说，釆用逻辑右移时，高位补 0,低位移出，因此，移位后得到的商的 值只可能变小而不会变大，即商朝。方向舍入。因此，不管是否能够整除，釆用移位方式和直 接相除得到的商完全一样，如表 2.9 给出的例子所示。表 2.2 中给出了无符号整数 32 760 除以 2*（A 为正整数）的例子，无
符号整数 32 760 的机器数为 0111 1111 1111 1000。
表 2.2 无符号整数 32 760 除以 2*的示例

对于带符号整数来说，釆用算术右移时，高位补符号，低位移出。因此，当符号为 0 时, 与无符号整数相同，釆用移位方式和直接相除得到的商完全一样。当符号为 1 时，若低位移出 的是全 0,则说明能够整除，移位后得到的商与直接相除的完全一样；若低位移出的并非全 0, 则说明不能整除，移出一个非 0 数相当于把商中小数点后面的值舍去。因为符号是 1,所以商 是负数，一个补码表示的负数舍去小数部分的值后变得更小，因此移位后的结果是更小的负数 商。例如，对于-3/2,假定补码位数为 4,则进行算术右移操作 1101 »1 =1110. 1B（小数点 后面部分移出）后得到的商为-2,而精确商是-1.5（整数商应为-1）。算术右移后得到的商 比精确商少了 0.5,显然朝-8 方向进行了舍入，而不是朝 0 方向舍入。因此，这种情况下， 移位得到的商与直接相除得到的商不一样，需要进行校正。校正的方法是，对于带符号整数，, 若x<0,则在右移前，先将，加上偏移量（2*-1）,然后再右移 K 位。例如，上述例子中，在 对-3 右移 1 位之前，先将-3 加上 1,即先得到 1101 +0001 =1110,然后再算术右移，即 1110>>1 =1111,此时商为-1。表 2.3 给出了带符号整数-32760 除以 2*（K 为正整数）的例子，带符号整数-32760 的 补码表示为 1000 0000 0000 1000。
表 2.3 带符号整数-32 760 除以 2*的示例

从表 2.3 可以看出，对带符号整数-32 760 先加一个偏移量后再进行算术右移，避免了 商朝-8 方
向舍人的问题。例如，对于表中 k=6 的情况，若不进行偏移校正，则算术右移 6 位后商的补码表示为 111111 1000 0000 00,即商为-512,而校正后得到的商等于-32 760/64 的整数商-511。

3. 浮点数的表示
3.1IEEE 754 浮点数标准
直到 20 世纪 80 年代初，浮点数表示格式还没有统一标准，不同厂商的计算机内部，其 浮点数表示格式不同，在不同结构的计算机之间进行数据传送或程序移植时，必须进行数 据格式的转换，而且，数据格式转换还会带来运算结果的不一致。因而，20 世纪 70 年代后 期，IEEE 成立委员会着手制定浮点数标准，1985 年完成了浮点数标准 IEEE 754 的制定。其 主要起草者是加州大学伯克利分校数学系教授 William Kahan，他帮助 Intel 公司设计了 8087 浮点处理器(FPU),并以此为基础形成了 IEEE 754 标准，Kahan 教授也因此获得了 1987 年 的图灵奖。
目前几乎所有计算机都采用 IEEE 754 标准表示浮点数。在这个标准中，提供了两种基本 浮点
格式：32 位单精度格式和 64 位双精度格式，如图 2. 3 所示.

图 3.1 IEEE 754 浮点数格式

32 位单精度格式中包含 1 位符号 s、8 位阶码 e 和 23 位尾数 f； 64 位双精度格式包含 1 位 符号 s、
11 位阶码 e 和 52 位尾数人 其基数隐含为 2；尾数用原码表示，规格化尾数第一位总为 1,因而可在尾数中缺省第一位的 1,该缺省位称为隐藏位，隐藏一位后使得单精度格式的 23 位尾数实际上表示了 24 位有效数字，双精度格式的 52 位尾数实际上表示了 53 位有效数字。 IEEE 754 规定隐藏位“1”的位置在小数点之前。
IEEE 754 标准中，阶码用移码形式，偏置常数并不是通常 n 位移码所用的 2n-1,而是（2n-1-1）,因此，单精度和双精度浮点数的偏置常数分别为 127 和 1023。IEEE 754 的这种 “尾数带一个隐藏位，偏置常数用（2n-1-1）”的做法，不仅没有改变传统做法的计算结果, 而且带来以下两个好处：尾数可表示的位数多一位，因而使浮点数的精度更高。阶码的可表示范围更大，因而使浮点数范围更大。对于 IEEE 754 标准格式的数，一些特殊的位序列（如阶码为全 0 或全 1）有其特别的解释。

表3.1 IEEE 754 浮点数的解释

在表 3.1 中，对 IEEE 754 中规定的数进行了以下分类：
（1）全 0 阶码全 0 尾数：+0/-0
IEEE 754 的零有两种表示：+0 和-0。零的符号取决于符号 s。一般情况下+0 和-0 是 等效的。
（2）全 0 阶码非 0 尾数：非规格化数
非规格化数的特点是阶码为全 0,尾数高位有一个或几个连续的 0,但不全为 0。因此非规 格化数的隐藏位为 0,并且单精度和双精度浮点数的阶分别为-126 或-1022,故浮点数的值 分别为（-1）x0./x2-126 和（-1）1X0.FX2-1022
非规格化数可用于处理阶码下溢，使得出现比最小规格化数还小的数时程序也能继续进行 下去。当运算结果的阶太小（比最小能表示的阶还小，即小于-126 或小于-1022）时，尾数 右移 1 次，阶码加 1, 如此循环直到尾数为 0 或阶达到可表示的最小值（-126 或- 1022）。 这个过程称为“逐级下溢”。因此，“逐级下溢”的结果就是使尾数变为非规格化形式，阶 变为最小负数。例如，当一个十进制运算系统的最小阶为-99 时，以下情况需进行阶的逐 级下溢。
20000 x 1026  x 5.2000 x 1084  = 1.04 x 1O-98→0.1040 x 10 108  →0.0104 x 10l07 …….	0.0
20002 x 10-98-2.0000 x 10-98=2 0000 x 10-98→0.2000 x 1O-101→0.0200 x 1000→0.0020 x 10-99  
表示了加入非规格化数前、后 IEEE 754 的表数范围的变化。图中将可表示数以 ［2n+1, 2n+1］的区间分组。区间［2n, 2n+1］内所有数的阶相同，都为 n，而尾数部分的变化范 围为这里小数点前的 1 是隐藏的隐含位。对于 32 位单精度规格化数，因 为尾数的位数有 23 位，故每个区间内的数的个数相同，都是 2 谷个。例如，在正数范围内最左 边的区间为［2-126，2-125］,在该区间内，最小规格化数为 1.00...0、2-126，最大规格化数为 1.11-1X2-126  在该区间中的各个相邻数之间具有等距性，其距离为 2-23x2-126，该区间右边 相邻的区间为［2-125, 2-124］,区间内各相邻数间的距离为 2-23x2-125 由此可见，每个右边 区间内相邻数间的距离总比左边一个区间的相邻数距离大一倍，因此越离原点近的区间内的数 的间隙越小。图 2.4a 给出了未定义非规格化数时的情况，在图中可看出，在 0 和最小规格化 数 2-126 之间有一个间隙未被利用。图 2. 4b给出了定义非规格化数后的情况，非规格化数就是 在 0 和 2-126 之间增加的 2-26 个附加数，这些相邻附加数之间与区间［2-126，2-125］内的相邻数 等距，所有非规格化数具有与区间［2-126，2-125］内的数相同的阶，即最小阶（-126）。尾数 部分的变化范围为 0.00…0~0. 这里的隐含位为 0,这也是非规格化数的重要标志 之一。


图 3.2 IEEE 754 中加入非规格化数前、后表数范围的变化
(3)全 1 阶码全 0 尾数：+8/-8
引入无穷大数使得在计算过程出现异常的情况下程序能继续进行下去，并且可为程序提供 错误检测功能。+8 在数值上大于所有有限数，-8 则小于所有有限数，无穷大数既可能是操 作数，也可能是运算的结果。当操作数为无穷大时，系统可以有两种处理方式。
产生不发信号的非数 NaN。如+ 8+ (- 8)、+8 - (+ 8)、8/8 等。
产生明确的结果。如 5+(+8)= +8、(+8)+(+8)= +8、5-(+8)= -8、 (-8)-(+8)= -8 等。
(4)全 1 阶码非 0 尾数：NaN
NaN (Not a Number)表示一个没有定义的数，称为非数。分为不发信号(quiet)和发信号 (signaling)
两种非数。有的书中把它们分别称为“静止的 NaN”和“通知的 NaN”。表 2. 3 给出了能产生不发信号(静止的)NaN 的计算操作。
引入 NaN 的目的是为了检测非初始化值的使 用。程序员或编译程序可用非数表示每个浮点数 变量的非初始化值。引入 NaN 还可以使计算出现 异常时程序能继续进行下去，让程序员将测试或 判断延迟到方便的时候进行。可用尾数取值的不 同来区分是“不发信号NaN”还是“发信号 NaN”。当最高有效位为 1 时，为不发信号(静止 的)NaN,当结果产生这种非数时，不发异常操 作通知，即不进行异常处理；当最高有效位为0时为发信号(通知的)NaN,当结果产生这种非数时，则发一个异常操作通知，表示要进行异常 处理。因为NaN 的尾数是非 0 数，除了第一位有定义外其余的位没有定义，所以可用其余位来指 定具体的异常条件。一些没有数学解释的计算(如 0/0, 0X8 等)会产生一个非数 NaN。

表 3.2 产生不发信号 NaN 的计算操作

(5)阶码非全 0 且非全 1：非规格化数
对于阶码范围在 1 ~254(单精度)和 1~2046(双精度)的数，是一个正常的规格化非 0 数。根据 IEEE 754 的定义，这种数的阶的范围应该是-126 - + 127(单精度)和-1022 ~ + 1023(双精度)，其值的计算公式分别为：
(-1)sx l./x 2"-127  和(-1)' x l.fx2'1023

例：将十进制数-0.75 转换为 IEEE 754 的单精度浮点数格式表示。
(-0.75)10 = (-0.11)2=(-1.l)2x2-1 =(-l),xl./x2e-127m,所以 s = l, /=0.100-0, e = (127-1)10= (126)10= (0111 1110)2,表示为单精度浮点数格式为 1 0111 1110 1000 0000 ••- 0000 000,用十六进制表示为 BF400000H。

例：求 IEEE 754 单精度浮点数 C0A00000H 的值是多少。
求一个机器数的真值，就是将该数转换为十进制数。首先将 COAOOOOOH 展开为一个 32 位单精度浮点数： 1 10000001 010 0000-0000。据 IEEE 754 单精度浮点数格式可知，符号 S = 1,F=(O.01)2 = (0.25)10,阶码e = ( 10000001 )2  = ( 129)10)所以，其值为(-1 ) x l./x2e127  =（-1）' xl.25 x2,29-127  = - 1.25 x22  = -5.0。IEEE 754 标准的单精度和双精度浮点数格式的特征参数见表 3.3。
表 3.3 IEEE 754 浮点数格式参数

IEEE 754 用全 0 阶码和全 1 阶码表示一些特殊值，如 0、8 和 NaN,因此，除去全 0 和全 1 阶码后，单精度和双精度格式的阶码个数分别为 254 和 2046,最大阶的值也相应地变为 127 和 1023 o 单精度规格化数的个数为 254 x223  =1.98 x 231，双精度规格化数的个数为 2046 x 252  = 1.99x263。根据单精度和双精度格式的最大阶分别为 127 和 1023,可以得出数的量级范围分别 为 10 38  -10，"和 10 308  ~ 10-308。 IEEE 754 除了对上述单精度和双精度浮点数格式进行了具体的规定以外，还对单精度扩展 和双精度扩展两种格式的最小长度和最小精度进行了规定。例如，IEEE 754 规定，双精度扩展 格式必须至少具有64 位有效数字，并总共占用至少 79 位，但没有规定其具体的格式，处理器 厂商可以选择符合该规定的格式。
例如，SPARC 和 PowerPC 处理器中釆用 128 位扩展双精度浮点数格式，包含 1 位符号位 s、 15 位阶码 e（偏置常数为 16383）和 112 位尾数釆用隐藏位，所以有效位数为 113 位。
又如，Intel 及其兼容的 FPU 采用 80 位双精度扩展格式，包含 4 个字段：1 位符号位 s、15 位阶码e（偏置常数为 16 383）、1 位显式首位有效位（explicit leading significant bit） j 和 63 位尾 数f.［ntel 采用的这种扩展浮点数格式与 IEEE 754 规定的单精度和双精度浮点数格式的一个重 要的区别是，它没有隐藏位，有效位数共 64 位。

3.2 IEEE 754 浮点数精度
计算机中的浮点数运算比较复杂，从浮点数的表示来说，有规格化浮点数和非规格化浮点 数，有+8、
-8 和非数（NaN）等特殊数据的表示。利用这些特殊表示，程序可以实现诸如 + 8+ （— 8）、+8—（+8）、
8/8、8. 0/0 等运算.
此外，由于浮点加减运算中需要对阶并最终进行舍入，因而可能导致“大数吃小数”的 问题，使得浮点数运算不能满足加法结合律和乘法结合律。
例如，在 x 和 y 是单精度浮点类型时，-1.5X1030, r  = 1.5xl030, z = 1.0,则

根据上述计算可知，(x+y) +z=t + (y+z),其原因是，当一个“大数”和一个“小数” 相加时，因为对阶使得“小数”尾数中的有效数字右移后被丢弃，从而使“小数”变为 0。
例如，在 x 和 y 是单精度浮点类型时，当*=> = 1.0x10”, z = 1.0 xl0-30,则： (x x y) xz = (1.0 x1030  x 1.0 x I030) x 1.0 x IO-30  = + 8x x (y x z) = 1.0 x 1030  x (1.0 x IO30  x 1.0 x10-30) = 1.0 x 1030
显然，(xxy) xz=xx(yxz),这主要是两个大数相乘后可能超出可表示范围造成的。
1991 年 2 月 25 日,海湾战争中，美国在沙特阿拉伯达摩地区设置的爱国者导弹拦截伊拉 克的飞毛腿导弹失败，致使飞毛腿导弹击中了沙特阿拉伯载赫蓝的一个美军军营，杀死了美国 陆军第十四军需分队的 28 名士兵。这是由爱国者导弹系统时钟内的一个软件错误造成的，引 起这个软件错误的原因是浮点数的精度问题。爱国者导弹系统中有一个内置时钟，用计数器实 现，每隔 0. 1 秒计数一次。程序用 0. 1
的一个 24 位定点二进制小数，来乘以计数值作为以秒为 单位的时间。0. 1 的二进制表示是一个无限循环
序列：0.00011 [0011]-, x=0.000 1100 1100 1100 1100 1100B。显然，x 只是 0. 1 的近似表示，
0. 1 -x =0.000 1100 1100 1100 1100 1100 [1100] 0.000 1100 1100 1100 1100 1100B,即误差值
为：
0. 000 0000 0000 0000 0000 0000 1100[1100]--B = X 0. 1 =9. 54 * 10”
在爱国者导弹准备拦截飞毛腿导弹之前，已经连续工作了 100 小时，相当于计数了 100 X 60 x 60x10
= 36x105 次，因而导弹的时钟已经偏差了 9.54x10“ x36xl05=0. 343 秒。爱国者导弹根据飞毛腿导弹的速度乘以它被侦测到的时间来预测位置，飞毛腿导弹的速度 大约为2000 米/秒，因此，由于系统时钟误差导致的距离误差相当于 0.343 x2000=687 米。因 此，由于时钟误差，纵使雷达系统侦察到飞毛腿导弹并且预计了它的弹道，爱国者导弹却找不 到实际上来袭的飞毛腿导弹。这种情况下，起初的目标发现被视为一次假警报，侦测到的目标 也在系统中被删除。
实际上，以色列方面已经发现了这个问题并于 1991 年 2 月 11 日知会了美国陆军及爱国者 计划办公室(软件制造商)。以色列方面建议重新启动爱国者系统的电脑作为暂时解决方案， 可是美国陆军方面却不知道每次需要间隔多少时间重新启动系统一次。1991 年 2 月 16 日，制 造商向美国陆军提供了更新软件，但这个软件最终却在飞毛腿导弹击中军营后的一天才运抵 部队。
例：对于上述爱国者导弹拦截飞毛腿导弹的例子，回答下列问题。
如果用精度更高一点的 24 位定点小数 x =0.000 1100 1100 1100 1100 1101B 来表示 0. 1, 则
0. 1 与 x 的偏差是多少？系统运行 100 小时后的时钟偏差是多少？在飞毛腿导弹速度为 2000 米/秒的情况下，预测的距离偏差为多少？
假定用一个类型为 float 的变量 x 来表示 0. 1,则变量，在机器中的机器数是什么(要求 写成十
六进制形式)？ o. 1 与攵的偏差是多少？系统运行 100 小时后的时钟偏差是多少？在飞毛 腿导弹速度为2000 米/秒的情况下，预测的距离偏差为多少？
如果将 0. 1 用 32 位二进制定点小数 x =0.000 1100 1100 1100 1100 1100 1100 1101 B
表 示，则其误差比用 32 位 float 表示的误差更大还是更小？试分析这两种方案的优缺点。
0. 1 与 x 的偏差计算如下：
| 0. 000 1100 1100 1100 1100 1100[1100]--- - 0. 000 1100 1100 1100 1100 1101B I
=0.000 0000 0000 0000 0000 0000 00 1100[1100]—B =2-22x0. 1 = 2. 38 x 10-8
100 小时后的时钟偏差是 2.38 x 10-8 X 36 x 105 =0, 086 秒。预测的距离偏差为 0. 086 x 2000^171
米。比爱国者导弹系统精确约 4 倍。0. 1 =0.0 0011 [0011 ] B = + 1. 1 0011 0011 0011 0011 0011 00B x2-4，float 类型采用 IEEE 754 单精度浮点数格式。符号位 s 为 0,阶码 e = 127-4=0111 1011B,尾数的小数部分为 0. 1001100 1100 1100 1100 1100,因此，在机器中 float 型变量 x 表示为 0 011 1101 1 100 1100 1100 11001100 1100,用十六进制形式表示为 3DCCCCCCH。由于 float 类型的精度有限，只有 24 位有效位数，尾数从最前面的 1 开始一共只能表示 24 位，后面的有效数字全部被截断，故 x 与 0. 1 之间的误差为：|x-0. 1 | = 0. 000 0000 0000 0000 0000 00000000 1100[1100]..B 这个值等于 2-24x0. 1,大约为 5. 96x10-9。100 小时后 的时钟偏差是 5. 96 x 10"x36 x 10s  =0, 0215 秒。预测的距离偏差仅为 0. 0215 x 2000 =43 米。 比爱国者导弹系统精确约16倍。
当 x=0.000 1100 1100 1100 1100 1100 1100 1101 B 时，与 0. 1 之间的误差为：| x-
0. 1 | =0. 000 0000 0000 0000 0000 0000 0000 0000 00 1100[ 1100] --Bo 这个值等于 2 30  x0.
1, 大约为 9.31X10-11。100 小时后的时钟偏差是 9.31 X 10 5 x 36 x 10、^0. 000 335 秒。预测的距 离
偏差仅为 0.000 335 x2000 =0.67 米。比爱国者导弹系统精确约 1024 倍。
从上述结果可以看出，如果爱国者导弹系统中的 0.1 采用 32 位二进制定点小数表示，那 么将比
釆用 32 位 IEEE 754 浮点数标准（float）精度更髙，精确度大约高 26  =64 倍。而且，采 用 float 表示在计算速度上也会有很大影响，因为必须先把计数值转换为 IEEE 754 格式浮点数， 然后再对两个 IEEE 754 格式的数进行相乘，显然比直接将两个二进制数相乘要慢得多。
从上面这个例子可以看出，程序员在编写程序时，必须对底层机器级数据的表示和运算有 深刻的理解，而且在计算机世界里，经常是“差之毫厘，失之千里”，需要细心再细心，精确 再精确。同时，也不能遇到小数就用浮点数表示，有些情况下，例如需要将一个整数变量乘以 一个确定的小数常量时，可以先用一个确定的定点整数与整数变量相乘，然后再通过移位运算 来确定小数点。

3.3浮点数加减运算
先看一个十进制数加法运算的例子：0.123x10、+0.456 X10,显然，不可以把 0.123 和 0.456 直接相加，必须把阶调整为相等后才可实现两数相加。其计算过程如下。
0. 123 x 105  + 0. 456 x 102  = 0. 123 x 105  + 0. 000 456 x 105
=(0. 123 + 0.000 456) x 105
=0. 123 456 x 105
从上面的例子不难理解实现浮点数加减法的运算规则。
设两个规格化浮点数，和 y 表示为 x = M  x 2Ex, x y = M  x 2Ey  , M  M 分别是浮点数 x 和 y 的尾数，Mx  、My 分别是浮点数 x 和 y 的阶，不失一般性，设 Mx  ≤My 那么
x + y = (M x 2Ex-Ey  + M ) x 2Ey x - y = (M x 2Ex-Ey  + M ) x 2Ey
计算机中实现上述计算过程需要经过对阶、尾数加减、规格化和舍入 4 个步骤，此外，还 必须考虑溢出判断和溢出处理问题。
（1）对阶
对阶的目的是使两数的阶相等，以便尾数可以相加减。对阶的原则是：小阶向大阶看齐， 阶小的那个数的尾数右移，右移的位数等于两个阶的差的绝对值。通用计算机多采用 IEEE 754 标准来表示浮点数， 因此，阶小的那个数的尾数右移时按原码小数方式右移，符号位不参加移 位，数值位要将隐含的一位“1” 右移到小数部分，前面空出的位补 0。为了保证运算的精度， 尾数右移时，低位移出的位不要丢掉，应保留并参加尾数部分的运算。
（2）尾数加减
对阶后两个浮点数的阶相等，此时，可以把对阶后的尾数相加减。因为 IEEE 754 釆用定 点原码小数表示尾数，所以，尾数加减实际上是定点原码小数的加减运算。在进行尾数加减 时，必须把隐藏位还原到尾数部分，对阶过程中尾数右移时保留的附加位也要参加运算。
（3）尾数规格化
IEEE 754 的规格化尾数形式为：±1.xx....x。在进行尾数相加减后可能会得到各种形式的 结果， 例如：
1.xx...x+1. xx...x = ±1x.xx…x 1.xx...x-1. xx...x = ±0. 00...01x…x
对于上述结果为±1xx•••x 的情况，需要进行如下絶操作：尾数右移一位，阶码加 1。最后一位移岀时，要考虑舍入。
对于上述结果为±0.00-01x...xF 的情况，需要进行如下左规操作：数值位逐次左移， 阶码逐次减 1,直到将第一位“1”移到小数点左边。尾数左移时数值部分最左 k 个 0 被移 出，因此，相对来说， 小数点右移了 A 位。因为进行尾数相加时，默认的小数点位置在第一 个数值位（即隐藏位）之后，所以小数点右移 K 位后被移到了第一位 1 后面，这个 1 就是隐 藏位。
（4）尾数的舍入处理
在对阶和尾数右规时，可能会对尾数进行右移，为保证运算精度，一般将低位移出的位保 留下来， 并让其参与中间过程的运算，最后再将运算结果进行舍入，以还原表示成 IEEE 754 格式。这里要解决以下两个问题。
保留多少附加位才能保证运算的精度？ 最终如何对保留的附加位进行舍入？
对于第①个问题，可能无法给出一个准确的答案。但是不管怎么说，保留附加位应该可 以得到比不保留附加位更高的精度。IEEE 754 标准规定，所有浮点数运算的中间结果右边都必 须至少保留两位附加位。这两位附加位中，紧跟在浮点数尾数右边那一位为保护位或警戒位 （guard）,用以保护尾数右移的位，紧跟保护位右边的是舍入位（round）,左规时可以根据其 值进行舍入。在 IEEE 754 标准中，为了更进一步提高计算精度，在保护位和舍入位后面还引 入了额外的一个数位，称为粘位（sticky） o 只要舍入位的右边有任何非 0 数字，粘位就被置 1; 否则，粘位被置为 0。
对于第②个问题，IEEE 754 提供了 4 种可选模式：就近舍入（中间值舍入到偶数）、朝 + 8 方向舍入、朝-8 方向舍入、朝 0 方向舍入。就近舍入到偶数。舍入为最近可表示的数，当结果是两个可表示数的非中间值时，实 际上是“0 舍 1 入”方式。当结果正好在两个可表示数中间时，根据“就近舍入”的 原则无法操作。IEEE 754 标准规定：这种情况下结果强迫为偶数。实现过程为：若舍 入后结果的 LSB 为 1 （即奇数）， 则末位加 1;否则舍入后的结果不变。这样，就保证 了结果的 LSB 总是。（即偶数）。使用粘位可以减少运算结果正好在两个可表示数中间的情况。不失一般性，我们 用一个十进制数计算的例子来说明这样做的好处。假设计算 1-24 x 104  + 5.03 x 104  （精度保留两位小数），若只使用保护位和舍入位而不使用粘位，则结果为 1-2400X104 + 0. 0050 x 104 = 1. 2450x 104。这个结果位于两个相邻可表示数 1.24 xlO4 和 1. 25 x 104 的中间，釆用就近舍入到偶数，则结果应该为 1.24x104；若同时使用保护位、舍入位 和粘位，则结果为 1.24000 x104+0.00503 x104=1.24503 x104。这个结果就不在 1.24 X 104 和 1.25x104 的中间，而更接近于 1.25 xlO4,采用就近舍入方式，结果 应该为 1.25x10'。显然，后者更精确。朝+ 8 方向舍入。总是取数轴上右边最近可表示数，也称为正向舍入或朝上舍入。 •朝-8 方向舍入。总是取数轴上左边最近可表示数，也称为负向舍入或朝下舍入。朝 0 方向舍入。直接截取所需位数，丢弃后面所有位，也称为截取、截断或恒舍法。 这种舍入处理最简单。对正数或负数来说，都是取数轴上更靠近原点的那个可表示数, 是一种趋向原点的舍入， 因此，又称为趋向 0 舍入。
表 3.4 以十进制小数为例给出了若干示例，以说明这 4 种舍入方式，表中假定结果保留 小数点后面三位数，最后两位（加黑的数字）为附加位，需要舍去。

表 3.4 以十进制小数为例对 4 种舍入方式举例

（5）阶码溢出判断
在进行尾数规格化和尾数舍入时，可能会对结果的阶码执行加、减运算。因此，必须考 虑结果的阶码溢出问题。若结果的阶码为全 1,也即，结果的阶比最大允许值 127 （单精 度）或 1023（双精度）还大， 则发生“阶码上溢”,产生“阶码上溢”异常，也有的机器把 结果置为“+8”（符号位为。时）或“-8”
（符号位为 1 时），而不产生“溢出”异常。 若结果的阶码为全 0,也即，结果的阶比最小允许值（-126 或- 1022）还小，则发生“阶 码下溢”,此时，一般把结果置为“+0”（符号位为 0 时）或“-0”（符号位为 1 时），也 有的机器引起“阶码下溢”异常。从浮点数加、减运算过程可以看出，浮点数的溢出并不以尾数溢出来判断，尾数溢出可以通过右规操作得到纠正。因此结果是否溢出通过判断阶 是否上溢来确定。

3.4浮点数乘除运算
对于浮点数的乘除运算，在进行运算前首先应对参加运算的操作数进行判 0 处理、规格化 操作和溢出判断，并确定参加运算的两个操作数是正常的规格化浮点数。
浮点数乘除运算步骤类似于浮点数加减运算步骤，两者主要区别是，加减运算需要对阶， 而对乘除运算来说则无需这一步。两者对结果的后处理步骤一样，都包括规格化、舍入和阶码 溢出处理。
已知两个浮点数 x = M  x2Ey, y =M x2%则乘、除运算的结果如下。
x xy = (M  x 2Ey) x(M  x 2Ey)=(M +/M ) x 2Ey-Ey x / y = (M  x 2Ey) /(M x 2Ey)=(M +/M ) x 2Ey-Ey

4.C 语言中的数据
4.1C语言中的整数及其相互转换
C 语言中支持多种整数类型。无符号整数在 C 语言中对应 unsigned short 、unsigned int
（unsigned）, unsigned long 等类型，通常在常数的后面加一个“u”或“U”来表示，例如， 12345U,
0x2B3Cu 等；带符号整数在 C 语言中对应 short、int、long 等类型。
C 语言标准规定了每种数据类型的最小取值范围，例如，int 类型至少应为 16 位，取值范 围为-32 768
~ 32 767。通常，short 类型总是 16 位；int 类型在 32 位和 64 位机器中都为 32 位； long 类型在 32 位机器中为 32 位，在 64 位机器中为 64 位；long long 类型是在 ISO C99 中引入 的，规定它必须是 64 位。

 小贴士
C 语言是由贝尔实验室的 Dennis M. Ritchie 最早设计并实现的。为了使 UNIX 操作系 统得以推广，1977 年 Dennis M. Ritchie 发表了不依赖于具体机器的 C 语言编译文本《可移 植的 C 语言编译程序》。1978 年 Brian W. Kemighian 和 Dennis M. Ritchie 合著出版了《The C Programming
Language）,从而使 C 语言成为目前世界上流行最广泛的高级程序设计语言 之一.
1988 年，随着微型计算机的日益普及，出现了许多 C 语言版本。由于没有统一的标 准，使得这些 C 语言之间出现了一些不一致的地方。为了改变这种情况，美国国家标准学 会（ANSI）为 C 语言制定了一套 ANSI 标准，对最初贝尔实验室的 C 语言做了重大修改。Brian W. Kemighan 和 Dennis M. Ritchie 编写的《The C Programming Language》第 2 版对 ANSI C 做了全面的描述，该书被公认为是关于 C 语言的最好的参考手册之一。
国际标准化组织（ISO）接管了对 C 语言标准化的工作，在 1990 年推出了几乎和 ANSI C — 样的版本，称为“ISOC90”。该组织 1999 年又对 C 语言做了一些更新，成为“ISO C99”，该版本引进了一些新的教据类型，对英语以外的字符串本文提供了支持。
C 语言中允许无符号整数和带符号整数之间的转换，转换前、后的机器数不变，只是转换 前、后对其的解释发生了变化。转换后数的真值是将原二进制机器数按转换后的数据类型重新 解释得到。例如，对于以 1 开头的一个机器数，如果转换前是带符号整数类型，则其值为负整 数，若将其转换为无符号数类型， 则它被解释为一个无符号数，因而其值变成了一个大于等于 2n+1 的正整数。也就是说，转换前的一个负整数，很可能转换后变成了一个值很大的正整数。由于上述原因，程序在某些情况下会发生意想不到的结果。例如，考虑以下 C 代码：
Int x = -1 ；
unsigned u = 2147483648;
prlntf （"x = %u = %d\n", x, x）;
prlntf （"u = %u = %d\n", u, u）;
上述 c 代码中，，为带符号整数，U 为无符号整数，初值为 2 147 483 648 （即 231）。函数 printf用来输出数值，格式符％u、％d 分别用来以无符号整数和带符号整数的形式输出十进制 数的值。当在一个 32 位机器上运行上述代码时，它的输出结果如下。

X = 4294967295 = -1
U = 2147483648 = -2147483648

输出结果说明如下：因为-1 的补码表示为所以当作为 32 位无符号数来解释 （格式符为％u）时，其值为 232-1 =4 294 967 296 -1 =4 294 967 295。
U 的输出结果说明如下：231 的无符号数表示为 100-0,当这个数被解释为 32 位带符号整 数（格式符为％
D)时，其值为最小负数-231-1=-231= -2 147483648（参见前面例 2.12）。
在 C 语言中，如果执行一个运算时同时有无符号数和带符号整数参加，那么，C 编译器会 隐含地将带符号整数强制类型转换为无符号数，因而会带来一些意想不到的结果。
例：在有些 32 位系统上，C 表达式“ -2147483648 <2147483647”的执行结果为 false,与事实不
符；但如果定义一个变量“int i = -2147483648；”，表达式“i <2147483647” 的执行结果却为 true。试分析产生上述结果的原因。如果将表达式写成“ -2147483647 - 1 < 2147483647",则结果会怎样呢？
题目中遇到的问题在 ISO C90 标准下就会出现。在该标准下，编译器在处理常量时，会按 int32_t（int 型、long 
型）、uint32_t（unsigned int、unsigned long）、int64_t（long long）、uint64_t（unsigned long long）的顺序确定数据类型。也即，在 0 ~ 2" - 1 之间的常量为 32 位带符号整 型，在 231  ~232  - 1之间为 32 位无符号整型，在 232  ~ 263  - 1 之间的为 64 位带符号整型，在 263  ~264  - 1 之间的为 64 位无符号整型。
编译器对于比较运算（如“〈”）釆用以下规则进行：若两个操作数中至少有一个为无符 号整型，则采用无符号数比较，只有当两个操作数均为带符号整型时才采用带符号整数比较。
编译器对 C 表达式“-2147483648 <2147483647”编译时，将“-2147483648”的表示分 为两个
部分来处理。对于 ISOC90 标准，首先将 2 147 483 648 =231 看成无符号整型，其机器数 为 0x80000000,然后，对其取负（搜位取反，末位加 1）,结果仍为 0x80000000,还是将其看 成一个无符号整型，其值仍为 2 147 483648。因而在处理条件表达式 2147483648 < 2147483647”时，实际上是将 2 147 483 648 与 2 147 483 647
进行比较，显然结果为 false。在计 算机内部处理时，真正进行的是对机器数 0x80000000 和 0X7FFFFFFF 做减法，然后按照无符号 整型来比较其大小。
编译器在处理“int i= -2147483648；”时进行了类型转换，将 2147 483 648 转换为带符号 整
数后赋给变量 i,其机器数还是 0x80000000,但是值为-2 147 483 648,执行“i < 2147483647"时，按照带符号整型来比较，结果是 true。在计算机内部，实际上是对机器数 0x80000000 和 0x7FFFFFFF 按照带符号整型进行比较。
对于“-2147483647 -1 <2147483647”，编译器首先将 2 147 483 647 = 2，' - 1 (机器数为 Ox7FFFFFFF)
看成带符号整型，然后对其取负，得到-2 147 483 647(机器数为 0x80000001), 然后将其减 1,得到-2
147483648,与 2 147 483 647 比较，得到结果为 true。在计算机内部， 实际上是对机器数 0X80000000 和
0X7FFFFFFF 按照带符号整型进行比较。
在 ISO C99 标准下，C 表达式“ -2147483648 <2147483647”的执行结果为 true。因为在 该标准下， 编译器在处理常量时会按 int32_t(int 型、long 型)、int64_t( long long)、uint64_t (unsigned long
long)的顺序确定数据类型。也即，在 0 ~ 2“ - 1 之间的常量为 32 位带符号整 型，在 231  ~263  - 1 之间的为 64 位带符号整型，在 263  ~2M  -1 之间的为 64 位无符号整型。因 此，处理“-2147483648”时，虽然分两步得到的机器数与在 ISO C90 标准中一样，都是 0x80000000，但是，因为其对应二进制数的值为 231,在 231 ~263- 1 之间，因此被看成是 64 位 带符号数，与 2 147 483 647 比较时，按照带符号数进行比较，结果正确。

4.2 C语言中的浮点数类型
C 语言中有 float 和 double 两种不同浮点数类型，分别对应 IEEE 754 单精度浮点数格式和 双精度浮点数格式，相应的十进制有效数字分别为 7 位和 17 位左右。
C 对于扩展双精度的相应类型是 long double,但是 long double 的长度和格式随编译器和处 理器类型的不同而有所不同。例如，Microsoft Visual C++ 6. 0 版本以下的编译器都不支持该类 型，因此， 用其编译出来的目标代码中 long double 和 double —样，都是 64 位双精度；在 IA-32 上使用 gcc 编译器时，long double 类型数据采用 2. 3. 3 节中所述的 Intel x86 FPU 的 80 位双精度 扩展格式表示； 在 SPARC 和 PowerPC 处理器上使用 gcc 编译器时，long double 类型数据采用 2. 3. 3 节中所述的 128 位双精度扩展格式表示。
当在 int、float 和 double 等类型数据之间进行强制类型转换时，程序将得到以下数值转换 结果（假定 int 为 32 位）。从 int 转换为 float 时，不会发生溢出，但有效数字可能被舍去。从 int 或 float 转换为 double 时，因为 double 的有效位数更多，故能保留精确值。从 double 转换为 float 时，因为 float 表示范围更小，故可能发生溢出，此外，由于有效 位数变少，故数据可能被舍入。从 float 或 double 转换为 int 时，因为 int 没有小数部分，所以数据可能会向 0 方向被截 断。例如，1.9999 被转换为 1, -1.9999 被转换为-1。此外，因为 int 的表示范围更小，故可 能发生溢出。将大的浮点数转换为整数可能会导致程序错误，这在历史上曾经有过惨痛的教训。
1996 年 6 月 4 日，Ariana 5 火箭初次航行，在发射仅仅 37 秒钟后，偏离了飞行路线， 然后解体爆炸，火箭上载有价值 5 亿美元的通信卫星。根据调査发现，原因是由于控制惯性 导航系统的计算机向控制引擎喷嘴的计算机发送了一个无效数据。它没有发送飞行控制 信息，而是发送了一个异常诊断位模式数据，表明在将一个 64 位浮点数转换为 16 位带符 号整数时，产生了溢出异常。溢出的值是火箭的水平速率，这比原来的 Ariana 4 火箭所能 达到的速率高出了 5 倍。在设计 Ariana 4 火箭软件时，设计者确认水平速率决不会超出一 个 16 位的整数，但在设计 Ariana 5 时，他们没有重新检查这部分，而是直接使用了原来 的设计。
在不同数据类型之间转换时，往往隐藏着一些不容易被察觉的错误，这种错误有时会带来 重大损失， 因此，编程时要非常小心。
例：假定变量 i、f、d 的类型分别是 int、float 和 double,它们可以取除+ 8、-8 和 NaN 以外的任意值。请判断下列每个 C 语言关系表达式在 32 位机器上运行时是否永真。
i = = (int) ( float) i f = = ( float) ( int) f
i = = (int) ( double ) i f = = ( float) (double)f d = = ( float) d
f = = - ( -f)
(d + f) - d ==f
·不是，int 有效位数比 float 多，，从 int 型转换为 float 型时有效位数可能丢失。
·不是，float 有小数部分，f 从 float 型转换为 int 型时小数部分可能会丢失。
·是，double 比 int 有更大的精度和范围，，j 从 int 型转换为 double 型时数值不变。
·是，double 比 float 有更大的精度和范围，f 从。。成型转换为 double 型时数值不变。
·不是，double 比 float 有更大的精度和范围，当 d 从 double 型转换为 float 型时可能丢失 有效数字
或发生溢出。
·是，浮点数取负就是简单地将数符取反。
·不是，例如，当 d = 1.79xl0308、y=l. 0 时，左边为 0(因为 d+f 时/f 需向 d 对阶，对阶后 f 的
尾数有效数位被舍去而变为 0,故 d+f 仍然等于 d,再减去 d 后结果为 0),而右边 为 1。

4.3 按位运算和逻辑运算
C 语言中的按位运算有：符号“丨”表示按位“OR”运算；符号"&”表示按位“AND” 运算；符号表示按位“NOT 运算；符号"“表示按位“XOR”运算。按位运算的一 个重要运用就是实现掩码(masking) 操作，通过与给定的一个位模式进行按位与，可以提取 所需要的位，然后可以对这些位进行“置 1”、“清
0”、“是否为 1 测试”或“是否为 0 测试” 等，这里位模式被称为“掩码'。例如，表达式“OxOF&Ox8C” 的运算结果为“00001100”，即 “OxOC”。这里通过掩码“OxOF”提取了一个字节“0x8C”的低 4 位。
C 语言中的逻辑运算符有：符号" || ”表示“OR”运算；符号"&&”表示“AND”运 算；符号“！” 表示“NOT”运算。
逻辑运算很容易和按位运算混淆，事实上它们的功能完全不同。逻辑运算是非数值计算， 其操作数只有两个逻辑值：“True”和“False”，通常用非 0 数表示逻辑值 True,而全 0 表示逻 辑值 False；而按位运算是一种数值运算，运算时将两个操作数中对应各二进位按照指定的逻辑 运算规则逐位进行计算。例如，若 x = FAH, y=7BH,则叼= 81H, ~ (xy) =7EH,而！(x-y)= 00Ho 也即等价于表达式“x==y”的是
“!(x”y 也,而不是“~(x”y)”。

4.4 左移运算和右移运算
C 语言中提供了一组移位运算。移位操作有逻辑移位和算术移位两种。
逻辑移位不考虑符号位的问题，左移时，高位移出，低位补 0；右移时，低位移岀，高位 补 0。对于无符号整数的逻辑左移，如果最高位移出的是 1,则发生溢出。
因为计算机内部的带符号整数都是用补码表示的，所以对于带符号整数的移位操作应采用 补码算术移位方式。左移时，高位移出，低位补 0,如果移出的高位不同于移位后的符号位， 也即，若左移前、后符号位不同，则发生“溢出”；右移时，低位移出，高位补符号。
虽然 C 语言没有明确规定应该釆用逻辑移位还是算术移位，但是，实际上许多机器和编译 器都对无符号整数采用逻辑移位方式，而对带符号整数釆用算术移位方式。因此，编译器只要 根据移位操作数类型就可选择是逻辑还是算术移位。表达式“X<<k”表示对数 X 左移人位。 事实上，对于左移来说，逻辑移位和算术移位的结果都一样，都是丢弃 k 个最高位，并在低位 补 k 个 0。表达式“x>>k”表示对数 x 右移 L 位。
每左移一位，相当于数值扩大一倍，所以左移可能会发生溢出，左移&位，相当于数值乘 以 2'；每
右移一位，相当于数值缩小一半，右移上位，相当于数值除以 2*。
已知 32 位寄存器 R1 中存放的变量 X 的机器数为 80 00 00 04H，请回答下列问题。
当％是 unsigned int 类型时，x 的值是多少？ x/2 的值是多少？ x/2 的机器数是什么？ 2x 的值
是多少？ 2x 的机器数是什么？
当”是 int 类型时，x 的值是多少？ x/2 的值是多少？ x/2 的机器数是什么？ 2x 的值是多 少？
2x 的机器数是什么？
O ①当，是 unsigned int 类型时，x 是无符号数，机器数 80 00 00 04 H 的真值是：
+ 1000 0000 0000 0000 0000 0000 0000 0100B = 23' + 22
对于 x/2 的情况：
一方面，根据，的真值求得了/2 的值为(231  +22)/2 =230  +2；另一方面，x/2 的机器数可 由*逻辑右移一位得到，因此，x/2 的机器数是：
0100 0000 0000 0000 0000 0000 0000 0010 = 40 00 00 02 H
由上述机器数得 X/2 的真值为 2，°+2。因此，根据*的真值求出的 x/2 的值与对 x 的机器 数逻辑右移得到的 x/2 的值是一样的。
对于 2x 的情况：
一方面，根据"的真值求得 2x 的值为(231  +22) x2 =232  +23；另一方面，2x 的机器数可 由*逻辑左移一位得到，因此，2x 的机器数是：
0000 0000 0000 0000 0000 0000 0000 1000 = 00 00 00 08 H
由上述机器数得為的真值为 2，=8。显然，232+23 不等于 8,说明结果溢出。
实际上，对，左移时，移出的一位为 1,表明有效数据被丢弃，结果将会溢出，导致根据 x 的真值求出的 2x 与由 x 逻辑左移得到的臨的值不一样。其原因在于 2x 的值(232+23)超出 了最大可表示值(232 - 1 ),无法用 32 位表示。
②当％是 int 类型时，x 是带符号数，机器数 80000004H (用二进制补码表示)为： 1000 0000 0000
0000 0000 0000 0000 0100。
根据由补码求真值的简便方法“若符号位为 1,则真值的符号为负，其数值部分的各位由 补码中相应各位取反后末尾加 1 而得”，得到*的真值为：
-0111 1111 1111 1111 1111 1111 1111 1100B= - (231  -22)
对于 x/2 的情况：
一方面，根据 x 的真值可求得 x/2 的值为-(2" -2^)/2= -(2"-2)；另一方面，x/2 的 机器数可通过对 x 算术右移一位得到，因此，％/2 的机器数是：
1100 0000 0000 0000 0000 0000 0000 0010 = C0000002H
由上述机器数得 X/2 的真值为：
-0011 1111 1111 1111 1111 1111 1111 1110B= -(230  -2)
由此可见，真值求出的 x/2 与由 x 的机器数算术右移一位得到的*/2 是一样的。对于 2x 的情况：一方面，根据真值求得 2x 的值为-(2“ -2?) x2 = -(232  -23  )；另一方面，2x 的机 器数可由，算术左移一位得到，因此，2x 的机器数是：
0000 0000 0000 0000 0000 0000 0000 1000 = 00000008 H
由上述机器数得為的真值为 23=8。显然，-(232-2，)不等于 8,说明结果溢出。

4.5 位扩展运算和位截断运算
C 语言中没有明确的位扩展运算符，但是在进行数据类型转换时，如果遇到一个短数向长 数转换， 就要进行位扩展运算了。进行位扩展时，扩展后的数值应保持不变。有两种位扩展方 式：O 扩展和符号扩展。0 扩展用于无符号数，只要在短的无符号数前面添加足够的 o 即可。 符号扩展用于补码表示的带符号整数，通过在短的带符号整数前添加足够多的符号位来扩展。
考虑以下 c 语言程序代码：
short si = -32768;
unsigned short usi = s1 ;
int 1 = s1 ;
unslngned ui = us1;
执行上述程序段，并在 32 位大端方式机器上输出变量 si、usj、i、uj 的十进制和十六进制 值，可得到各变量的输出结果为：
si = -32768 80 00
usi = 32768	80 00
j= -32768 FF FF 80 00
ui = 32768	00 00 80 00
由此可见，-32 768 的补码表示和 32 768 的无符号数表示具有相同的 16 位 0/1 序列，分 别将它们
扩展为 32 位后，得到的 32 位位序列的高位不同。因为前者是符号扩展，高 16 位补 符号 1,后者是 0 扩展， 高 16 位补 0。
位截断发生在将长数转换为短数时，例如，对于下列代码：
int 1 = 32768 ;
short si = (short)1 ；
int j = si ;
在一台 32 位大端方式机器上执行上述代码段时，第 2 行要求强行将一个 32 位带符号整数 截断为一个 16 位带符号整数，32 768 的 32 位补码表示为 00008000H,截断为 16 位后变成 8000H,它是-32 768 的
16 位补码表示。再将该 16 位带符号整数扩展为 32 位时，就变成了 FFFF8000H,它是-32 768 的 32 位补码表示，因此丿为-32 768。也就是说，原来的 i (值为 32 768)经过截断、再扩展后，其值变成了-32 768, 不等于原来的值了。
从上述例子可以看出，截断一个数可能会因为溢出而改变它的值。因为长数的表示范围远 远大于短数的表示范围，所以当一个长数足够大到短数无法表示的程度，则截断时就会发生溢 出。上述例子中的32 768 大于 16 位补码能表示的最大数 32 767,所以就发生了截断错误。这 里所说的截断溢出和截断错误只会导致程序出现意外的计算结果，但并不导致任何异常或错误 报告，因此，错误的隐蔽性很强，需要引起注意。

5.字符
5.1西文字符
西文由拉丁字母、数字、标点符号及一些特殊符号所组成，它们统称为“字符” (character) o 所有字符的集合叫做“字符集“。字符不能直接在计算机内部进行处理，因而也必须对 其进行数字化编码。字符集中每一个字符都有一个代码(即二进制编码的 0/1 序列)，构成了 该字符集的代码表，简称码表。码表中的代码具有唯一性。
字符主要用于外部设备和计算机之间交换信息。一旦确定了所使用的字符集和编码方法 后，计算机内部所表示的二进制代码和外部设备输入、打印和显示的字符之间就有唯一的对应 关系。
字符集有多种，每一个字符集的编码方法也多种多样。目前计算机中使用最广泛的西文字 符集及其编码是 ASSCII 码，即美国标准信息交换码(American Standard Code for Information Interchange) ,
ASCII 字符编码见表 2. 50
从表 2. 5 中可看出，每个字符都由 7 个二进位 b6b5b4b3b2b1b0 表示，其中 b6b5b4 是高位部 分，b3b2b1b0。是低位部分。一个字符在计算机中实际上是用 8 位表示的。一般情况下，最高一 位 b7 为 0。在需要奇偶校验时，这一位可用于存放奇偶校验值，此时称这一位为奇偶校验位。 从表 2.5 中可看出 ASCII 字符编码有以下两个规律。
字符 0~9 这 10 个数字字符的高三位编码为 011,低 4 位分别为 0000-1001 o 当去掉高 三位时， 低 4 位正好是 0~9 这 10 个数字的 8421 码。这样既满足了正常的排序关系，又有利于 实现 ASCII 码与十进制数之间的转换。
英文字母字符的编码值也满足正常的字母排序关系，而且大、小写字母的编码之间有 简单的对应关系，差别仅在 b5 这一位上。若这一位为 0,则是大写字母；若为 1,则是小写字 母。这使得大、小写字母之间的转换非常方便。
表 5.1 ASCII 码表

5.2汉字字符
中文信息的基本组成单位是汉字，汉字也是字符。但汉字是表意文字，一个字就是一个方 块图形。计算机要对汉字信息进行处理，就必须对汉字本身进行编码，但汉字的总数超过 6 万 字，数量巨大，给汉字在计算机内部的表示、汉字的传输与交换、汉字的输入和输出等带来了 一系列问题。为了适应汉字系统各组成部分对汉字信息处理的不同需要，汉字系统必须处理以 下几种汉字代码：输入码、内码、字模点阵码。

5.2.1 汉字的输入码
键盘是面向西文设计的，一个或两个西文字符对应一个按键，因此使用键盘输入西文字符 非常方便。汉字是大字符集，专门的汉字输入键盘由于键多、査找不便、成本高等原因而几乎 无法釆用。由于汉字字数多，无法使每个汉字与西文键盘上的一个键相对应，因此必须使每个 汉字用一个或几个键来表示， 这种对每个汉字用相应的按键进行的编码表示就称为汉字的“遡 入码”，又称外码。因此汉字的输入码的码元(即组成编码的基本元素)是西文键盘中的某个 按键。


5.2.2 字符集与汉字内码
汉字被输入到计算机内部后，就按照一种称为“内码”的编码形式在系统中进行存储、 查找、传送等处理。对于西文字符，它的内码就是 ASCII 码。
为了适应计算机处理汉字信息的需要，1981 年我国颁布了《信息交换用汉字编码字符 集•基本集》
(GB2312—80)。该标准选出 6763 个常用汉字，为每个汉字规定了标准代码，以 供汉字信息在不同计算机系统之间交换使用。这个标准称为国标码,又称国标交换码。
GB 2312 国标字符集由三部分组成：第一部分是字母、数字和各种符号，包括英文、俄 文、日文平假名与片假名、罗马字母、汉语拼音等共 687 个；第二部分为一级常用汉字，共 3755 个，按汉语拼音排列；第三部分为二级常用汉字，共 3008 个，因为不太常用，所以按偏 旁部首排列。
GB 2312 国标字符集中为任意一个字符（汉字或其他字符）规定了一个唯一的二进制代 码。码表由
94 行（十进制编号 0~93 行）、94 列（十进制编号 0~93 列）组成，行号称为区 号，列号称为位号。每一个汉字或符号在码表中都有各自的位置，因此各有一个唯一的位置编 码，该编码用字符所在的区号及位号的二进制代码表示，7 位区号在左，7 位位号在右，共 14 位，这 14 位代码就叫汉字的“区位码”。区位码指出了汉字在码表中的位置。
汉字的区位码并不是其国标码（即国标交换码）。由于信息传输的原因，每个汉字的区号 和位号必须各自加上 32 （即十六进制的 20H）,这样区号和位号各自加上 32 后的相应的二进制 代码才是它的“国标码”，因此在"国标码”中区号和位号还是各自占 7 位。在计算机内部， 为了处理与存储的方便，汉字国标码的前后各 7 位分别用一个字节来表示，所以共需 2 个字节 才能表示一个汉字。因为计算机中的中西文信息是混合在一起进行处理的，所以汉字信息如不 予以特别的标识，它与单字节的 ASCII 码就会混淆不清，无法识别。这就是前面给出的第一个 要考虑的因素。为了解决这个问题，采用的方法之一，就是使表示汉字的两个字节的最高位 （b7）总等于 1。这种双字节（16 位）的汉字编码就是其中的一种汉字
“机内忌”（即汉字内 码）。例如，汉字“大”的区号是 20,位号是 83,因此区位码为 14 53H（OOO1 0100 0101 0011B）,国标码为 34 73H（0011 0100 0111 0011B）,前面的 34H 和字符 “4” 的 ACSU 码相
同, 后面的 73H 和字符“s”的 ACSII 码相同，将每个字节的最高位各设为 1 后，就得到其机内码 B4 F3H
（1011 0100 1111 0011B）o 这样就不会和 ASCII 码混淆了。应当注意，汉字的区位码和 国标码是唯一的、标准的，而汉字内码可能随系统的不同而有差别。
随着亚洲地区计算机应用的普及与深入，汉字字符集及其编码还在发展。国际标准 ISO/ IEC 10646 提出了一种包括全世界现代书面语言文字所使用的所有字符的标准编码，每个字符 用 4 个字节（称为UCS-4）或 2 个字节（称为 UCS-2）来编码。我国（包括香港、台湾地区） 与日本、韩国联合制订了一个统一的汉字字符集（CJK 编码），共收集了上述不同国家和地区 的共约 2 万多汉字及符号，采用 2 字节
（即 UCS-2）编码，现已被批准为国家标准（GB 13000）。 美国微软公司在 Windows 操作系统（中文版） 中也已釆用了中西文统一编码，其中收集了中、 日、韩三国常用的约 2 万汉字，称为“Unicode”（2 字节编码），它与 ISO/IEC 10646 的 UCS-2 编码一致。
汉字输入码与汉字内码、国标交换码完全是不同范畴的概念，不能把它们混淆起来。使用 不同的输入编码方法输入同一个汉字时，在计算机内部得到的汉字内码是一样的。

5.2.3 汉字的字模点阵码和轮廓描述
经过计算机处理后的汉字，如果需要在屏幕上显示出来或用打印机打印出来，则必须把汉 字机内码转换成人们可以阅读的方块字形式。
每一个汉字的字形都必须预先存放在计算机内，一套汉字（例如 GB 2312 国标汉字字符 集）的所有字符的形状描述信息集合在一起称为字形信息库，简称字库（font library）。不同的字体（如宋体、仿宋、楷体、黑体等）对应着不同的字库。在输出每一个汉字时，计算机都 要先到字库中去找到它的字形描述信息，然后把字形信息送到相应的设备输出。
汉字的字形主要有两种描述方法：字模点阵描述和轮廓描述。字模点阵描述是将字库中的 各个汉字或其他字符的字形（即字模），用一个其元素由“0”和“1”组成的方阵（如 16x 16、24 x 24、32 x32 甚至更大）来表示，汉字或字符中有黑点的地方用“1”表示，空白处用 “0”表示，我们把这种用来描述汉字字模的二进制点阵数据称为汉字的字模点阵码。汉字的轮廓描述方法比较复杂，它把汉字笔画的轮廓用一组直线和曲线来勾画，记下每一直线和曲线 的数学描述公式，目前已有两类国际标准：Adobe Typel 和 True Type。这种用轮廓线描述字形 的方式精度高，字形大小可以任意变化。

