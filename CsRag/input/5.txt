第5章


ELF 目标文件格式

1.1可重定位目标文件格式
可重定位目标文件主要包含代码部分和数据部分，它可以与其他可重定位目标文件链接， 从而创建可执行目标文件、共享库文件或其他可重定位目标文件。如图 4. 4 所示，ELF 可重定位目标文件由 ELF 头、节头表以及夹在 ELF 头和节头表之间的各个不同的节组成。

1.1.1 ELF 头
ELF 头位于目标文件的起始位置,包含文件结构说明信息。ELF 头的数据结构分 32 位系统对应结构和 64 位系统对应结构,以下是 32 位系统对应的数据结构。

#define EI_NIDENT	16
typedef struct {
unsigned char	e_ident[ EI_NIDENT]; Elf32_Half	e_type;
Elf32_Half	e_mach1ne；
Elf32_Word	e_vers1on；
Elf32_Addr	e_entry；
Elf32_0ff	e_phoff;
Elf32_0ff	e_shoff;
Elf32_Word	e_flags；
Elf32_Half	e_ehsize；
Elf32_Half	e_phentsize;
Elf32_Half	e_phnum;
Elf32_Balf	e_shents1ze；
Elf32_Half	e_shnum；


在 32 位 ELF 头的数据结构中，字段 e_ident 是一个长度为 16 的字节序列，其中，最开始的 4 字节用来标识是否为 ELF 文件，第一个字节为 0x7F,后面三个字节分别为'17、*F'O 再 后面的 12 个字节中，主要包含一些标识信息，例如，标识是 32 位还是 64 位格式、标识数据按小 端还是大端方式存放、标识ELF 头的版本号等。字段 e_type 用于说明目标文件的类型是可重定位 文件、可执行文件、共享库文件， 还是其他类型文件。字段 e_machine 用于指定机器结构类型， 如 IA-32、SPARC V9、AMD64 等。字段e_version 用于标识目标文件版本。字段 e_entry 用于指定 系统将控制权转移到的起始虚拟地址（入口点），如果文件没有关联的入口点，则为零。例如， 对于可重定位文件，此字段为 0。字段 e_ehsize 用于说明 ELF 头的大小（以字节为单位）。字段 e_shofT 指出节头表在文件中的偏移量（以字节为单位）。字段 e_shentsize 表示节头表中一个表项 的大小（以字节为单位），所有表项大小相同。字段 e_shnum 表示节头表中的项数。因此 e_shentsize 和 e_shnum 共同指定了节头表的大小（以字节为单位）。仅 ELF 头在文件中具有固定位置，即总 是在最开始的位置，其他部分的位置由 ELF 头和节头表指出，不需要具有固定的顺序。

1.1.2.节头表
节头表由若干个表项组成，每个表项描述相应的一个节的节名、位置和长度等信息，目标 文件中的每个节都有一个表项与之对应。

1.1.3.节
节是 ELF 文件中的主体信息，包含了链接过程所用的目标代码信息，包括指令、数据、符 号表和重定位信息等。一个典型的 ELF 可重定位目标文件中包含下面几个节。
text：目标代码部分。
.rodata：只读数据，如 printf 语句中的格式串、开关语句(如 switch-case)的跳转表等。
data：已初始化的全局变量°
·bss：未初始化的全局变量。因为未初始化变量没有具体的值.所以无需在目标文件中分 配用于保存值的空间，也即它在目标文件中不占据实际的磁盘空间，仅仅是一个占位符。目标 文件中区分已初始化和未初始化全局变量是为了提高空间利用率。
对于 auto 型局部变量，因为它们在运行时被分配在栈中，因此既不出现在.data 节，也不岀现
在.bss节。
.symtab：符号表(symbol table)。在程序中被定义和引用的函数名和全局变量名都属于符 号，与
这些符号相关的信息被保存在符号表中。每个可重定位目标文件都有一个.symtab节。
. reLtext：.text 节相关的可重定位信息。当链接器将某个目标文件和其他目标文件组合时, . text 节中的代码被合并后，一些指令中引用的操作数地址信息或跳转目标指令位置信息等都可 能要被修改。通常，调用外部函数或者引用全局变量的指令中的地址字段需要修改。
. rodata： .data 节相关的可重定位信息。当链接器将某个目标文件和其他目标文件组合时, .data
节中的代码被合并后，一些全局变量的地址可能被修改。
.debug：调试用符号表，有些表项对程序中定义的局部变量和类型定义进行说明，有些表 项对程序中定义和引用的全局变量进行说明。只有带-g 选项的 gcc 命令才会得到这张表。
.line： C 源程序中的行号和.text 节中机器指令之间的映射。只有带-g 选项的 gcc 命令才会 得到这张表。
.strtab：字符串表，包括.symtab 节和.debug 节中的符号以及节头表中的节名。字符串表就
是以 null 结尾的字符串序列。


图1-1 ELF 可重定位目标文件

1.2可执行目标文件格式
可执行目标文件由链接器将若干个相互关联的可重定位目标文件组合起来而生成，可重定位文件中的代码和数据的地址是相对于起始地址。而得到的，而可执行文件中代码和数据的地址则按照操作系统规定的存储器映像来确定起始地址，并且可重定位文件中代码和数据的地址将会被修改，使得它们被重定位到运行时的虚拟存储空间中相应地址处。
ELF 可执行目标文件由 ELF 头、程序头表、节头表以及夹在程序头表和节头表之间的各个不同的
节组成，如图 1-1 所示。可执行目标文件格式与可重定位目标文件格式类似，例如，这两种格式中 ELF 头的数据结构一样，.text 节、.rodata 节和.data 节中除了有些重定位地址不同以外，大部分都类似。与 ELF 可重定 位目标文件格式相比，ELF 可执行目标文件的不同点主要有：
ELF 头中字段 e_entry 给出系统将控制权转移到的起始的虚拟地址（入口点），即执行 程序时第一
条指令的地址。而在可重定位目标文件中，此字段为 0。多了一个.init 节，其中定义了一个一 init 函数，用于可执行目标文件开始执行时的初始 化工作。少了两个.rel 节，因为可执行目标文件中的指令和数据已被重定位，故可去掉用于重定 位的节。多了一个程段头表,也称段头表（segment header table）,它是一个结构数组。可执行目 标文件中所有代码的位置连续，所有只读数据的位置连续，所有可读可写数据的位置连续。因 而，这些连续的片段（chunk）被映射到存储空间（实际上就是虚拟地址空间）中的一个存储 段，程序头表用于描述这种映射关系，一个表项说明一个连续的片段或一个特殊的节。由 ELF 头中的字段 e_phentsize 和 e_phnum 分别指定程序头表表项大小和表项数。
32 位系统的程序头表中每个表项具有以下数据结构：

typedef struct {
E1f32_Word	p_type;
Elf32_0ff	p_offset;
Elf32_Addr	p_vaddr；
Elf32_Addr	p_paddr；
Elf32_Word	p_filesz;
Elf32_Word	pjnemsz;
Elf32_Word	p_flags;
Elf32_Word	p.align；
} Elf32_Phdr；

P.type 描述存储段的类型或特殊节的类型。例如，是否为可装入段（PT_LOAD）,是否是 特殊的动态节（PT_DYNAMIC）,是否是特殊的解释程序节（PT_INTERP）。p_offset 指出本段 的首字节在文件中的偏移地址。P_vaddr 指出本段首字节的虚拟地址。p_paddr 指出本段首字节 的物理地址，因为物理地址由操作系统根据情况动态确定，因而该信息通常是无效的。p.filesz 指出本段在文件中所占的字节数， 可以为 0。p_memsz 指出本段在存储器中所占字节数，也可 以为 0。p_flags 指出存取权限。p_align 指出对齐方式，用一个模数表示，为 2 的正整数蓦，通 常模数与页面大小相关，若页面大小为 4KB,则模数为 212。






图 1-2 给出了使用 GNU READELF 显示的某个可执行目标文件的程序头表信息。

图 1-2 给出的程序头表中有 8 个表项，其中有两个是可装入段(Type=LOAD)对应的表 项信息。第一个可装入段对应可执行目标文件中第 0x00000 - 0x004(13 字节的内容( 包括 ELF 头、 程序头表以及.init、.text 和.rodata 节)，被映射到虚拟地址 0x8048000 开始的长度为 0x004d4 字节 的区域，按0x1000 = 2,2  = 4KB 对齐，具有只读/执行权限(Flg = RE),因此它是一个只读代码段 (read-only code segment)。第二个可装入段对应可执行目标文件中第 OxOOOfOc 开始的长度为 0x00108 字节的内容(即.data 节)，被映射到虚拟地址 0x8049f0c 开始的长度为 0x00110 字节的存 储区域，在 0x00110 = 272 字节的存储区中，前 0x00108 = 264 字节用.data 节的内容来初始化，而 后面的 272 - 264 = 8 个字节对应.bss 节，被初始化为 0,该段按 0x1000 = 4KB 对齐，具有可读可写 权限(Flg = RW),因此，它是一个可读写数据成(read/write data segment)。
从这个例子可以看出，.data 节在可执行目标文件中占用了相应的磁盘空间，在存储器中也 需要给它分配相同大小的空间；而.bss 节在文件中不占用磁盘空间，但在存储器中需要给它分 配相应大小的空间。

1.3实验：程序的链接和执行视图

程序的链接视图和执行视图
输入以下程序12-1.c：
//12-1.c
#include <stdio.h> 
extern int shared;
int init_global_20=20; 
int init_global_0=0; 
int uninit_global; 
int main()
{
	static int init_static_20=20; 
	static int init_static_0=0; 
	static int uninit_static; 
	int init_local=100;
	int uninit_local;
	printf("address of init_global_20:%x\n",&init_global_20);
	printf("address of init_global_0:%x\n",&init_global_0);
	printf("address of uninit_global:%x\n",&uninit_global);
	printf("address of init_static_20:%x\n",&init_static_20);
	printf("address of init_static_2:%x\n",&init_static_0);
	printf("address of uninit_static:%x\n",&uninit_static);
	printf("address of init_local:%x\n",&init_local);
	printf("address of uninit_local:%x\n",&uninit_local);
	return 0;
}

（1）编译成可重定位目标文件：
$gcc -c -m32 12-1.c -o 12-1.o
用 hexdump查看文件内容：
$hexdump -C 12-1.o
00000000  7f 45 4c 46 01 01 01 00  	00 00 00 00 00 00 00 00  	|.ELF............|
00000010  01 00 03 00 01 00 00 00  	00 00 00 00 00 00 00 00  	|................|
00000020  50 05 00 00 00 00 00 00  	34 00 00 00 00 00 28 00  	|P.......4.....(.|
00000030  0d 00 0a 00 8d 4c 24 04  	83 e4 f0 ff 71 fc 55 89  	|.....L$.....q.U.|
00000040  e5 51 83 ec 14 65 a1 14  	00 00 00 89 45 f4 31 c0  	|.Q...e......E.1.|
00000050  c7 45 ec 64 00 00 00 83  	ec 08 68 00 00 00 00 68  	|.E.d......h....h|
00000060  00 00 00 00 e8 fc ff ff  	ff 83 c4 10 83 ec 08 68  	|...............h|
00000070  00 00 00 00 68 1e 00 00  	00 e8 fc ff ff ff 83 c4  	|....h...........|
00000080  10 83 ec 08 68 00 00 00  	00 68 3b 00 00 00 e8 fc  	|....h....h;.....|
00000090  ff ff ff 83 c4 10 83 ec  	08 68 04 00 00 00 68 58  	|.........h....hX|
000000a0  00 00 00 e8 fc ff ff ff  	83 c4 10 83 ec 08 68 04  	|..............h.|
000000b0  00 00 00 68 76 00 00 00  	e8 fc ff ff ff 83 c4 10  	|...hv...........|
000000c0  83 ec 08 68 08 00 00 00  	68 93 00 00 00 e8 fc ff  	|...h....h.......|
000000d0  ff ff 83 c4 10 83 ec 08  	8d 45 ec 50 68 b0 00 00  	|.........E.Ph...|
000000e0  00 e8 fc ff ff ff 83 c4  	10 83 ec 08 8d 45 f0 50  	|.............E.P|
000000f0  68 ca 00 00 00 e8 fc ff  	ff ff 83 c4 10 b8 00 00  	|h...............|
00000100  00 00 8b 55 f4 65 33 15  	14 00 00 00 74 05 e8 fc  	|...U.e3.....t...|
00000110  ff ff ff 8b 4d fc c9 8d  	61 fc c3 00 14 00 00 00  	|....M...a.......|
00000120  14 00 00 00 61 64 64 72  	65 73 73 20 6f 66 20 69  	|....address of i|
00000130  6e 69 74 5f 67 6c 6f 62  	61 6c 5f 32 30 3a 25 78  	|nit_global_20:%x|
00000140  0a 00 61 64 64 72 65 73  	73 20 6f 66 20 69 6e 69  	|..address of ini|
00000150  74 5f 67 6c 6f 62 61 6c  	5f 30 3a 25 78 0a 00 61  	|t_global_0:%x..a|
00000160  64 64 72 65 73 73 20 6f  	66 20 75 6e 69 6e 69 74  	|ddress of uninit|
00000170  5f 67 6c 6f 62 61 6c 3a  	25 78 0a 00 61 64 64 72  	|_global:%x..addr|
00000180  65 73 73 20 6f 66 20 69  	6e 69 74 5f 73 74 61 74  	|ess of init_stat|
00000190  69 63 5f 32 30 3a 25 78  	0a 00 61 64 64 72 65 73  	|ic_20:%x..addres|
000001a0  73 20 6f 66 20 69 6e 69  	74 5f 73 74 61 74 69 63  	|s of init_static|
000001b0  5f 32 3a 25 78 0a 00 61  	64 64 72 65 73 73 20 6f  	|_2:%x..address o|
000001c0  66 20 75 6e 69 6e 69 74  	5f 73 74 61 74 69 63 3a  	|f uninit_static:|
000001d0  25 78 0a 00 61 64 64 72  	65 73 73 20 6f 66 20 69  	|%x..address of i|
000001e0  6e 69 74 5f 6c 6f 63 61  	6c 3a 25 78 0a 00 61 64  	|nit_local:%x..ad|
000001f0  64 72 65 73 73 20 6f 66  	20 75 6e 69 6e 69 74 5f  	|dress of uninit_|
00000200  6c 6f 63 61 6c 3a 25 78  	0a 00 00 47 43 43 3a 20  	|local:%x...GCC: |
00000210  28 55 62 75 6e 74 75 20  	35 2e 34 2e 30 2d 36 75  	|(Ubuntu 5.4.0-6u|
00000220  62 75 6e 74 75 31 7e 31  	36 2e 30 34 2e 31 32 29  	|buntu1~16.04.12)|
00000230  20 35 2e 34 2e 30 20 32  	30 31 36 30 36 30 39 00  	| 5.4.0 20160609.|
00000240  14 00 00 00 00 00 00 00  	01 7a 52 00 01 7c 08 01  	|.........zR..|..|
00000250  1b 0c 04 04 88 01 00 00  	28 00 00 00 1c 00 00 00  	|........(.......|
00000260  00 00 00 00 e7 00 00 00  	00 44 0c 01 00 47 10 05  	|.........D...G..|
00000270  02 75 00 43 0f 03 75 7c  	06 02 d4 0c 01 00 41 c5  	|.u.C..u|......A.|
00000280  43 0c 04 04 00 00 00 00  	00 00 00 00 00 00 00 00  	|C...............|
00000290  00 00 00 00 01 00 00 00  	00 00 00 00 00 00 00 00  	|................|
000002a0  04 00 f1 ff 00 00 00 00  	00 00 00 00 00 00 00 00  	|................|
000002b0  03 00 01 00 00 00 00 00  	00 00 00 00 00 00 00 00  	|................|
000002c0  03 00 03 00 00 00 00 00  	00 00 00 00 00 00 00 00  	|................|
000002d0  03 00 04 00 00 00 00 00  	00 00 00 00 00 00 00 00  	|................|
000002e0  03 00 05 00 08 00 00 00  	04 00 00 00 04 00 00 00  	|................|
000002f0  01 00 03 00 1c 00 00 00  	04 00 00 00 04 00 00 00  	|................|
00000300  01 00 04 00 2f 00 00 00  	08 00 00 00 04 00 00 00  	|..../...........|
00000310  01 00 04 00 00 00 00 00  	00 00 00 00 00 00 00 00  	|................|
00000320  03 00 07 00 00 00 00 00  	00 00 00 00 00 00 00 00  	|................|
00000330  03 00 08 00 00 00 00 00  	00 00 00 00 00 00 00 00  	|................|
00000340  03 00 06 00 42 00 00 00  	00 00 00 00 04 00 00 00  	|....B...........|
00000350  11 00 03 00 51 00 00 00  	00 00 00 00 04 00 00 00  	|....Q...........|
00000360  11 00 04 00 5f 00 00 00  	04 00 00 00 04 00 00 00  	|...._...........|
00000370  11 00 f2 ff 6d 00 00 00  	00 00 00 00 e7 00 00 00  	|....m...........|
00000380  12 00 01 00 72 00 00 00  	00 00 00 00 00 00 00 00  	|....r...........|
00000390  10 00 00 00 79 00 00 00  	00 00 00 00 00 00 00 00  	|....y...........|
000003a0  10 00 00 00 00 31 32 2d  	31 2e 63 00 69 6e 69 74  	|.....12-1.c.init|
000003b0  5f 73 74 61 74 69 63 5f  	32 30 2e 31 39 33 37 00  	|_static_20.1937.|
000003c0  69 6e 69 74 5f 73 74 61  	74 69 63 5f 30 2e 31 39  	|init_static_0.19|
000003d0  33 38 00 75 6e 69 6e 69  	74 5f 73 74 61 74 69 63 	|38.uninit_static|
000003e0  2e 31 39 33 39 00 69 6e  	69 74 5f 67 6c 6f 62 61  	|.1939.init_globa|
000003f0  6c 5f 32 30 00 69 6e 69  	74 5f 67 6c 6f 62 61 6c  	|l_20.init_global|
00000400  5f 30 00 75 6e 69 6e 69  	74 5f 67 6c 6f 62 61 6c  	|_0.uninit_global|
00000410  00 6d 61 69 6e 00 70 72  	69 6e 74 66 00 5f 5f 73  	|.main.printf.__s|
00000420  74 61 63 6b 5f 63 68 6b  	5f 66 61 69 6c 00 00 00  	|tack_chk_fail...|
00000430  27 00 00 00 01 0c 00 00  	2c 00 00 00 01 05 00 00  	|'.......,.......|
00000440  31 00 00 00 02 10 00 00  	3c 00 00 00 01 0d 00 00  	|1.......<.......|
00000450  41 00 00 00 01 05 00 00  	46 00 00 00 02 10 00 00  	|A.......F.......|
00000460  51 00 00 00 01 0e 00 00  	56 00 00 00 01 05 00 00  	|Q.......V.......|
00000470  5b 00 00 00 02 10 00 00  	66 00 00 00 01 03 00 00  	|[.......f.......|
00000480  6b 00 00 00 01 05 00 00  	70 00 00 00 02 10 00 00  	|k.......p.......|
00000490  7b 00 00 00 01 04 00 00  	80 00 00 00 01 05 00 00  	|{...............|
000004a0  85 00 00 00 02 10 00 00  	90 00 00 00 01 04 00 00  	|................|
000004b0  95 00 00 00 01 05 00 00  	9a 00 00 00 02 10 00 00  	|................|
000004c0  a9 00 00 00 01 05 00 00  	ae 00 00 00 02 10 00 00  	|................|
000004d0  bd 00 00 00 01 05 00 00  	c2 00 00 00 02 10 00 00  	|................|
000004e0  db 00 00 00 02 11 00 00  	20 00 00 00 02 02 00 00  	|........ .......|
000004f0  00 2e 73 79 6d 74 61 62  	00 2e 73 74 72 74 61 62  	|..symtab..strtab|
00000500  00 2e 73 68 73 74 72 74  	61 62 00 2e 72 65 6c 2e  	|..shstrtab..rel.|
00000510  74 65 78 74 00 2e 64 61  	74 61 00 2e 62 73 73 00  	|text..data..bss.|
00000520  2e 72 6f 64 61 74 61 00  	2e 63 6f 6d 6d 65 6e 74  	|.rodata..comment|
00000530  00 2e 6e 6f 74 65 2e 47  	4e 55 2d 73 74 61 63 6b  	|..note.GNU-stack|
00000540  00 2e 72 65 6c 2e 65 68  	5f 66 72 61 6d 65 00 00  	|..rel.eh_frame..|
00000550  00 00 00 00 00 00 00 00  	00 00 00 00 00 00 00 00  	|................|
*
00000570  00 00 00 00 00 00 00 00  	1f 00 00 00 01 00 00 00  	|................|
00000580  06 00 00 00 00 00 00 00  	34 00 00 00 e7 00 00 00  	|........4.......|
00000590  00 00 00 00 00 00 00 00  	01 00 00 00 00 00 00 00  	|................|
000005a0  1b 00 00 00 09 00 00 00  	40 00 00 00 00 00 00 00  	|........@.......|
000005b0  30 04 00 00 b8 00 00 00  	0b 00 00 00 01 00 00 00  	|0...............|
000005c0  04 00 00 00 08 00 00 00  	25 00 00 00 01 00 00 00  	|........%.......|
000005d0  03 00 00 00 00 00 00 00  	1c 01 00 00 08 00 00 00  	|................|
000005e0  00 00 00 00 00 00 00 00  	04 00 00 00 00 00 00 00  	|................|
000005f0  2b 00 00 00 08 00 00 00  	03 00 00 00 00 00 00 00  	|+...............|
00000600  24 01 00 00 0c 00 00 00  	00 00 00 00 00 00 00 00  	|$...............|
00000610  04 00 00 00 00 00 00 00  	30 00 00 00 01 00 00 00  	|........0.......|
00000620  02 00 00 00 00 00 00 00  	24 01 00 00 e6 00 00 00  	|........$.......|
00000630  00 00 00 00 00 00 00 00  	01 00 00 00 00 00 00 00  	|................|
00000640  38 00 00 00 01 00 00 00  	30 00 00 00 00 00 00 00  	|8.......0.......|
00000650  0a 02 00 00 36 00 00 00  	00 00 00 00 00 00 00 00  	|....6...........|
00000660  01 00 00 00 01 00 00 00  	41 00 00 00 01 00 00 00  	|........A.......|
00000670  00 00 00 00 00 00 00 00  	40 02 00 00 00 00 00 00  	|........@.......|
00000680  00 00 00 00 00 00 00 00  	01 00 00 00 00 00 00 00  	|................|
00000690  55 00 00 00 01 00 00 00  	02 00 00 00 00 00 00 00  	|U...............|
000006a0  40 02 00 00 44 00 00 00  	00 00 00 00 00 00 00 00  	|@...D...........|
000006b0  04 00 00 00 00 00 00 00  	51 00 00 00 09 00 00 00  	|........Q.......|
000006c0  40 00 00 00 00 00 00 00  	e8 04 00 00 08 00 00 00  	|@...............|
000006d0  0b 00 00 00 08 00 00 00  	04 00 00 00 08 00 00 00  	|................|
000006e0  11 00 00 00 03 00 00 00  	00 00 00 00 00 00 00 00  	|................|
000006f0  f0 04 00 00 5f 00 00 00  	00 00 00 00 00 00 00 00  	|...._...........|
00000700  01 00 00 00 00 00 00 00  	01 00 00 00 02 00 00 00  	|................|
00000710  00 00 00 00 00 00 00 00  	84 02 00 00 20 01 00 00  	|............ ...|
00000720  0c 00 00 00 0c 00 00 00  	04 00 00 00 10 00 00 00  	|................|
00000730  09 00 00 00 03 00 00 00  	00 00 00 00 00 00 00 00  	|................|
00000740  a4 03 00 00 8a 00 00 00  	00 00 00 00 00 00 00 00  	|................|
00000750  01 00 00 00 00 00 00 00                           	|........|
00000758
作业截图1 hexdump查看文件内容
从左到右的内容为：偏移量，16进制字节内容， ASCII 码内容。

（2）查看文件头内容：
$readelf -h 12-1.o
ELF Header:
  Magic:   	7f 45 4c 46 01 01 01 00 00 00 00 00 00 00 00 00
  Class:               	ELF32
  Data:                     	2's complement, little endian
  Version:                   	1 (current)
  OS/ABI:                 	UNIX - System V
  ABI Version:            	0
  Type:                   	REL (Relocatable file)
  Machine:                 	Intel 80386
  Version:                  	0x1
  Entry point address:         	0x0
  Start of program headers:   	0 (bytes into file)
  Start of section headers:    	1360 (bytes into file)
  Flags:                     	0x0
  Size of this header:       	52 (bytes)
  Size of program headers:  	0 (bytes)
  Number of program headers:  	0
  Size of section headers:     	40 (bytes)
  Number of section headers:   	13
  Section header string table index: 	10
作业截图2 文件头内容
对照作业截图1、2，填写以下表格，解析12-1.o文件头内容：


（3）找到节头表的位置，对内容截图：
00000550  00 00 00 00 00 00 00 00  	00 00 00 00 00 00 00 00  	|................|
*
00000570  00 00 00 00 00 00 00 00  	1f 00 00 00 01 00 00 00  	|................|
00000580  06 00 00 00 00 00 00 00  	34 00 00 00 e7 00 00 00  	|........4.......|
00000590  00 00 00 00 00 00 00 00  	01 00 00 00 00 00 00 00  	|................|
000005a0  1b 00 00 00 09 00 00 00  	40 00 00 00 00 00 00 00  	|........@.......|
000005b0  30 04 00 00 b8 00 00 00  	0b 00 00 00 01 00 00 00  	|0...............|
000005c0  04 00 00 00 08 00 00 00  	25 00 00 00 01 00 00 00  	|........%.......|
000005d0  03 00 00 00 00 00 00 00  	1c 01 00 00 08 00 00 00  	|................|
000005e0  00 00 00 00 00 00 00 00  	04 00 00 00 00 00 00 00  	|................|
000005f0  2b 00 00 00 08 00 00 00  	03 00 00 00 00 00 00 00  	|+...............|
00000600  24 01 00 00 0c 00 00 00  	00 00 00 00 00 00 00 00  	|$...............|
00000610  04 00 00 00 00 00 00 00  	30 00 00 00 01 00 00 00  	|........0.......|
00000620  02 00 00 00 00 00 00 00  	24 01 00 00 e6 00 00 00  	|........$.......|
00000630  00 00 00 00 00 00 00 00  	01 00 00 00 00 00 00 00  	|................|
00000640  38 00 00 00 01 00 00 00  	30 00 00 00 00 00 00 00  	|8.......0.......|
00000650  0a 02 00 00 36 00 00 00  	00 00 00 00 00 00 00 00  	|....6...........|
00000660  01 00 00 00 01 00 00 00  	41 00 00 00 01 00 00 00  	|........A.......|
00000670  00 00 00 00 00 00 00 00  	40 02 00 00 00 00 00 00  	|........@.......|
00000680  00 00 00 00 00 00 00 00  	01 00 00 00 00 00 00 00  	|................|
00000690  55 00 00 00 01 00 00 00  	02 00 00 00 00 00 00 00  	|U...............|
000006a0  40 02 00 00 44 00 00 00  	00 00 00 00 00 00 00 00  	|@...D...........|
000006b0  04 00 00 00 00 00 00 00  	51 00 00 00 09 00 00 00  	|........Q.......|
000006c0  40 00 00 00 00 00 00 00  	e8 04 00 00 08 00 00 00  	|@...............|
作业截图3 文件表内容
查看节头表的内容
$readelf -S 12-1.o
There are 13 section headers, starting at offset 0x550:

Section Headers:
  [Nr] Name  	Type   	Addr     Off   Size   ES	Flg	Lk	Inf  Al
  [ 0] 	NULL  	00000000 000000 000000 00 		0   0  	0
  [ 1] .text  	PROGBITS  	00000000 000034 0000e7 00  	AX	0   0  	1
  [ 2] .rel.text	REL     	00000000 000430 0000b8 08 	I 	11 	1 	4
  [ 3] .data	PROGBITS 	00000000 00011c 000008 00 	WA	0   0  	4
  [ 4] .bss	NOBITS  	00000000 000124 00000c 00 	WA	0   0  	4
  [ 5] .rodata	PROGBITS	00000000 000124 0000e6 00  	A	0   0  	1
  [ 6] .comment	PROGBITS 	00000000 00020a 000036 01 	MS	0   0  	1
  [ 7] .note.GNU-stack	PROGBITS	00000000 000240 000000 00     	0   0  	1
  [ 8] .eh_frame	PROGBITS	00000000 000240 000044 00 	A  	0   0  	4
  [ 9] .rel.eh_frame	REL  	00000000 0004e8 000008 08 	I 	11 	8  	4
  [10] .shstrtab	STRTAB  	00000000 0004f0 00005f 00      	0   0  	1
  [11] .symtab	SYMTAB  	00000000 000284 000120 10     	12  12 	4
  [12] .strtab	STRTAB   	00000000 0003a4 00008a 00      	0   0  	1
Key to Flags:
  W (write), A (alloc), X (execute), M (merge), S (strings)
  I (info), L (link order), G (group), T (TLS), E (exclude), x (unknown)
  O (extra OS processing required) o (OS specific), p (processor specific)
作业截图4 节头表内容

（4）找到符号表的位置，对内容截图：
00 00 00 00  	00 00 00 00 00 00 00 00  	|C...............|
00000290  00 00 00 00 01 00 00 00  	00 00 00 00 00 00 00 00  	|................|
000002a0  04 00 f1 ff 00 00 00 00  	00 00 00 00 00 00 00 00  	|................|
000002b0  03 00 01 00 00 00 00 00  	00 00 00 00 00 00 00 00  	|................|
000002c0  03 00 03 00 00 00 00 00  	00 00 00 00 00 00 00 00  	|................|
000002d0  03 00 04 00 00 00 00 00  	00 00 00 00 00 00 00 00  	|................|
000002e0  03 00 05 00 08 00 00 00  	04 00 00 00 04 00 00 00  	|................|
000002f0  01 00 03 00 1c 00 00 00  	04 00 00 00 04 00 00 00  	|................|
00000300  01 00 04 00 2f 00 00 00  	08 00 00 00 04 00 00 00  	|..../...........|
00000310  01 00 04 00 00 00 00 00  	00 00 00 00 00 00 00 00  	|................|
00000320  03 00 07 00 00 00 00 00  	00 00 00 00 00 00 00 00  	|................|
00000330  03 00 08 00 00 00 00 00  	00 00 00 00 00 00 00 00  	|................|
00000340  03 00 06 00 42 00 00 00  	00 00 00 00 04 00 00 00  	|....B...........|
00000350  11 00 03 00 51 00 00 00  	00 00 00 00 04 00 00 00  	|....Q...........|
作业截图5符号表内容
查看符号表的内容
$readelf –s 12-1.o
Symbol table '.symtab' contains 18 entries:
  Num: Value      Size Type      Bind     Vis        Ndx     Name
     0: 00000000    	0 NOTYPE 	LOCAL 	DEFAULT 	UND
     1: 00000000     0 FILE    	LOCAL  	DEFAULT  	ABS 	12-1.c
     2: 00000000     0 SECTION LOCAL  	DEFAULT    1
     3: 00000000     0 SECTION LOCAL  	DEFAULT    3
     4: 00000000     0 SECTION LOCAL  	DEFAULT    4
     5: 00000000     0 SECTION LOCAL  	DEFAULT    5
     6: 00000004     4 OBJECT  LOCAL  	DEFAULT    3 	init_static_20.1937
     7: 00000004     4 OBJECT  LOCAL  	DEFAULT    4 	init_static_0.1938
     8: 00000008     4 OBJECT  LOCAL  	DEFAULT    4 	uninit_static.1939
     9: 00000000     0 SECTION LOCAL  	DEFAULT    7
    10: 00000000     0 SECTION LOCAL  	DEFAULT    8
    11: 00000000     0 SECTION LOCAL  	DEFAULT    6
    12: 00000000     4 OBJECT  GLOBAL 	DEFAULT    3 	init_global_20
    13: 00000000     4 OBJECT  GLOBAL 	DEFAULT    4 	init_global_0
    14: 00000004     4 OBJECT  GLOBAL 	DEFAULT  COM	uninit_global
    15: 00000000   231 FUNC    GLOBAL 	DEFAULT    1 	main
    16: 00000000     0 NOTYPE  GLOBAL DEFAULT  UND 	printf
    17: 00000000     0 NOTYPE  GLOBAL DEFAULT  UND	stack_chk_fail
作业截图6 符号表内容
编译为可重定位目标文件，查看符号表，填定下表：


（5）解释符号表里的第1、2和printf项。
第1项：无用的占位项；
第2项：文件名；
第printf项：外部符号。

（6）找到程序12-1.c中有下划线的printf的字符串的位置及相应机器值：

（7）将程序12-1.c编译成可执行目标文件
$gcc -m32 12-1.c -o 12-1
用 hexdump查看文件内容，对照12-1.o和12-1文件头，列举两者值不同值的位置及意义：
对照12-1.o和12-1节头表，列举两者值不同值的位置及意义：
对照12-1.o和12-1符号表，列举两者值不同值的位置及意义：
对照12-1.o和12-1字符串表，列举两者值不同值的位置及意义：

（8）用hexdump在12-1的.text找到前20个字节；同时反汇编12-1为12-1.s，查看12-1.s代码段。两相对照，建立对应关系。
00000370  31 ed 5e 89 e1 83 e4 f0  	50 54 52 68 c0 85 04 08  	|1.^.....PTRh....|
00000380  68 60 85 04 08 51 56 68  	6b 84 04 08 e8 bf ff ff  	|h`...QVhk.......|
00000390  ff f4 66 90 66 90 66 90  	66 90 66 90 66 90 66 90  	|..f.f.f.f.f.f.f.|
000003a0  8b 1c 24 c3 66 90 66 90  	66 90 66 90 66 90 66 90  	|..$.f.f.f.f.f.f.|
000003b0  b8 2b a0 04 08 2d 28 a0  	04 08 83 f8 06 76 1a b8  	|.+...-(......v..|
000003c0  00 00 00 00 85 c0 74 11  	55 89 e5 83 ec 14 68 28  	|......t.U.....h(|
000003d0  a0 04 08 ff d0 83 c4 10  	c9 f3 c3 90 8d 74 26 00  	|.............t&.|
000003e0  b8 28 a0 04 08 2d 28 a0  	04 08 c1 f8 02 89 c2 c1  	|.(...-(.........|
000003f0  ea 1f 01 d0 d1 f8 74 1b  	ba 00 00 00 00 85 d2 74  	|......t........t|
00000400  12 55 89 e5 83 ec 10 50  	68 28 a0 04 08 ff d2 83  	|.U.....Ph(......| 
00000410  c4 10 c9 f3 c3 8d 74 26  	00 8d bc 27 00 00 00 00  	|......t&...'....|
00000420  80 3d 28 a0 04 08 00 75  	13 55 89 e5 83 ec 08 e8  	|.=(....u.U......|
00000430  7c ff ff ff c6 05 28 a0  	04 08 01 c9 f3 c3 66 90  	||.....(.......f.|
00000440  b8 10 9f 04 08 8b 10 85  	d2 75 05 eb 93 8d 76 00  	|.........u....v.|
00000450  ba 00 00 00 00 85 d2 74  	f2 55 89 e5 83 ec 14 50  	|.......t.U.....P|
00000460  ff d2 83 c4 10 c9 e9 75  	ff ff ff 8d 4c 24 04 83  	|.......u....L$..|
00000470  e4 f0 ff 71 fc 55 89 e5  	51 83 ec 14 65 a1 14 00  	|...q.U..Q...e...|
00000480  00 00 89 45 f4 31 c0 c7  	45 ec 64 00 00 00 83 ec  	|...E.1..E.d.....|
00000490  08 68 20 a0 04 08 68 e0  	85 04 08 e8 90 fe ff ff  	|.h ...h.........|
作业截图7 12-1的.text找到前若干个字节
12-1:     file format elf32-i386
Disassembly of section .text:
08048370 <_start>:
 8048370:       31 ed             	xor    %ebp,%ebp
 8048372:       5e              	pop    %esi
 8048373:       89 e1            	mov    %esp,%ecx
 8048375:       83 e4 f0         	and    $0xfffffff0,%esp
 8048378:       50            	push   %eax
 8048379:       54             	push   %esp
 804837a:       52             	push   %edx
 804837b:       68 c0 85 04 08  	push   $0x80485c0
 8048380:       68 60 85 04 08   	push   $0x8048560
 8048385:       51              	push   %ecx
 8048386:       56            	push   %esi
 8048387:       68 6b 84 04 08  	push   $0x804846b
 804838c:       e8 bf ff ff ff   	call   8048350 <__libc_start_main@plt>
 8048391:       f4               	hlt
 8048392:       66 90           	xchg   %ax,%ax
 8048394:       66 90         	xchg   %ax,%ax
 8048396:       66 90         	xchg   %ax,%ax
 8048398:       66 90       	xchg   %ax,%ax
 804839a:       66 90          	xchg   %ax,%ax
 804839c:       66 90        	xchg   %ax,%ax
 804839e:       66 90        	xchg   %ax,%ax
作业截图8 12-1.s代码段
解释：12-1.s中的机器码与12-1的.text一样。

(9)运行并调试程序，查看变量地址，并解释。
address of init_global_20:804a020
address of init_global_0:804a02c
address of uninit_global:804a038
address of init_static_20:804a024
address of init_static_2:804a030
address of uninit_static:804a034
address of init_local:ffc05fe4
address of uninit_local:ffc05fe8
作业截图9 变量地址

ELF文件中的section

编写12-2-1.c、12-2-2.c文件。
//12-2-1.c
extern int shared; 
int main(){
int a=100;
swap(&a, &shared);
return 0;
}
//12-2-2.c
int shared; 
void swap(int* a, int* b){
  *a^=*b^=*a^=*b;
}
编译并链接：
$gcc -fno-stack-protector  -c 12-2-1.c 12-2-2.c
$ld 12-2-1.o 12-2-2.o -e main -o 12-2
-fno-stack-protector不需要栈保护；
-e main表示将main函数作为程序入口(默认入口函数为_start) ；
-o 12-2表示链接输出文件名为12-2。

(1)解释elf文件头，说明两个文件elf文件头的不同；
$readelf -h 12-2-1.o
ELF Header:
  Magic:   7f 45 4c 46 01 01 01 00 00 00 00 00 00 00 00 00
  Class:               	ELF32
  Data:                  	2's complement, little endian
  Version:                 	1 (current)
  OS/ABI:             	UNIX - System V
  ABI Version:            	0
  Type:                 	REL (Relocatable file)
  Machine:                 	Intel 80386
  Version:                 	0x1
  Entry point address:        	0x0
  Start of program headers:  	0 (bytes into file)
  Start of section headers:   	548 (bytes into file)
  Flags:                   	0x0
  Size of this header:        	52 (bytes)
  Size of program headers:    0 (bytes)
  Number of program headers:0
  Size of section headers:     	40 (bytes)
  Number of section headers: 12
  Section header string table index: 9

ELF Header:
  Magic:   7f 45 4c 46 01 01 01 00 00 00 00 00 00 00 00 00
  Class:                	ELF32
  Data:                      	2's complement, little endian
  Version:                  	1 (current)
  OS/ABI:                   	UNIX - System V
  ABI Version:             	0
  Type:                    	EXEC (Executable file)
  Machine:                 	Intel 80386
  Version:                  	0x1
  Entry point address:   	0x8048094
  Start of program headers:    	52 (bytes into file)
  Start of section headers:      	748 (bytes into file)
  Flags:                    		0x0
  Size of this header:         		52 (bytes)
  Size of program headers:    	32 (bytes)
  Number of program headers: 	3
  Size of section headers:       	40 (bytes)
  Number of section headers:   	8
  Section header string table index: 5
解释：

（2）对比两个文件的节头表，说明两个文件节头表的不同；
There are 12 section headers, starting at offset 0x224:
Section Headers:
  [Nr] Name  	Type	Addr	Off 	Size	ES	Flg	Lk	Inf	Al
  [ 0]       	NULL    	00000000 000000 000000 00 		0 0	0
  [ 1] .text         	PROGBITS00000000 000034 000039 00	AX	0 0 1
  [ 2] .rel.text         REL	00000000 0001b4 000010 08 	I 	10 1  4
  [ 3] .data         	PROGBITS00000000 00006d 000000 00  WA  0 0 1
  [ 4] .bss          	NOBITS	00000000 00006d 000000 00  WA 	0	0 1
  [ 5] .comment  	PROGBITS00000000 00006d 000036 01 	MS	0	0	1
  [ 6] .note.GNU-stackPROGBITS00000000 0000a3 000000 00		0	0	1
  [ 7] .eh_frame    	PROGBITS00000000 0000a4 000044 00   A  0   0  4
  [ 8] .rel.eh_frame	REL    	00000000 0001c4 000008 08   I 10   7  4
  [ 9] .shstrtab    	STRTAB 	00000000 0001cc 000057 00      0   0  1
  [10] .symtab    	SYMTAB 	00000000 0000e8 0000b0 10     11   8  4
  [11] .strtab    	STRTAB 	00000000 000198 00001b 00      0   0  1

There are 8 section headers, starting at offset 0x2ec:
Section Headers:
  [Nr] Name       	Type      	Addr     Off    Size   ES Flg Lk Inf Al
  [ 0]          	NULL    	00000000 000000 000000 00     	0 0 0
  [ 1] .text      	PROGBITS08048094 000094 000072 00  AX	0 0 1
  [ 2] .eh_frame 	PROGBITS08048108 000108 000064 00   A	0 0 4
  [ 3] .bss        	NOBITS   0804916c 00016c 000004 00  WA	0 0 4
  [ 4] .comment 	PROGBITS00000000 00016c 000035 01  MS	0 0 1
  [ 5] .shstrtab     	STRTAB	00000000 0002b0 000039 00    	0 0 1
  [ 6] .symtab     	SYMTAB	00000000 0001a4 0000d0 10    	7 7 4
  [ 7] .strtab      	STRTAB	00000000 000274 00003c 00     	0 0 1
解释：


（3）对比两个文件的.symtab，说明两者的不同，尤其shared、swap条目；
Symbol table '.symtab' contains 11 entries:
   Num:    Value  Size Type    Bind   Vis      Ndx Name
     0: 00000000     0 NOTYPE  LOCAL  DEFAULT  UND
     1: 00000000     0 FILE    LOCAL  DEFAULT  ABS 12-2-1.c
     2: 00000000     0 SECTION LOCAL  DEFAULT    1
     3: 00000000     0 SECTION LOCAL  DEFAULT    3
     4: 00000000     0 SECTION LOCAL  DEFAULT    4
     5: 00000000     0 SECTION LOCAL  DEFAULT    6
     6: 00000000     0 SECTION LOCAL  DEFAULT    7
     7: 00000000     0 SECTION LOCAL  DEFAULT    5
     8: 00000000    57 FUNC    GLOBAL DEFAULT    1 main
     9: 00000000     0 NOTYPE  GLOBAL DEFAULT  UND shared
    10: 00000000     0 NOTYPE  GLOBAL DEFAULT  UND swap

Symbol table '.symtab' contains 13 entries:
   Num:    Value  Size Type    Bind   Vis      Ndx Name
     0: 00000000     0 NOTYPE  LOCAL  DEFAULT  UND
     1: 08048094     0 SECTION LOCAL  DEFAULT    1
     2: 08048108     0 SECTION LOCAL  DEFAULT    2
     3: 0804916c     0 SECTION LOCAL  DEFAULT    3
     4: 00000000     0 SECTION LOCAL  DEFAULT    4
     5: 00000000     0 FILE    LOCAL  DEFAULT  ABS 12-2-1.c
     6: 00000000     0 FILE    LOCAL  DEFAULT  ABS 12-2-2.c
     7: 080480cd    57 FUNC    GLOBAL DEFAULT    1 swap
     8: 0804916c     4 OBJECT  GLOBAL DEFAULT    3 shared
     9: 0804916c     0 NOTYPE  GLOBAL DEFAULT    3 __bss_start
    10: 08048094    57 FUNC    GLOBAL DEFAULT    1 main
    11: 0804916c     0 NOTYPE  GLOBAL DEFAULT    3 _edata
12: 08049170     0 NOTYPE  GLOBAL DEFAULT    3 _end

（4）对比两个文件的.strtab，说明两者的不同；
$readelf -x .strtab 12-2-1.o
Hex dump of section '.strtab':
  0x00000000 0031322d 322d312e 63006d61 696e0073 .12-2-1.c.main.s
  0x00000010 68617265 64007377 617000            hared.swap.

Hex dump of section '.strtab':
  0x00000000 0031322d 322d312e 63003132 2d322d32 .12-2-1.c.12-2-2
  0x00000010 2e630073 77617000 73686172 6564005f .c.swap.shared._
  0x00000020 5f627373 5f737461 7274006d 61696e00 _bss_start.main.
  0x00000030 5f656461 7461005f 656e6400          _edata._end.
解释：


（5）对比两个文件的.text，说明两者的不同；
$readelf -x .text 12-2-1.o
Hex dump of section '.text':
 NOTE: This section has relocations against it, but these have NOT been applied to this dump.
  0x00000000 8d4c2404 83e4f0ff 71fc5589 e55183ec 	.L$.....q.U..Q..
  0x00000010 14c745f4 64000000 83ec0868 00000000 	..E.d......h....
  0x00000020 8d45f450 e8fcffff ff83c410 b8000000	.E.P............
  0x00000030 008b4dfc c98d61fc c3                	..M...a..

Hex dump of section '.text':
  0x08048094 8d4c2404 83e4f0ff 71fc5589 e55183ec 	.L$.....q.U..Q..
  0x080480a4 14c745f4 64000000 83ec0868 6c910408 	..E.d......hl...
  0x080480b4 8d45f450 e8100000 0083c410 b8000000 	.E.P............
  0x080480c4 008b4dfc c98d61fc c35589e5 8b45088b 	..M...a..U...E..
  0x080480d4 108b450c 8b0031c2 8b450889 108b4508 	..E...1..E....E.
  0x080480e4 8b108b45 0c8b0031 c28b450c 89108b45 	...E...1..E....E
  0x080480f4 0c8b108b 45088b00 31c28b45 08891090 	....E...1..E....
  0x08048104 5dc3                                	].

（6） 对比两个文件的.rel.text，说明两者的不同；
$readelf -x .rel.text 12-2-1.o
Hex dump of section '.rel.text':
  0x00000000 1c000000 01090000 25000000 020a0000 ........%.......
12-2无.rel.text节。

（7）解释各个目标文件的section，并画图表示出12-2-1.o、12-2-2.o、12-2中的section分布；
$objdump -h 12-2-1.o
12-2-1.o:     file format elf32-i386
Idx 	Name  	Size	VMA	LMA 	File off	Algn
0 	.text 	00000039 	00000000	00000000	00000034	2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
  1 .data  	00000000  00000000  00000000  0000006d  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss	00000000  00000000  00000000  0000006d  2**0
                  ALLOC
  3 .comment	00000036  00000000  00000000  0000006d  2**0
                  CONTENTS, READONLY
  4 .note.GNU-stack 00000000  00000000  00000000  000000a3  2**0
                  CONTENTS, READONLY
  5 .eh_frame	00000044  00000000  00000000  000000a4  2**2
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, DATA

12-2-2.o:     file format elf32-i386
Idx 	Name	Size	VMA	LMA	File off	Algn
  0 .text	00000039	00000000	00000000	00000034	2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data	00000000	00000000	00000000	0000006d	2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss	00000000	00000000	00000000	0000006d	2**0
                  ALLOC
  3 .comment	00000036  00000000	00000000	0000006d	2**0
                  CONTENTS, READONLY
  4 .note.GNU-stack 00000000  00000000  00000000	000000a3	2**0
                  CONTENTS, READONLY
  5 .eh_frame	00000038	00000000	00000000	000000a4	2**2
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, DATA

12-2:     file format elf32-i386
Idx 	Name 	Size   	VMA  	LMA  	File off	Algn
0 	.text  	00000072	08048094	08048094	00000094	2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
1 .eh_frame	00000064 	08048108	08048108	00000108	2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
2 .bss     	00000004 	0804916c	0804916c	0000016c	2**2
                  ALLOC
3 .comment 	00000035 	00000000	00000000	0000016c	2**0
                  CONTENTS, READONLY

(8) 画图表示出12-2-1.o、12-2-2.o中的section与12-2中section的关系；


(9) 反汇编12-2-1.o
$objdump -d 12-2-1.o
找到引用shared、swap的位置；
00000000 <main>:
   0:   8d 4c 24 04        	lea 	0x4(%esp),%ecx
   4:   83 e4 f0           	and 	$0xfffffff0,%esp
   7:   ff 71 fc          	pushl	-0x4(%ecx)
   a:   55                	push	%ebp
   b:   89 e5          	mov	%esp,%ebp
   d:   51             	push	%ecx
   e:   83 ec 14           	sub 	$0x14,%esp
  11:   c7 45 f4 64 00 00 00  movl	$0x64,-0xc(%ebp)
  18:   83 ec 08           	sub	$0x8,%esp
  1b:   68 00 00 00 00     	push	$0x0
  20:   8d 45 f4          	lea 	-0xc(%ebp),%eax
  23:   50                	push	%eax
  24:   e8 fc ff ff ff       	call 	25 <main+0x25>
  29:   83 c4 10         	add 	$0x10,%esp
  2c:   b8 00 00 00 00      	mov 	$0x0,%eax
  31:   8b 4d fc           	mov 	-0x4(%ebp),%ecx
  34:   c9               	leave
  35:   8d 61 fc          	lea  	-0x4(%ecx),%esp
  38:   c3                	ret


(10)查看12-2-1.o的重定位表
$objdump -r 12-2-1.o
解释shared、swap的条目。

12-2-1.o:     file format elf32-i386
RELOCATION RECORDS FOR [.text]:
OFFSET   TYPE   	VALUE
0000001c 	R_386_32 	shared
00000025 	R_386_PC32	swap

RELOCATION RECORDS FOR [.eh_frame]:
OFFSET 	TYPE	VALUE
00000020 	R_386_PC32	.text

(11)反汇编12-2
$objdump -d 12-2
找到引用shared、swap的位置，解释对比2.3的变化。

08048094 <main>:
 8048094:       8d 4c 24 04       	lea  	0x4(%esp),%ecx
 8048098:       83 e4 f0          	and	$0xfffffff0,%esp
 804809b:       ff 71 fc            	pushl	-0x4(%ecx)
 804809e:       55                	push	%ebp
 804809f:       89 e5               	mov	%esp,%ebp
 80480a1:       51                	push	%ecx
 80480a2:       83 ec 14            	sub 	$0x14,%esp
 80480a5:       c7 45 f4 64 00 00 00	movl 	$0x64,-0xc(%ebp)
 80480ac:       83 ec 08          	sub	$0x8,%esp
 80480af:       68 6c 91 04 08       	push	$0x804916c
 80480b4:       8d 45 f4            	lea 	-0xc(%ebp),%eax
 80480b7:       50                 	push 	%eax
 80480b8:       e8 10 00 00 00     	call 	80480cd <swap>
 80480bd:       83 c4 10           	add  	$0x10,%esp
 80480c0:       b8 00 00 00 00      	mov	$0x0,%eax
 80480c5:       8b 4d fc            	mov	-0x4(%ebp),%ecx
 80480c8:       c9                 	leave
 80480c9:       8d 61 fc            	lea 	-0x4(%ecx),%esp
 80480cc:       c3                 	ret


(12)链接12-2-1.o
$ld 12-2-1.o
解释错误原因。

思考题：
1.解释从链接过程中链接视图到执行视图的变化。

2.12-2-1.o和12-2-2.o链接时，同名节会合并，例如两个.text节会合并成一个.text节。那么12-2-1.text和12-2-2.text谁放置在低位地址谁放置在高位地址？链接后的可执行文件12-2中，main、swap两个函数先后次序怎么确定，由什么决定？

3.编译以下6个代码段，编译执行。有些代码段会编译错误。观察6个代码段的差异，并解释原因。
//代码1
char *a="I love China!";
//代码2
char *a;	
a=″I love China!″;
//代码3
char str[14]="I love China!";
//代码4
char str[14];	
str[]=″I love China!″;
//代码5
char a[]="House";	
a[2]='r';
//代码6
char *b="House";
b[2]='r';

答：字符数组由若干个元素组成，每个元素中放一个字符。字符数组存放在可修改节中，数组元素可以修改。
字符指针变量中存放的是地址(字符串第1个字符的地址)，不是将字符串放到字符指针变量中。事实上，代码1/2中的字符串存放在只读节中，字符指针变量中存放的是只读节中字符串第1个字符的地址。只读节中的数据不能修改。
可以对字符指针变量赋值，但不能对数组名赋值，数组名是常量。


库文件

2.1静态库

2.1.1 编译.a 静态库
(1).生成对应的.o 文件：
$gcc -c X.c Y.c
(2).使用ar命令合成静态库：
$ar crs libxy.a x.o y.o
(3).查看编译库使用的gcc 版本：
$strings libxy.a |grep GCC
(4).调用方法：
$gcc main.c -o main libxy.a

2.1.2 链接.a静态库
A源码在进行功能实现的时候，需要用到独立的B源码的接口和功能。那么此时可以将B源码编译成指定的lib库的方式，这里指的的xxx.a的方式，而不是xxx.so的方式。那么在A调用B接口的时候，直接在编译选项中增加-L参数指定需要的库.a文件即可。那么在A中就能直接通过包含的B的头文件对B中的函数进行调用了。

2.2动态库

2.2.1生成共享库
$gcc -shared -fpic -o allvector.so addvec.c multvec.c
-fpic或-fPIC表示生成位置无关的共享库，-fpic产生的代码较小、运行较快，但与平台相关；
-fpie或者-fPIE表示生成位置无关的可执行文件；

2.2.2链接共享库
$gcc -o proglib mainlib.c ./allvector.so
-ldl，表示生成的对象模块需要使用共享库；
-Wl,-rpath=???，指定运行时动态库加载路径；
查看可执行文件库的链接情况：
$ldd可执行文件名方式

2.2.3运行共享库
当加载可执行文件时，通过动态链接器链接共享库，因此必须把共享库放在默认的共享库搜索路径。
可执行文件加载时，有一个.interp节，这个节包含了动态链接器的文件路径。动态链接器也是一个共享库，操作系统负责加载和运行这个动态链接器，然后由这个动态链接器来负责加载共享库。
2.2.4 加载动态链接库
加载动态链接库，首先为共享库分配物理内存，然后在进程对应的页表项中建立虚拟页和物理页面之间的映射。可以认为系统中存在一种引用计数机制， 每当一个进程加载了共享库（在该进程的页表中进行一次映射），引用计数加1；一个进程显式卸载（通过dlclose等）共享库或进程退出时，引用计数减1 。当减少到0时，系统卸载共享库。
2.2.5可执行文件运行时动态链接
除了在可执行文件加载时进行动态链接，也可以在应用程序运行过程中，加载和运行一个共享库，然后进行动态连接。运行时动态连接有两个常见场景：
(1).分发软件包，例如采用共享库来作为一个软件升级包，用户下载这个这个共享库后，替换了旧版本，应用程序运行时，会自动加载这个共享库并进行重新链接。
(2).构建高性能的Web服务器，很多Web服务器接受客户端的请求生成动态的页面内容，早期的做法是创建一个子进程(fork)，然后在这个子进程来生成动态的页面内容，这样的方式性能不是很好，不利于扩展，而高性能的Web服务器则是将每个动态生成页面内容的函数封装成一个共享库，当服务器接受到客户端请求时，会动态链接到合适的函数，然后调用它，这个函数只加载一次，便会缓存在内存中，下一次请求同一个函数时，就是直接获取这个函数指针即可，另外，如果函数发生变化时，不需要重启服务器，只需要重新加载这个共享库就可以了，另外Web服务器也可以动态增加一个新的函数，来满足新的业务需求。
Linux提供了运行时加载共享库的接口，如下所示：
#include <dlfcn.h>
打开一个共享库，返回一个共享库句柄：
void *dlopen(const char*filenames， int flag);
根据一个共享库句柄，查找某个函数名的指针：
void *dlsym(void *handle， char*symbol);
根据共享库句柄，关闭一个共享库，如果没有其它程序引用这个句柄，则卸载这个共享库：
NULL const char *dlerror(void);
用于检查dlopen，dlsym，dlclose操作是不是成功，如果不成功则返回错误信息：
int dlclose(void *handle);

链接器

3.1符号表和符号解析

3.1.1符号表
链接器在生成一个可执行目标文件时，必须完成符号解析，而要进行符号解析，则需要用 到符号表。通常目标文件中都有一个符号表，表中包含了在程序模块中被定义和引用的所有符 号的相关信息。对于某个 C 程序模块 m 来说，包含在符号表中的符号有以下三种不同类型。
在模块 m 中定义并被其他模块引用的全局符号(global symbol)。这类符号包括非静态的函数名和被定义为不带 static 属性的全局变量名。
由其他模块定义并被 m 引用的外部符号(external symbol),包括在其他模块定义的外 部函数名和外部变量名。
在模块 m 中定义并在 m 中引用的本地符号(local symbol)。这类符号包括带 static 属性 的函数名和全局变量名。这类在一个过程(函数)内部定义的带 static 属性的本地变量不在栈 中管理，而是被分配在静态数据区，即编译器为它们在节.data 或.bss 中分配空间。如果在模 块 m 内有两个函数使用了同名 static 本地变量，则需要为这两个变量都分配空间，并作为两个 不同的符号记录到符号表中。
例如，对于以下同一个模块中的两个函数 funcl 和 func2,假定它们都定义了 static 本地变 量％且都被初始化，则编译器在该模块的.data 节中同时为这两个变量分配空间，并在符号表 中构建两个符号
funcl.x 和 func2.x 的关联信息。

1 1 nt funcl ( )
2 {
static 1 nt x =0;
return x;
5 }
6
6 1nt func2()
        7
8	static int x = 1 ；
9	return x ；
10 }
注意上述三类符号不包括分配在栈中的非静态局部变量（auto 变量），链接器不需要这类 变量的信息，因而它们不包含在由节.symtab 定义的符号表中。
例如，对于图 4. 7 给出的两个源程序文件 main.c 和 swap.c 来说，在 main.c 中的全局符号有 buf 和 main,外部符号有 swap；在 swap.c 中的全局符号有 bufpO 和 swap,外部符号有 buf,本地 符号有 bufpl o swap.c 中的知叩是局部变量，是在运行时动态分配的，它不用记录在符号表中。
 
图 3-1 两个源程序文件模块


ELF 文件中包含的符号表中每个表项具有以下数据结构。
typedef struct {
Elf32_Word	st_name；
Elf32_Addr	st_value；
Elf32 顼 ord	st_s1ze；
unsigned char	st_1nfo;
unsigned char	st_other；
Elf32_Half	st_shndx;
字段 st_name 给出符号在字符串表中的索引（字节偏移量），指向在字符串表（.strtab 节） 中的一个以 null 结尾的字符串，即符号。st_value 给出符号的值，在可重定位目标文件中，是 指符号所在位置相对于所在节起始位置的字节偏移量。例如，符号 buf 在.data 节的偏移量为 0;在可执行目标文件和共享目标文件中，则是符号所在的虚拟地址。st_size 给出符号所表示 对象的字节个数。例如，若符号是函数名，则是指函数所占字节个数，若符号是变量，则是指 变量所占字节个数。如果符号表示的内容没有大小或大小未知，则值为 0。
字段 st_info 指出符号的类型和绑定属性，从以下定义的宏可以看出，符号类型占低 4 位, 符号绑定属性占高 4 位。
#define ELF32_ST_BIND(1nfo)	((Info) >> 4)
#def1ne ELF32_ST_TYPE(1 nfo)	(dnfo) & Oxf )
#define ELF32_ST_INFO(b1nd, type) (((bind) < < 4 ) + ( (type)&0xf ))
符号类型可以是未指定(NOTYPE)、变量(OBJECT),函数(FUNC)、节(SECTION) 等。当类型为“节” 时，其表项主要用于重定位。绑定属性可以是本地(LOCAL)、全局 (GLOBAL)、弱(WEAK)等。其中，本地符号指在包含其定义的目标文件的外部是不可见 的，名称相同的本地符号可存在于多个文件中而不会相互干扰。全局符号对于合并的所有目标 文件都可见。弱符号与全局符号类似，但其定义具有较低的优先级，详见 4. 3. 2 节。
字段 st_other 指出符号的可见性。通常在可重定位目标文件中指定可见性，它定义了当符 号成为
可执行目标文件或共享目标库的一部分后访问该符号的方式。字段 st_shndx 用于指出符 号所在节在节头表中的索引。有些符号属于三种特殊伪节(pseudo section)之一，伪节在节头 表中没有相应的表项，无法表示其索引值，因而用以下特殊的索引值表示：ABS 表示该符号不 会由于重定位而发生值的改变，即不应该被重定位；UNDEF 表示未定义符号，即在本模块引 用而在其他模块定义的符号；COMMON 表示还未被分配位置的未初始化的变量。对于 COMMON 类型的符号，其 st.value 字段给出的是对齐要求，而 st_size 给出的是最小长度。
可通过 GNU READELF I 具显示符号表。例如，对于图 4. 7 给出的两个源程序模块文件 main.c 和swap.c,可使用命令 readelf -s main.o 査看 main.。中的符号表，其最后三个表项显示结 果如图 4. 8 所示。


图 3-2  main.o 中部分符号表信息

从显示结果可看岀，main 模块的三个全局符号中，buf 是变量(Type = OBJECT ),它位于 节头表中第三个表项(Ndx=3)对应的.data 节中偏移量为 0 (Value =0)处，占 8 个字节 (Size =8)； main 是函数(Type = FUNC),它位于节头表中第一个表项对应的.text 节中偏移量 为 0 处，占 17 个字节；sawp 是未指定(NOTYPE)且无定义(UND)的符号，说明 swap 是在 main 中被引用的由外部模块定义的符号。
使用 GNU READELF 工具显示可重定位目标文件 swap.。符号表中最后四个表项结果如 图 4. 9 所示。


图 3-3 swap.o 中部分符号表信息

可以看岀，swap 模块的四个符号中有三个全局符号和一个本地符号。其中 bufpO 是全局变 量，它位于节头表中第三个表项对应的.data 节中偏移量为。处，占 4 个字节；buf 是未指定的 且无定义的全局符号，说明 buf 是在 swap 中被引用的由外部模块定义的符号；swap 是函数，它位于节头表中第一个表项对应的.text 节中偏移量为 0 处，占 39 个字节；bufpl 是未分配位置 且未初始化（Ndx=COM）的本地变量，按 4 字节边界对齐，至少占 4 个字节，当 swap 模块被 链接时，bufpl 将作为.bss 节中的一个变量来分配空间。注意，swap 模块中的变量唧是函数 内的局部变量，因而不在符号表中说明。
3.1.2 符号解析
符号解析的目的是将每个模块中引用的符号与某个目标模块中的定义.符号建立关联。每个 定义符号在代码段或数据段中都被分配了存储空间，因此，将引用符号与对应的定义符号建立 关联后，就可以在重定位时将引用符号的地址重定位为相关联的定义符号的地址。
对于在一个模块中定义且在同一个模块中被引用的本地符号，链接器的符号解析会比较容 易进行， 因为编译器会检查每个模块中的本地符号是否具看唯一的定义，所以，只要找到第一 个本地定义符号与之关联即可。对于跨模块的全局符号的解析，则比较困难。
编译器在对源程序编译时，会把每个全局符号输出到汇编代码文件中，每个全局符号或者 是强符号或者是弱符号。汇编器把全局符号的强、弱特性隐含地编码在可重定位目标文件的符 号表中，以供链接时符号解析所需。

全局符号的强、弱特性

强、弱符号的定义如下：函数名和已初始化的全局变量名是强符号，未初始化的全局变量 名是弱符号。例如，在图 4.7 中的两个模块中，main、buf、swap 和 bufpO 是强符号，bufpl 为 本地符号，而本地符号没有强弱之分，temp 则是局部变量，不包含在符号表中。
链接器根据以下强符号和弱符号的处理规则来处理多重定义符号。
规则1:强符号不能多次定义。也即强符号只能被定义一次，否则链接错误。
规则 2：若一个符号被说明为一次强符号定义和多次弱符号定义，则按强符号定义为准。 规则 3：若有多个弱符号定义，则任选其中一个。
例如，对于图 4. 10 所示的两个模块 main.c 和 pl.c,因为强符号*被重复定义了两次，所以 链接器将输出一条出错信息。

图 3-4 两个强符号定义的例子

考察图 3-4 所示例子中的符号 y 和符号 z 的情况。图 3-4 中，符号 y 在 main.c 中是强符号，在 pl.c 中是弱符号，根据规则 2 可知，链接器 将 main.o 符号表中的符号 y 作为其唯一定义符号，而在 pl 模块中的:T 作为引用符号，其地址 等于 main 模块中定义符号 y 的地址，也即这两个'是同一个变量。在 main 函数调用 pl 函数 后，V 的值从初始化的 100 被修改为 200,因而，在 main 函数中用 printf 打印出来后 y 的值为200,而不是 100。




图 3-5 同类型定义符号的例子
对于符号 z,情况也类似。因为符号 z 在 main 和 pl 模块都没有初始化，因此，在两个模块 中都是弱符号，按照规则 3 可知，链接器将其中的一个符号作为唯一定义符号，如果按先后顺 序来定，则链接器将
main 模块中定义的符号 z 作为唯一定义符号，而 pl 模块中的 z 作为引用 符号，符号 z 的地址为 main 模块中定义的地址。在 main 函数调用 pl 函数后，z 的值从 1000 被 修改为 2000,因而，在 main 函数中用printf 打印岀来后 z 的值为 2000,而不是 1000。
上述例子说明，如果在两个不同模块定义相同变量名，那么很可能会发生程序员意想不到 的
结果。特别当两个重复定义的变量具有不同类型时，更容易出现难以理解的结果。例如，对于图3-5 所示的例子，全局变量 d 在 main 模块中为 int 型强符号，在 pl 中是 double 型弱符号。根 据规则2 可知，链接器将 main.。符号表中的符号 d 作为其唯一定义符号，因而其地址和所占字 节数等于 main 模块中定义符号 d 的地址和字节数，因此符号长度为 int 型大小，即 4 个字节， 而不是 double 型变量的8 个字节。由于 pl.c 中的 d 为引用符号，因而其地址与 main 中变量 d 的地址相同，在 main 函数调用 pl 函数后，地址&d 中存放的是 double 型浮点数 1. 0 对应的低 32 位机器数 OOOOOOOOH,地址&x 中存放的是double 型浮点数 1.0 对应的高 32 位机器数 3FF00000H,如图 4. 12c 所示。因而，在 main 函数中用 printf 打印出来后 d 的值为 0,，的值是 1 072 693 2480 可见，的值被 pl.c 中的变量 d 给冲掉了。这里，double型浮点数 1. 0 对应的机 器数为 3FF0 0000 0000 0000H。

对于两个完全相同的结构（struct）类型弱变量，由不同的编译器分别按照不同的对齐规 则进行编译时，链接生成的程序可能会带来无法预料的结果！
上述由于多重定义变量引起的值的改变往往是在没有任何警告的情况下发生的，而且通常 是在程序执行了一段时间后才表现出来，并且远离错误发生源，甚至错误发生源在另一个模 块。对于由成百上千个模块组成的大型程序的开发，这种问题将更加麻烦，如果没有对变量定 义进行规范，那将很难避免这类错误的发生。可以使用相应的选项命令（如-fno-common）来 告诉链接器在遇到多重定义符号时输出警告信息。
解决上述问题的办法是，尽量避免使用全局变量，一定需要用的话，就把全局变量定义为 static, 这样就没有强弱之分，而且不会和其他全局符号产生冲突，如果其他模块需要引用它， 就将它封装成函数。此外，尽量要给全局变量赋初值使其变成强符号，而外部全局变量则尽量 使用 extern。对于程序员来说最好能了解链接器是如何工作的，如果不了解，那么就要养成良 好的编程习惯。

（2）符号解析过程
编译系统通常会提供一种将多个目标模块打包成一个单独的库文件的机制，这个库文件就 是静态库
（static library） o 在构建可执行文件时只需指定库文件名，链接器会自动到库中寻找 那些应用程序用到的目标模块，并且只把用到的模块从库中拷贝出来。
程序中的符号包括变量名和函数名，它们在程序中可能出现在定义处，称为符号的定义; 也可能出现在引用处，称为符号的引用。为叙述方便起见，本教材将定义处的符号和引用处的 符号分别称为定义符号和引用符号。例如，对于图 4. 12 中的符号 d,在 main.c 第 2 行中是定义 符号，其余地方都是引用符号，其中，在 main.c 中有一处（第 8 行）引用，在 pl.c 中有一处 （第 5 行）引用。
链接器按照所有可重定位目标文件和静态库文件出现在命令行中的顺序从左至右依次扫描 它们，在此期间它要维护多个集合。其中，集合 E 是指将被合并到一起组成可执行文件的所有 目标文件集合；集合 U 是未解析符号的集合，未解析符号是指还未与对应定义符号关联的引用 符号；集合。是指当前为止已被加入到 E 的所有目标文件中定义符号的集合。
符号解析开始时，集合 E、U、。中都是空的。然后按照以下过程进行符号解析。
对命令行中的每一个输入文件链接器确定它是目标文件还是库文件，如果它是目标 文件，就把/ 加入到 E,根据，中未解析符号和定义符号分别对 0、。集合进行修改，然后处理 下一个输入文件。例如， 对于图 4. 12 中的符号 d,在处理 main.0 文件时，因为 d 是定义符号， 所以 d 被加入到 D 中；而对于 d 的引用，因为是可以与 d 的定义关联的，故 d 不被加入到 U 中。然后，再处理目标文件 pl.o,因为其对 d 的引用可以与。中已有的定义符号 d 建立关联， 因此，也不会将 d 加入到〃中。
如果/是一个库文件，链接器会尝试把 U 中的所有未解析符号与/中各目标模块定义的 符号进行匹配。如果某个目标模块 m 定义了一个〃中的未解析符号 x, 那么就把 m 加入到 E 中，并把符号，从"移入〃中。不断地对 f 中的所有目标模块重复这个过程直到 U 和 D 不再变 化为止。那些未加入到 E 中的里的目标模块就被简单地丢弃，链接器继续处理下一输入文件。如果处理过程中往 D 加入一个已存在的符号或者当扫描完所有输入文件时〃非空，链 接器报错并停止动作。否则，它把 E 中的所有目标文件进行重定位后合并在一起，以生成可执 行目标文件。

3.2静态链接过程
将一个程序的所有关联模块对应的目标代码文件结合在一起，以形成一个可执行文件的过程称为链接(linking)。链接器位于编译器、指令集体系结构和操作系统的交叉点上，涉及到指令系统、代码生成、机器语言、程序转换和虚拟存储管理等诸多概念，因而它对于理解整个计算机系统概念来说是非常重要的。

图3-6 编译过程
操作命令：
$gcc -E -o hello.i hello.c	
对应cpp命令
$gcc -S -o hello.s hello.i	
对应ccl命令
$gcc -c -o hello.o hello.s	
对应as命令
$gcc -o hello hello.o		
对应ld命令。
包含多个源代码文件工程的编译链接过程，多个源代码文件工程的编译链接过程如图3-7所示。

图3-7 多个源代码文件工程的编译链接过程

从程序员的角度，尽量编写没有漏洞的正确代码；从编译器和操作系统方面，己经采取了多种机制，例如地址空间随机化、栈破坏检测盒可执行代码区域限制等方式。

3.2.1符号解析
符号解析也称为符号绑定，将每个模块(可重定位文件)中的符号引用与某个目标模块(可能是本模块，也可能是其它模块)中的符号定义建立关联。通常，符号定义意味着要在内存中分配一块内存，而符号对应的内存地址就是这块内存的首地址。引用符号时(访问变量、函数跳转等)需要获得该符号对应的内存地址，以作寻址之用。然而此时符号最终在虚拟地址空间中的地址(链接地址)还未确定，所以需要把出现的所有符号引用与所引用的符号建立关联。为了给符号解析提供方便，可重定位文件使用.rel.text、.rel.data等节记录源文件中出现的所有符号引用，使用.symtab节记录符号信息。链接器根据这些节构建定义与符号引用之间的关联。

3.2.2同节合并
在虚拟地址空间中，可重定位文件文件的同类节被拼接到了一起，如下图所示。这里的空间是指虚拟地址空间，而不是实际的文件存储空间。 
      
图3-8 同节合并及虚拟地址空间

主要关注Size和VMA(Virtual Memory Address虚拟地址)，可以简单看出如下几个特性：
a.o和b.o中的虚拟地址为0，也就是在未链接之前的目标文件虚拟地址为0；而链接以后会产生虚拟地址，这个虚拟地址是随着平台的变化而变化的，但在一个平台下面一般是统一的；
$gcc a.c b.c -c -fno-stack-protector
$objdump -h a.o
Idx Name          Size      VMA       LMA       File off  Algn
0 .text         00000039  00000000  00000000  00000034  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
1 .data         00000000  00000000  00000000  0000006d  2**0
                  CONTENTS, ALLOC, LOAD, DATA
2 .bss          00000000  00000000  00000000  0000006d  2**0
                  ALLOC
$objdump -h b.o
Idx Name          Size      VMA       LMA       File off  Algn
0 .text         00000032  00000000  00000000  00000034  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
1 .data         00000004  00000000  00000000  00000068  2**2
                  CONTENTS, ALLOC, LOAD, DATA
2 .bss          00000000  00000000  00000000  0000006c  2**0
                  ALLOC 
ab的.text代码节大小等于a.o和b.o代码节大小相加。也就是两个目标文件的代码段合并成了链接后文件的代码节。这也印证了同节合并示意图4。 
$ld a.o b.o -e main -o ab
$objdump -h ab
Idx Name          Size      VMA       LMA       File off  Algn
0 .text         0000006b  08048094  08048094  00000094  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
1 .eh_frame     00000064  08048100  08048100  00000100  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
2 .data         00000004  08049164  08049164  00000164  2**2
                  CONTENTS, ALLOC, LOAD, DATA
3 .comment      00000035  00000000  00000000  00000168  2**0
                  CONTENTS, READONLY
将上面的目标文件的地址分配过程具现化，就是下面这张图的效果。左边是链接前的目标文件节图，中间是链接后的可执行文件节图，右边是可执行文件的虚拟内存中的内存分布。可以看出，链接前的目标文件对应节合并在一起，（如0x34+0x3e=0x72)，构成链接后的可执行文件，然后在运行的时候将这个整合的段一起映射到虚拟内存中。 

图3-9 同节合并

3.2.3确定地址
每个符号引用会对应到具体的节，以及在节中的偏移。因此，当节链接过程中进行合并时，可以通过这个偏移量去重新定位符号的位置，从而修正符号在可执行文件中的地址。
通过符号查询语句readelf -s，可以获得main符号的位置是代码段的起始位置。那么在进行链接合并以后，因为a.o中的代码段在前面(ld的先后顺序很重要)，所以main其实也相当于ab的代码段的起始位置。因为ab的代码段被映射到0x08048094，因此main符号在ab中的地址就是0x08048094，同样我们可以使用readelf -s进行查看。
同样的方法也可以定位swap、shared符号的地址。

3.2.4修改引用
将多个可重定位文件中的代码段和数据段分别合并为一个单独的代码段和数据段；
合并之后，谁排在前谁排在后就已经确定，进而可以确定每个定义的符号所对应的在虚拟地址空间中的地址(链接地址)；
符号对应的地址确定后，根据符号解析时构建的联系，将符号引用处的地址修改为相应符号对应的地址。
重定位的两种方式：
R_386_PC32：指明引用处采用相对寻址方式，即有效地址为PC内容加上重定位后的32位地址，PC的内容是下条指令地址。例如，调用指令中的转移目的地址就来用相对寻址方式；
R_386_32：指明引用处采用绝对地址方式，即有效地址就是重定位后的32位地址。

3.2.5实验:程序的静态链接过程

3.2.5.1 链接程序-重定位
程序13-1-1.c和13-1-2.c如下：
//13-1-1.c
void swap();
int buf[2]={1， 2};
int main(){
	swap();
	return 0;
}

//13-1-2.c
extern int buf[];
int *bufp0=&buf[0];
static int *bufp1;
void swap(){
	int temp;
	bufp1 = &buf[1];
	temp = *bufp0;
	*bufp0 = *bufp1;
	*bufp1 = temp;
}
（1）生成可重定位目标文件13-1-1.o：
$gcc -c 13-1-1.c -o 13-1-1.o
观察13-1-1.o中的符号，并填写下表：
$readelf -s 13-1-1.o
对13-1-2.c生成可重定位目标文件13-1-2.o，观察其中的符号并填写下表：
(2)反汇编13-1-1.o，观察其中的引用，并填写下表：
$objdump -d -r 13-1-1.o
反汇编13-1-2.o，观察其中有几次引用，并填写下表：
查看13-1-1.o的.text 的重定位表.rel.text：
$readelf -a 13-1-1.o
Relocation section '.rel.text' at offset 0x1a4 contains 1 entries:
 Offset     Info    	Type     	Sym.Value  Sym. Name
00000012  	00000a02 	R_386_PC32 	00000000   swap

Relocation section '.rel.eh_frame' at offset 0x1ac contains 1 entries:
 Offset  	Info    	Type         	Sym.Value  Sym. Name
00000020  00000202 	R_386_PC32   	00000000   .text
作业截图1 main.o的重定位表
查看13-1-2.o的.text 的重定位表.rel.text：

作业截图2. swap.o的重定位表
(3)反汇编13-1-1.o，用红线画出的需要符号重定位的内容，解释这些条目。

作业截图3. main.o的重定位信息
反汇编13-1-2.o，用红线画出的需要符号重定位的内容，解释这些条目。

作业截图3. main.o的重定位信息

(4)链接程序
$ld 13-1-1.o 13-1-2.o -e main -o 13-1
观察.text、.data、.bss、.rodata各个节链接前后的地址分配情况：

画出链接前后各节地址分配的变化情况：

(5)确定链接生成的可执行目标文件中main函数08048094、swap函数代码起始地址080480b8，以及buf 0x08049154、bufp0、bufp1 08049160的存储地址。上述符号重定位后，1.3中需要符号重定位的内容应该是什么？

(6)填写下表，观察各个符号在重定位前后值的变化？


(7)利用objdump -d -r -j .text ./13-1 > 13-1.s反汇编13-1，验证上一步计算是否正确。(给出截图并用红框注明对应的内容）

作业截图7. 重定位后的main和swap函数

3.2.5.2 静态标准库
源文件如下：
//13-2-1.c
#include <stdio.h>
void test(void){
printf("test obj， add by wzu\n");
return;
}

//13-2-1.h
#ifndef _OBJ_TEST_H
#define _OBJ_TEST_H
extern void test(void);
#endif  

//13-2-2.c
#include ”obj_add.h“
int main(void){      
test();
return 0;
}
（1）编译13-2-1.c，生成目标文件13-2-1.o：
$gcc -c 13-2-1.c -o 13-2-1.o

作业截图8. 编译13-2-1.c
（2）从/usr/lib/i386-linux-gnu/中把libc.a复制到/home/xx目录下：
$cp /usr/lib/i386-linux-gnu/libc.a /home/xx
查看libc.a：
$ar -t libc.a

作业截图9. 查看libc.a
查看libc.a的符号表：
$objdump -t libc.a | grep printf

作业截图10. 查看libc.a的符号表

（3）解压libc.a，可以看到目录下解压出很多.o文件：
$ar -x libc.a

作业截图11. 解压后的libc.a的文件
（4）第一次编译13-2-2.c：
$gcc -c -fno-builtin 13-2-2.c -o 13-2-2.o
链接13-2-2.o和13-2-1.o、printf.o：
$ld 13-2-2.o 13-2-1.o printf.o

作业截图11. 链接结果
解释这个现象：


（5）把目标文件13-2-1.o放到/home/xx目录下，在/home/xx目录下生成新的libc.a：
$ar -rcs libc.a *.o 

  作业截图12. 生成新的libc.a
（6）用新生成的libc.a替换原libc.a：
$sudo cp libc.a /usr/lib/i386-linux-gnu/libc.a -i   
/usr/lib/ i386-linux-gnu /libc.a被覆盖掉。

  作业截图13. 覆盖掉libc.a

$gcc -static 13-2-2.c -o 13-2-2

  作业截图14. 第二次编译13-2-2.c
（8）执行编译的可执行程序，看运行结果：
$./13-2-2
test obj，add by wzu

  作业截图15. 编译执行
（9）查看13-2-2的符号表和重定位符号表：

  作业截图16. 查看13-2-2的符号表和重定位符号表
（10）第三次编译13-2-2.c：
$gcc -static --verbose -fno-builtin 13-2-2.c -o 13-2-2

作业截图17. 第三次编译13-2-2.c
解释编译过程的输出：

3.2.5.3.静态库
源文件13-3.c如下，main函数里面调用libA.a(A.c)里面的函数A()和libB.a(B.c)里面的函数B()，函数A()和B()分别调用了libC.a(C.c)里面的函数funcC1()和函数funcC2()。
//13-3.c
#include "A.h"
#include "B.h"
int main() {
    A();
    B(); 
    return 0;
}

//A.h
void A();

//A.c
#include "C.h"
void A() {
    funcC1();
}

//B.h
void B();

//B.c
#include "C.h"
int B() {
    funcC2();
}
 
//C.h
void funcC1();
void funcC2();
void funcC3();

//C.c
#include "C.h"
#include <stdio.h>
void funcC1() {
    printf("this is function C1.\n");
}
 
void funcC2() {
    printf("this is function C2.\n");
}
 
void funcC3() {
    printf("this is function C3.\n");
}
（1）将A.c编译成libA.a，B.c编译成libB.a，C.c编译成libC.a。 

作业截图18. 编译静态库
（2）按以下命令链接13-3.o和libA .a、libB.a和libC.a；
$gcc 13-3.o -L./ -lC -L./ -lA -L./ -lB
结果怎么样？给出解释。

作业截图19. 第一次链接静态库
报错如下：testA()和testB()中使用的funcA()和funcB()未定义。
解释：对于未定义的符号，默认从左向右逐个查找链接库列表，不向左查找。

（3）按以下命令链接13-3.o和libA.a、libB.a和libC.a；
$gcc 13-3.o -L./ -lA -L./ -lB -L./ -lC
链接成功，使用'nm'命令查看目标文件，会看到libC.a里面没有使用到的funcC3()也被加载到目标文件里面了。

作业截图20. 第二次链接静态库
解释：即使只使用到静态库中的部分函数，静态库也会被全量加载至目标文件中。

（4）按以下命令链接13-3.o和libC.a、libA.a和libB.a；
$gcc 13-3.o -L./ -lA -L./ -lC -L./ -lB -L./ -lC -L./ -lA
链接成功，使用’nm’命令查看目标文件，和上一步生成的目标文件相同。

作业截图21. 第三次链接静态库
结论：静态库在链接列表中可以重复出现，但目标文件中只会加载一份。
（5）按以下命令链接13-3.o和libC.a、libA.a和libB.a；
$gcc 13-3.o -L./ -lA -L./ -lB -L./ -lC

作业截图22. 第四次链接静态库
链接成功，使用‘nm’命令查看目标文件，函数testA()并没有加载到目标文件中。

思考题：
1.为什么静态库里的目标文件，往往都只定义了一个函数？
2.为什么在外部引用时要加入其头文件，例如使用printf()时要加入<stdio.h>？
APPENIDIX	K
OBJCOPY
K.1 objcopy命令
GNU实用工具程序objcopy拷贝一个目标文件的内容到另一个目标文件中。Objcopy使用GNU BFD库去读或写目标文件，可以使用不同于源目标文件的格式来写目的目标文件，即可以将一种格式的目标文件转换成另一种格式的目标文件。Objcopy在进行目标文件的转换时，将生成一个临时文件，转换完成后就将这个临时文件删掉。Objcopy使用BFD做转换工作。如果没有明确地格式要求，则Objcopy将访问所有在BFD库中已经描述了的并且它可以识别的格式。
通过使用srec作为输出目标(使用命令行选项-o srec)，Objcopy可以产生S记录格式文件。
通过使用binary作为输出目标(使用命令行选项-o binary)，Objcopy可以产生原始的二进制文件。使用Objcopy产生一个原始的二进制文件，实质上是进行了一回输入目标文件内容的内存转储。所有的符号和重定位信息都将被丢弃。内存转储起始于输入目标文件中那些将要拷贝到输出目标文件去的部分的最小虚地址处。
使用Objcopy生成S记录格式文件或者原始的二进制文件的过程中，-S选项和-R选项可能会比较有用。-S选项是用来删掉包含调试信息的部分，-R选项是用来删掉包含了二进制文件不需要的内容的那些部分。
K.2 objcopy选项
--infile/outfile：源文件/目标文件，如果不指定目标文件那么objcopy将会创建一个临时文件，并且将其命名为源文件；
-I bfdname/--input-target=bfdname：指定输入文件的bfdname,可取值elf32-little，elf32-big等；
-O bfdname/--output-target=bfdname：指定输出文件的bfdname；
-F bfdname/--target=bfdname：指定输入、输出文件的bfdname，目标文件格式，只用于在目标和源之间传输数据，不转换； 
-j sectionname/--only-section=sectionname：只将由sectionname指定的section拷贝到输出文件，可以多次指定，并且注意如果使用不当会导致输出文件不可用； 
-R sectionname/--remove-section=sectionname：从输出文件中去除掉由sectionname指定的section，可以多次指定，并且注意如果使用 不当会导致输出文件不可用； 
-S/--strip-all：不从源文件拷贝符号信息和relocation信息；
-g/--strip-debug：不从源文件拷贝调试符号信息和相关的段。对使用-g编译生成的可执行文件执行之后，生成的结果和不用-g进行编译生成可执行文件一样； 
--strip-unneeded：去掉所有重定位处理不需要的符号； 
-K symbolname/--keep-symbol=symbolname：strip的时候，保留由symbolname指定的符号信息。可以指定多次；
-N symbolname/--strip-symbol=symbolname：不拷贝由symbolname指定的符号信息，可以多次指定；
-G symbolname/--keep-global-symbol=symbolname：保留symbolname为全局的，让其他的都是文件局部的变量这样外部不可见，这个选项可以多次指定； 
--globalize-symbol=symbolname：让变量symbolname变成全局范围，这样它可以在定义它的文件外部可见。可以多次指定；
-L symbolname/-localize-symbol=symbolname：将变量symbolname变成文件局部的变量。可以多次指定； 
-W symbolname/--weaken-symbol=symbolname：弱化变量；
-w/--wildcard：允许对其他命令行项中的symbolnames使用正则表达式。问号(?)、星号(*)、反斜线(\)和中括号([])操作可以用在标号名称的任何位置。如果标号的第一个字符是感叹号(!)，那么表示相反的含义，例如：
-w -W !foo -W fo* 
表示objcopy将要弱化所有以"fo"开头的标号，但是除了标号"foo"； 
-x/--discard-all：不从源文件中拷贝非全局变量； 
-X/--discard-locals：不拷贝编译生成的局部变量(一般以L或者..开头) ； 
-b byte/--byte=byte：只保留输入文件的每个第byte个字节(不会影响头部数据)。byte的范围可以是0到 interleave-1。这里，interleave通过-i选项指定，默认为4。将文件创建成程序rom的时候，这个命令很有用。经常用于srec输出目标；
-i interleave/--interleave=interleave：每隔interleave字节拷贝1 byte。通过-b选项指定选择哪个字节，默认为4。如果不指定-b那么objcopy会忽略这个选项。 
--gap-fill val：在section之间的空隙中填充val；
--set-start val：设定新文件的起始地址为val，并不是所有格式的目标文件都支持设置起始地址；
--change-start incr/--adjust-start incr：通过增加incr量来调整起始地址，并不是所有格式的目标文件都支持设置起始地址；
--change-address incr/--adjust-vma incr：通过增加incr量调整所有sections的VMA(virtual memory address)和LMA(linear  memory address)，以及起始地址；
--change-section-address section{=,+,-}val/--adjust-section-vma section{=,+,-}val：调整指定section的VMA/LMA地址； 
--set-section-flags section=flag：指定指定section的flag。flag的取值可以alloc、contents、load、noload、readonly、code、data、rom、share、debug。可以设置一个没有内容的节的flag，但是清除一个有内容的节的flag是没有意义的--应当把相应的节移除。并不是所有的flags对于所有的目标文 件都有意义；
--add-section sectionname=filename：在拷贝文件的时候，添加一个名为sectionname的section，该section的内容为filename 的内容，大小为文件大小。这个选项只在那些可以支持任意名称section的文件好用；
--rename-section oldname=newname[,flags]：更改section的名。将一个section的名字从oldname更改为newname，同时也可以指定更改其flags。这个在 执行linker脚本进行重命名的时候，并且输出文件还是一个目标文件并不成为可执行的连接 文件，这个时候很有优势。
这个项在输入文件是binary的时候很有用，因为这经常会创建一个名称为.data的 section，例如，你想创建一个名称为.rodata的包含二进制数据的section，这时候，你可以使用如下命令：
objcopy -I binary -O <output_format> -B <architecture> \
--rename-section .data=.rodata,alloc,load,readonly,data,contents \ 
 <input_binary_file> <output_object_file> 
--add-gnu-debuglink=path-to-file：创建一个.gnu_debuglink节，这个节包含一个特定路径的文件引用，并且把它添加到输出文件中；
--only-keep-debug：对文件进行strip，移走所有不会被--strip-debug移走的section，并且保持调试相关的 section原封不动。
K.3 objcopy举例
(1).将图像编译到可执行文件内
Q: 如何将一个二进制文件，比如图片、词典一类的东西做为.o文件，直接链接到可执行文件内部？
$ objcopy -I binary -O elf32-i386 -B i386 14_95_13.jpg image.o
$ gcc image.o tt.o -o tt
$ nm tt | grep 14_95
0805d6c7 D _binary_14_95_13_jpg_end
00014213 A _binary_14_95_13_jpg_size
080494b4 D _binary_14_95_13_jpg_start
(2).使用objcopy把不用的信息去掉
$ objcopy -R .comment -R .note halo halo.min


3.3动态链接过程
3.3.1符模块内的过程调用、跳转
3.3.2符模块内数据访问
3.3.3符模块外的过程调用、跳转
3.3.4符模块外的数据访问

3.3.5实验:程序的动态链接过程

3.3.5.1 共享库.so文件的结构
输入以下源代码14-1.c：
//14-1-1.c
static int a;
extern int b;
extern void ext();
void bar(){
   a=1;
   b=2;
}

void foo(){
   bar();
   ext();
}

//14-1-2.c
int b;
void ext(){
   b=1;
}

//14-1-3.c
extern void foo();
int main(){
   foo();
return 0;
}
（1）分别编译14-1-1.c、14-1-2.c成共享库lib1.so、lib2.so，编译14-1-3.c可执行文件3。
$gcc -shared -fPIC 14-1-1.c -o lib1.so
$gcc -shared -fPIC 14-1-2.c -o lib2.so
$gcc 14-1-3.c -o 14 ./lib1.so ./lib2.so

（2）查看lib1.so的文件头，注意查看程序启动时的入口地址，截图并解释其不同之处。
ELF Header:
  Magic:   7f 45 4c 46 01 01 01 00 00 00 00 00 00 00 00 00
  Class:                        	ELF32
  Data:                         	2's complement, little endian
  Version:                     	1 (current)
  OS/ABI:                       	UNIX - System V
  ABI Version:                  	0
  Type:                          	DYN (Shared object file)
  Machine:                        	Intel 80386
  Version:                         	0x1
  Entry point address:             	0x420
  Start of program headers:      	52 (bytes into file)
  Start of section headers:       	5912 (bytes into file)
  Flags:                        	0x0
  Size of this header:          	52 (bytes)
  Size of program headers:      	32 (bytes)
  Number of program headers:    	7
  Size of section headers:        	40 (bytes)
  Number of section headers:      	28
  Section header string table index: 	25

(3)查看lib1.so的节头表，注意查看其中.text的虚拟地址，截图并解释其不同之处。
There are 28 section headers, starting at offset 0x1718:
Section Headers:
  [Nr] Name	Type   	Addr 	Off	Size  	ES Flg Lk Inf　Al
  [ 0]  	NULL 	00000000 	000000 000000 00 　	0 0 	0
  [ 1] .note.gnu.build-iNOTE	00000114	000114 000024 00	A	0	0	4
  [ 2] .gnu.hash	GNU_HASH00000138 000138 000040 04 A 3 0  4
  [ 3] .dynsym	DYNSYM	00000178 000178 0000f0 10 　A 4 1  4
  [ 4] .dynstr 	STRTAB 	00000268 000268 0000b1 00  A 0 0 	1
  [ 5] .gnu.version   	VERSYM 	0000031a 00031a 00001e 02 　A 3 0 　2
  [ 6] .gnu.version_r 	VERNEED00000338 000338 000020 00 　A 4 1  4
  [ 7] .rel.dyn   	REL	00000358 000358 000048 08  A 3 0  4
  [ 8] .rel.plt     	REL	000003a0 0003a0 000010 08 　AI 3 21 4
  [ 9] .init         	PROGBITS000003b0 0003b0 000023 00  AX 0 0  4
  [10] .plt       	PROGBITS000003e0 0003e0 000030 04AX　0　0 16
  [11] .plt.got  	PROGBITS00000410 000410 000010 00  AX 0 0  8
  [12] .text   	PROGBITS00000420 000420 00017d 00  AX 0 0 16
  [13] .fini      	PROGBITS000005a0 0005a0 000014 00  AX 0 0  4
  [14] .eh_frame_hdr 	PROGBITS000005b4 0005b4 00002c 00  A  0 0  4
  [15] .eh_frame     	PROGBITS000005e0 0005e0 000098 00  A  0 0  4
  [16] .init_array  	INIT_ARRAY00001efc 000efc 000004 00 　WA 0 0 4
  [17] .fini_array  	FINI_ARRAY00001f00 000f00 000004 00  WA 0 0 4
  [18] .jcr      	PROGBITS00001f04 	000f04 000004 00  WA  0 0 4
  [19] .dynamic   	DYNAMIC00001f08 	000f08 0000e0 08  WA  4 0 4
  [20] .got      	PROGBITS00001fe8 	000fe8 000018 04  WA  0 0 4
  [21] .got.plt    	PROGBITS00002000　001000 000014 04 	WA 0 0 4
  [22] .data     	PROGBITS00002014　001014 000004 00	WA 0 0 4
  [23] .bss       	NOBITS00002018 	001018 000008 00WA	0　0　4
  [24] .comment   	PROGBITS00000000　001018 000035 01MS0　0　1
  [25] .shstrtab   	STRTAB	00000000 	00162c 0000ec 00 0 0 1
  [26] .symtab      	SYMTAB	00000000 	001050 0003e0 10　27 48 4
  [27] .strtab     	STRTAB	00000000 	001430 0001fc 00　0 0 1
Key to Flags:
  W (write), A (alloc), X (execute), M (merge), S (strings)
  I (info), L (link order), G (group), T (TLS), E (exclude), x (unknown)
  O (extra OS processing required) o (OS specific), p (processor specific)


（4）查看lib1.so的符号表，注意符号a、b、ext、bar、foo，截图并解释其不同之处。
Symbol table '.symtab' contains 62 entries:
   Num:    Value  Size Type    Bind   Vis      Ndx Name
     0: 00000000	0 	NOTYPE 	LOCAL  DEFAULT 	UND
     1: 00000114  	0 	SECTION 	LOCAL  DEFAULT    1
     2: 00000138  	0 	SECTION 	LOCAL  DEFAULT    2
     3: 00000178 	0 	SECTION 	LOCAL  DEFAULT    3
     4: 00000268  	0 	SECTION 	LOCAL  DEFAULT    4
     5: 0000031a  	0 	SECTION 	LOCAL  DEFAULT    5
     6: 00000338 	0 	SECTION 	LOCAL  DEFAULT    6
     7: 00000358  	0 	SECTION 	LOCAL  DEFAULT    7
     8: 000003a0  	0 	SECTION 	LOCAL  DEFAULT    8
     9: 000003b0 	0 	SECTION 	LOCAL  DEFAULT    9
    10: 000003e0 	0 	SECTION 	LOCAL  DEFAULT   10
    11: 00000410 	0 	SECTION 	LOCAL  DEFAULT   11
    12: 00000420 	0 	SECTION 	LOCAL  DEFAULT   12
    13: 000005a0 	0 	SECTION 	LOCAL  DEFAULT   13
    14: 000005b4  	0 	SECTION 	LOCAL  DEFAULT   14
    15: 000005e0  	0 	SECTION 	LOCAL  DEFAULT   15
    16: 00001efc  	0 	SECTION 	LOCAL  DEFAULT   16
    17: 00001f00  	0 	SECTION 	LOCAL  DEFAULT   17
    18: 00001f04 	0 	SECTION 	LOCAL  DEFAULT   18
    19: 00001f08 	0 	SECTION 	LOCAL  DEFAULT   19
    20: 00001fe8   	0 	SECTION 	LOCAL  DEFAULT   20
    21: 00002000 	0 	SECTION 	LOCAL  DEFAULT   21
    22: 00002014  	0 	SECTION 	LOCAL  DEFAULT   22
    23: 00002018  	0 	SECTION 	LOCAL  DEFAULT   23
    24: 00000000  	0 	SECTION 	LOCAL  DEFAULT   24
    25: 00000000  	0 	FILE    	LOCAL  DEFAULT  ABS crtstuff.c
    26: 00001f04  	0　OBJECT　LOCAL  DEFAULT   18 __JCR_LIST__
    27: 00000430 	0　FUNC　LOCAL  DEFAULT   12 deregister_t...
    28: 00000470　	0　FUNC　LOCAL  DEFAULT   12 register_tm_cl..
    29: 000004c0　	0　FUNC　LOCAL  DEFAULT   12 __do_glo..
    30: 00002018　	1　OBJECT　LOCAL  DEFAULT   23 completed.7209
    31: 00001f00　	0　OBJECT　LOCAL  DEFAULT   17 __do_globa..
    32: 00000510  	0　FUNC　LOCAL  DEFAULT   12 frame_dummy
    33: 00001efc  	0　OBJECT　LOCAL  DEFAULT   16 __frame_dummy..
    34: 00000000 	0　FILE　LOCAL  DEFAULT  ABS 14-1-1.c
    35: 0000201c  	4　OBJECT　LOCAL  DEFAULT   23 a
    36: 00000000  	0　FILE　LOCAL  DEFAULT  ABS crtstuff.c
    37: 00000674  	0　OBJECT　LOCAL  DEFAULT   15 __FRAME_END__
    38: 00001f04  	0　OBJECT　LOCAL  DEFAULT   18 __JCR_END__
    39: 00000000  	0　FILE 　LOCAL  DEFAULT  ABS
    40: 00000420  	4　FUNC　LOCAL  DEFAULT   12 __x86.get_pc_...
    41: 0000054c  	0　FUNC　LOCAL  DEFAULT   12 __x86.get_pc_t...
    42: 00002014 	0　OBJECT 　LOCAL  DEFAULT   22 __dso_handle
    43: 00000599  	0　FUNC　LOCAL  DEFAULT   12 __x86.get_pc_t..
    44: 00001f08   	0　OBJECT 　LOCAL  DEFAULT   19 _DYNAMIC
    45: 000005b4 	0　NOTYPE　LOCAL  DEFAULT   14 __GNU_EH_F...
    46: 00002018 	0　OBJECT 　LOCAL  DEFAULT   22 __TMC_END__
    47: 00002000 	0　OBJECT 　LOCAL  DEFAULT   21 _GLOBAL_OF...
    48: 00000000 	0　NOTYPE　WEAK　DEFAULT  UND _ITM_deregiste..
    49: 00000000  	0　NOTYPE　GLOBAL DEFAULT  UND b
    50: 00002018 	0　NOTYPE　GLOBAL DEFAULT   22 _edata
    51: 00000550  	38　FUNC　GLOBAL DEFAULT   12 bar
    52: 000005a0  	0　FUNC　GLOBAL DEFAULT   13 _fini
    53: 00000000 	0　FUNC　WEAK 	DEFAULT  UND __cxa_final..
    54: 00000000 	0　NOTYPE　WEAK　DEFAULT  UND __gmon_start__
    55: 00000576 	35　FUNC　GLOBAL DEFAULT   12 foo
    56: 00000000  	0　NOTYPE　GLOBAL DEFAULT  UND ext
    57: 00002020 	0　NOTYPE　GLOBAL DEFAULT   23 _end
    58: 00002018 	0　NOTYPE　GLOBAL DEFAULT   23 __bss_start
    59: 00000000  	0　NOTYPE　WEAK　DEFAULT  UND _Jv_Registe...
    60: 00000000  	0　NOTYPE　WEAK　DEFAULT  UND _ITM_registerT..
    61: 000003b0 	0　FUNC　GLOBAL DEFAULT    9 _init

（5）查看lib1.so的重定位节，截图并解释其不同之处。
Relocation section '.rel.dyn' at offset 0x358 contains 9 entries:
Offset  	Info    	Type            	Sym.Value	Sym. Name
00001efc  00000008 	R_386_RELATIVE
00001f00	00000008 	R_386_RELATIVE
00002014	00000008 	R_386_RELATIVE
00001fe8	00000106	R_386_GLOB_DAT	00000000 _ITM_deregist
00001fec	00000206	R_386_GLOB_DAT	00000000 b
00001ff0	00000306	R_386_GLOB_DAT	00000000 __cxa_f@GLIBC_2..
00001ff4  	00000406 	R_386_GLOB_DAT   	00000000 __gmon_start__
00001ff8	00000606	R_386_GLOB_DAT	00000000   _Jv_Register
00001ffc	00000706	R_386_GLOB_DAT	00000000   _ITM_registerTMCl
注意在节头表中.got节的长度0x18，0x18/4=6，正好是'.rel.dyn'节中R_386_GLOB_DAT类型数据的项数。

Relocation section '.rel.plt' at offset 0x3a0 contains 2 entries:
 Offset     Info    Type            Sym.Value  Sym. Name
0000200c  00000907 R_386_JUMP_SLOT   00000550   bar
00002010  00000507 R_386_JUMP_SLOT   00000000   ext
注意在节头表中 .got.plt节的长度0x14，0x14/4=5，GOT[0]、GOT[1]、GOT[2]和bar、ext共5项。


（6）查看lib1.so的程序头表并截图，画图示意各节分布并解释。
Elf file type is DYN (Shared object file)
Entry point 0x420
There are 7 program headers, starting at offset 52
Program Headers:
  Type           	Offset 	VirtAddr 	PhysAddr   FileSiz MemSiz  Flg Align
  LOAD           	0x000000 	0x00000000 0x00000000 0x00678 0x00678 R E 0x1000
  LOAD           	0x000efc 	0x00001efc 0x00001efc 0x0011c 0x00124 RW  0x1000
  DYNAMIC        	0x000f08 	0x00001f08 0x00001f08 0x000e0 0x000e0 RW  0x4
  NOTE           	0x000114 	0x00000114 0x00000114 0x00024 0x00024 R   0x4
  GNU_EH_FRAME	0x0005b4 	0x000005b4	0x000005b4	0x0002c 0x0002c R 	 0x4
  GNU_STACK      	0x000000 	0x00000000 0x00000000 0x00000 0x00000 RW  0x10
  GNU_RELRO      	0x000efc 	0x00001efc 0x00001efc 0x00104 0x00104 R    0x1
 Section to Segment mapping:
  Segment Sections...
00     .note.gnu.build-id .gnu.hash .dynsym .dynstr .gnu.version .gnu.version_r .rel.dyn .rel.plt .init .plt .plt.got .text .fini .eh_frame_hdr .eh_frame
   01     .init_array .fini_array .jcr .dynamic .got .got.plt .data .bss
   02     .dynamic
   03     .note.gnu.build-id
   04     .eh_frame_hdr
   05
   06     .init_array .fini_array .jcr .dynamic .got



（7） 查看lib1.so的GOT节、PLT节，截图并解释每项。
跨模块的数据访问，依赖got表；跨模块的函数访问，依赖got.plt表。
$objdump -s -j .got lib1.so
Contents of section .got:
 1fe8 00000000 00000000 00000000 00000000  ................
 1ff8 00000000 00000000                    ........
$objdump -s -j .got.plt lib1.so
Contents of section .got.plt:
 2000 081f0000 00000000 00000000 f6030000  ................
 2010 06040000                             ....
$objdump -d -j .plt.got lib1.so
00000410 <.plt.got>:
 410:   ff a3 f0 ff ff ff   	jmp  	*-0x10(%ebx)
 416:   66 90          	xchg 	%ax,%ax
 418:   ff a3 f4 ff ff ff   	jmp  	*-0xc(%ebx)
 41e:   66 90            	xchg  	%ax,%ax
$objdump -d -j .plt lib1.so
000003e0 <bar@plt-0x10>:
 3e0:   ff b3 04 00 00 00       pushl  0x4(%ebx)
 3e6:   ff a3 08 00 00 00       jmp    *0x8(%ebx)
 3ec:   00 00                	add    %al,(%eax)
        ...
000003f0 <bar@plt>:
 3f0:   ff a3 0c 00 00 00   jmp    *0xc(%ebx)
 3f6:   68 00 00 00 00    	push  	$0x0
 3fb:   e9 e0 ff ff ff        	jmp   	3e0 <_init+0x30>
00000400 <ext@plt>:
 400:   ff a3 10 00 00 00 	jmp  	*0x10(%ebx)
 406:   68 08 00 00 00  	push  	$0x8
 40b:   e9 d0 ff ff ff      	jmp 	3e0 <_init+0x30>

（8）查看lib1.so中符号 a、b、ext的表示。


（9）查看lib2.so的GOT节、PLT节和程序头表，截图并解释每项。
$objdump -s -j .got lib2.so
Contents of section .got:
 1fe8 00000000 00000000 00000000 00000000  ................
 1ff8 00000000 00000000                    ........
$objdump -s -j .got.plt lib2.so
Contents of section .got.plt:
 2000 201f0000 00000000 00000000            ...........
$objdump -d -j .plt lib2.so
000003a0 <.plt>:
 3a0:   ff b3 04 00 00 00  	pushl	0x4(%ebx)
 3a6:   ff a3 08 00 00 00  	jmp 	*0x8(%ebx)
 3ac:   00 00             	add 	%al,(%eax)
$objdump -d -j .plt.got lib2.so
000003b0 <.plt.got>:
 3b0:   ff a3 f0 ff ff ff    	jmp  	*-0x10(%ebx)
 3b6:   66 90          	xchg 	%ax,%ax
 3b8:   ff a3 f4 ff ff ff  	jmp   	*-0xc(%ebx)
 3be:   66 90        	xchg 	%ax,%ax

（10）查看可执行文件14的GOT节、PLT节和程序头表，截图并解释每项。
$objdump -s -j .got 14
14:     file format elf32-i386
Contents of section .got:
 8049ffc 00000000 
$objdump -s -j .got.plt 14

Contents of section .got.plt:
 804a000 049f0408 00000000 00000000 16840408  	................
 804a010 26840408                             		&...
$objdump -d -j .plt 14
08048420 <foo@plt>:
 8048420:       ff 25 10 a0 04 08	jmp    *0x804a010
 8048426:       68 08 00 00 00  	push   $0x8
 804842b:       e9 d0 ff ff ff       	jmp    8048400 <_init+0x28>
$objdump -d -j .plt.got 14
08048430 <.plt.got>:
 8048430:       ff 25 fc 9f 04 08  	Jmp    *0x8049ffc
 8048436:       66 90            xchg   %ax,%ax
$objdump -d -j .plt.got 14
Elf file type is EXEC (Executable file)
Entry point 0x8048440
There are 9 program headers, starting at offset 52
Program Headers:
  Type           Offset   VirtAddr   PhysAddr   FileSiz MemSiz  Flg Align
  PHDR           0x000034 0x08048034 0x08048034 0x00120 0x00120 R E 0x4
  INTERP         0x000154 0x08048154 0x08048154 0x00013 0x00013 R   0x1
      [Requesting program interpreter: /lib/ld-linux.so.2]
  LOAD           0x000000 0x08048000 0x08048000 0x006d8 0x006d8 R E 0x1000
  LOAD           0x000ef8 0x08049ef8 0x08049ef8 0x00124 0x00128 RW  0x1000
  DYNAMIC        0x000f04 0x08049f04 0x08049f04 0x000f8 0x000f8 RW  0x4
  NOTE           0x000168 0x08048168 0x08048168 0x00044 0x00044 R   0x4
  GNU_EH_FRAME   0x0005e0 0x080485e0 0x080485e0 0x0002c 0x0002c R   0x4
  GNU_STACK      0x000000 0x00000000 0x00000000 0x00000 0x00000 RW  0x10
  GNU_RELRO      0x000ef8 0x08049ef8 0x08049ef8 0x00108 0x00108 R   0x1
 Section to Segment mapping:
  Segment Sections...
   00
   01     .interp
02     .interp .note.ABI-tag .note.gnu.build-id .gnu.hash .dynsym .dynstr .gnu.version .gnu.version_r .rel.dyn .rel.plt .init .plt .plt.got .text .fini .rodata .eh_frame_hdr .eh_frame
   03     .init_array .fini_array .jcr .dynamic .got .got.plt .data .bss
   04     .dynamic
   05     .note.ABI-tag .note.gnu.build-id
   06     .eh_frame_hdr
   07
   08     .init_array .fini_array .jcr .dynamic .got

（11）查看可执行文件14中foo在GOT节、PLT节的记录。

（12）查看可执行文件14中foo在.dynamic节的记录。
$readelf -d 14
Dynamic section at offset 0xf04 contains 26 entries:
  Tag        Type            	Name/Value
 0x00000001 (NEEDED)   	Shared library: [./lib1.so]
 0x00000001 (NEEDED)         	Shared library: [./lib2.so]
 0x00000001 (NEEDED)         	Shared library: [libc.so.6]
 0x0000000c (INIT)             	0x80483d8
 0x0000000d (FINI)            	0x80485c4
 0x00000019 (INIT_ARRAY)      	0x8049ef8
 0x0000001b (INIT_ARRAYSZ)    	4 (bytes)
 0x0000001a (FINI_ARRAY)       	0x8049efc
 0x0000001c (FINI_ARRAYSZ)     	4 (bytes)
 0x6ffffef5 (GNU_HASH)        	0x80481ac
 0x00000005 (STRTAB)          	0x80482b8
 0x00000006 (SYMTAB)          	0x80481e8
 0x0000000a (STRSZ)            	203 (bytes)
 0x0000000b (SYMENT)         	16 (bytes)
 0x00000015 (DEBUG)         	0x0
 0x00000003 (PLTGOT)          	0x804a000
 0x00000002 (PLTRELSZ)       	16 (bytes)
 0x00000014 (PLTREL)         	REL
 0x00000017 (JMPREL)    	0x80483c8
 0x00000011 (REL)        	0x80483c0
 0x00000012 (RELSZ)          	8 (bytes)
 0x00000013 (RELENT)         	8 (bytes)
 0x6ffffffe (VERNEED)            	0x80483a0
 0x6fffffff (VERNEEDNUM)      	1
 0x6ffffff0 (VERSYM)            	0x8048384
 0x00000000 (NULL)            	0x0
NEEDED表示需要的库的名称、SYMTAB表示动态链接符号表.dynsym的地址、STRTAB表示动态链接字符串表.dynastr的地址等 。.dynamic段中保存的信息比较像ELF文件头，只是静态链接时相关的内容换成了动态链接下使用的相应信息。


（13）查看可执行文件14中foo在.dynsym节的记录。
$readelf --dyn-sym 14
Symbol table '.dynsym' contains 13 entries:
   Num:    Value  Size Type    Bind   Vis      Ndx Name
     0: 00000000     0 NOTYPE  LOCAL  DEFAULT  UND
     1: 00000000 0 NOTYPE  WEAK   DEFAULT  UND _ITM_deregisterTMCloneTab
     2: 00000000 0 NOTYPE  WEAK   DEFAULT  UND __gmon_start__
     3: 00000000 0 FUNC    GLOBAL DEFAULT  UND __libc_start_main@GLIBC_2.0 
     4: 00000000 0 FUNC    GLOBAL DEFAULT  UND foo
     5: 00000000 0 NOTYPE  WEAK   DEFAULT  UND _Jv_RegisterClasses
     6: 00000000 0 NOTYPE  WEAK   DEFAULT  UND _ITM_registerTMCloneTable
     7: 0804a01c 0 NOTYPE  GLOBAL DEFAULT   25 _edata
     8: 0804a020 0 NOTYPE  GLOBAL DEFAULT   26 _end
     9: 080485dc 4 OBJECT  GLOBAL DEFAULT   16 _IO_stdin_used
    10: 0804a01c 0 NOTYPE  GLOBAL DEFAULT   26 __bss_start
    11: 080483d8 0 FUNC    GLOBAL DEFAULT   11 _init
12: 080485c4 0 FUNC    GLOBAL DEFAULT   15 _fini

（14）查看可执行文件14中foo在重定位节的记录。
$readelf -r 14
Relocation section '.rel.dyn' at offset 0x3c0 contains 1 entries:
 Offset     Info    Type                Sym.Value  Sym. Name
08049ffc  00000206 R_386_GLOB_DAT    00000000   __gmon_start__

Relocation section '.rel.plt' at offset 0x3c8 contains 2 entries:
 Offset     Info    Type                Sym.Value  Sym. Name
0804a00c  00000307 R_386_JUMP_SLOT   00000000   __libc_start_main@GLIBC_2.0
0804a010  00000407 R_386_JUMP_SLOT   00000000   foo
动态链接也需要重定位也有重定位表，即.rel.dyn及.rel.plt。其中.rel.dyn是对数据引用的修正，用于修正.got及数据段；.rel.plt是对函数引用的修正，用于修正.got.plt。重定位表的表项按Elf32_Rel 定义，
typedef struct{
    Elf32_Addr r_offset;
    Elf32_Word r_info;
}Elf32_Rel;
其中r_info的高24位表示这个动态符号在动态链接符号表.dynsym中的位置，r_info的低8位表示这个待重定位对象的重定位类型。

(15)可执行文件14引用了lib1.so中的foo函数。可执行文件14是怎么定位到foo函数的？
08048420 <foo@plt>:
 8048420:       ff 25 10 a0 04 08	jmp    *0x804a010
 8048426:       68 08 00 00 00  	push   $0x8
 804842b:       e9 d0 ff ff ff       	jmp    8048400 <_init+0x28>

08048400 <__libc_start_main@plt-0x10>:
 8048400:       ff 35 04 a0 04 08 	pushl	0x804a004
 8048406:       ff 25 08 a0 04 08	jmp  	*0x804a008
 804840c:       00 00           	add 	%al,(%eax)
有了两个参数0x8、0x804a004 _dl_fixup就可以找到foo在lib1.so中的地址。0x8是push之后的整数，是这个外部函数在.rel.plt中偏移量。.rel.plt是一个结构数组，sizeof(Elf32_Rel)=8。第一个结构偏移是0，第二个地址偏移就是0x8，第三个就是0x10,所以每两个整数之间差8。当_dl_fixup返回时，该地址已经保存在了eax中。
怎么知道0x804a004是lib1.so？


3.3.5.2. 动态链接过程
输入以下源代码14-2.c：
#include<stdio.h>
int sum(int a，int b) {
    return a+b;
}
int main(){
    int i = 1;
    int j = 2;
    int k = 0;
    k = sum(i，j);
    printf("%d\n"，k);
    printf("%d\n"，k);//这里使用两次printf，方便调用查看 GOT表
    return 0;
}
(1)进行编译，不加任何优化，查看反汇编代码：
08048418 <main>:
 8048418:	8d 4c 24 04        	lea    0x4(%esp),%ecx
 804841c:	83 e4 f0           	and    $0xfffffff0,%esp
 804841f:	ff 71 fc             	pushl  -0x4(%ecx)
 8048422:	55              	push   %ebp
 8048423:	89 e5             	mov    %esp,%ebp
 8048425:	51               	push   %ecx
 8048426:	83 ec 14          	sub    $0x14,%esp
 8048429:	c7 45 ec 01 00 00 00 	movl   $0x1,-0x14(%ebp)
 8048430:	c7 45 f0 02 00 00 00 	movl   $0x2,-0x10(%ebp)
 8048437:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
 804843e:	ff 75 f0             	pushl  -0x10(%ebp)
 8048441:	ff 75 ec             	pushl  -0x14(%ebp)
 8048444:	e8 c2 ff ff ff       	call   804840b <sum>
 8048449:	83 c4 08          	add    $0x8,%esp
 804844c:	89 45 f4           	mov    %eax,-0xc(%ebp)
 804844f:	83 ec 08           	sub    $0x8,%esp
 8048452:	ff 75 f4             	pushl  -0xc(%ebp)
 8048455:	68 10 85 04 08       	push   $0x8048510
 804845a:	e8 81 fe ff ff       	call   80482e0 <printf@plt>
 804845f:	83 c4 10          	add    $0x10,%esp
 8048462:	83 ec 08           	sub    $0x8,%esp
 8048465:	ff 75 f4             	pushl  -0xc(%ebp)
 8048468:	68 10 85 04 08       	push   $0x8048510
 804846d:	e8 6e fe ff ff       	call   80482e0 <printf@plt>
 8048472:	83 c4 10          	add    $0x10,%esp
 8048475:	b8 00 00 00 00       	mov    $0x0,%eax
 804847a:	8b 4d fc          	mov    -0x4(%ebp),%ecx
 804847d:	c9               	leave  
 804847e:	8d 61 fc          	lea    -0x4(%ecx),%esp
 8048481:	c3               	ret    
 8048482:	66 90            	xchg   %ax,%ax
 8048484:	66 90              	xchg   %ax,%ax
 8048486:	66 90             	xchg   %ax,%ax
 8048488:	66 90            	xchg   %ax,%ax
 804848a:	66 90             	xchg   %ax,%ax
 804848c:	66 90            	xchg   %ax,%ax
 804848e:	66 90             	xchg   %ax,%ax
(2)跟踪第一个printf@plt跳转到GOT表的过程：
(gdb) disassemble printf
Dump of assembler code for function printf@plt:
   0x080482e0 <+0>:     jmp    *0x804a00c
   0x080482e6 <+6>:     push   $0x0
   0x080482eb <+11>:    jmp    0x80482d0
或者
(gdb) x/32wi 0x80482e0
   0x80482e0 <printf@plt>:      jmp    *0x804a00c
   0x80482e6 <printf@plt+6>:    push   $0x0
   0x80482eb <printf@plt+11>:   jmp    0x80482d0
这并不是真正的printf函数。这段代码的作用是到libc.so中去找真正的printf。
(gdb) x /16wx 0x804a00c
0x804a00c:      0x080482e6      0x080482f6      0x00000000      0x00000000
可以看到0x804a00c处存放的0x080482e6，是GOT表中的printf项，是pushl $0x0这条指令的地址。
# objdump -R 14-2
14-2   file format elf32-i386
DYNAMIC RELOCATION RECORDS
OFFSET   TYPE              VALUE
08049ffc R_386_GLOB_DAT    __gmon_start__
0804a00c R_386_JUMP_SLOT   printf@GLIBC_2.0
0804a010 R_386_JUMP_SLOT   __libc_start_main@GLIBC_2.0
但是此时GOT表中的内容为：
(gdb) x/32wx 0x0804a00c
0x804a00c:      0x080482e6      0xf7d79550      0x00000000      0x00000000
0x804a01c <completed.7209>:     0x00000000      0x00000000      0x00000000      0x00000000
所以第一条jmp指令没有起到任何作用，其作用就像空操作指令nop一样。当然这是在我们第一次调用printf时，其真正的作用是在今后再次调用printf时体现出来的。第二条jmp指令的目的地址是plt，也就是procedure linkage table，其内容可以通过objdump命令查看，我们感兴趣的就是下面这两条对程序的控制流有影响的指令：
因此调用关系如下图所示：

然后执行0x80482eb <printf@plt+11>: jmp 0x80482d0，跳转到0x80482d0：
(gdb) x/32wi 0x80482d0
   0x80482d0:   pushl  0x804a004
   0x80482d6:   jmp    *0x804a008
   0x80482dc:   add    %al,(%eax)
   0x80482de:   add    %al,(%eax)
   0x80482e0 <printf@plt>:      jmp    *0x804a00c
   0x80482e6 <printf@plt+6>:    push   $0x0
   0x80482eb <printf@plt+11>:   jmp    0x80482d0
第一条push指令将got(global offset table)中与printf相关的表项地址压入堆栈，之后jmp到内存单元0x804a008中所存放的地址0xf7fc8000处。这里需要注意的一点是，在查看got之前必须先将程序a.out启动运行，否则通过gdb中的x命令在0x0804a00c处看到的结果是不正确的。
然后执行完0x80482d6之后，此时的对应关系如下：

(3)跟踪GOT表并获得实际地址。
然后跳转到_dl_runtime_resolve函数：
>0xf7f9d000 <_dl_runtime_resolve>        push   %eax                                                                                                                                             
 0xf7f9d001 <_dl_runtime_resolve+1>      push   %ecx                                                                                                                                             
 0xf7f9d002 <_dl_runtime_resolve+2>      push   %edx                                                                                                                                             
 0xf7f9d003 <_dl_runtime_resolve+3>      mov    0x10(%esp),%edx                                                                                                                                  
 0xf7f9d007 <_dl_runtime_resolve+7>      mov    0xc(%esp),%eax                                                                                                                                   
 0xf7f9d00b <_dl_runtime_resolve+11>     call   0xf7f967e0 <_dl_fixup>                                                                                                                           
 0xf7f9d010 <_dl_runtime_resolve+16>     pop    %edx                                                                                                                                             
 0xf7f9d011 <_dl_runtime_resolve+17>     mov    (%esp),%ecx                                                                                                                                      
 0xf7f9d014 <_dl_runtime_resolve+20>     mov    %eax,(%esp)                                                                                                                                      
0xf7f9d017 <_dl_runtime_resolve+23>     mov    0x4(%esp),%eax                                                                                                                                   
 0xf7f9d01b <_dl_runtime_resolve+27>     ret    $0xc                                                                                                                                             
将0x0存入edx，0x804a004存入eax，有了这两个参数，_dl_fixup就可以找到printf在libc.so中的地址。当_dl_fixup返回时，该地址已经保存在了eax中。这里ret实际上被当成了call来使用。ret $0x8之后控制便转移到了真正的printf函数那里，并且清掉了堆栈上的0x0和0x804a004这两个已经没用的参数。
直接到达第二个printf前。查看堆栈情况，发现printf的GOT表中的内容已经变成实际地址：
(gdb) x/32wx 0x0804a00c
0x804a00c:      0xf7daa680      0xf7d79550      0x00000000      0x00000000
0x804a01c <completed.7209>:     0x00000000      0x00000000      0x00000000      0x00000000

(4)再次调用printf函数时，流程变为：



3.3.5.3. 动态加载共享库
编写以下程序14-3-1.c：
//14-3-1.c
#include <sys/types.h>
#include <signal.h>
#include <stdio.h>
#include <unistd.h>
typedef struct {
const char *module;
int  (*GetValue)(char *pszVal);
int   (*PrintfHello)();
}hello_ST_API;
 
int GetValue(char *pszVal){
int retval = -1; 
if (pszVal)
retval = sprintf(pszVal, "%s", "123456");
printf("%s, %d, pszVer = %s\n",  __FUNCTION__, __LINE__, pszVal);
return retval;
}
 
int PrintfHello(){
int retval = -1;
printf("%s, %d, hello everyone\n", __FUNCTION__, __LINE__);
return 0;
}
 
const hello_ST_API  Hello = {
.module = "hello",
GetValue,
PrintfHello,
};
编写调用函数的文件14-3-2.c：
//14-3-2.c
#include <sys/types.h>
#include <signal.h>
#include <stdio.h>
#include <unistd.h>
#include <dlfcn.h>
typedef struct {
const char *module;
int  (*GetValue)(char *pszVal);
int   (*PrintfHello)();
}hello_ST_API;
 
int main(int argc， char **argv){
hello_ST_API *hello;
int i = 0;
void *handle;
char psValue[20] = {0};
handle = dlopen("/opt/mylinux16/hello.so", RTLD_LAZY);
if (! handle) {
printf("%s, %d, NULL == handle\n", __FUNCTION__, __LINE__);
return -1;
}
dlerror();
hello = dlsym(handle, "Hello");
if (!hello) {
printf("%s, %d, NULL == handle\n", __FUNCTION__, __LINE__);
return -1;
}
if (hello && hello->PrintfHello)
i = hello->PrintfHello();
printf("%s, %d, i = %d\n", __FUNCTION__, __LINE__, i);
if (hello && hello->GetValue)
i = hello->GetValue(psValue);
if (hello && hello->module)
printf("%s, %d, module = %s\n", __FUNCTION__, __LINE__, hello->module);
dlclose(handle);
return 0;
}
(1)将14-3-1.c编译成共享库lib1431.so：
$gcc -shared -fPIC 14-3-1.c -o lib1431.so

(2)将14-3-2.c编译成主程序：
$gcc -o 14-3-2 14-3-2.c -ldl

(3)正确运行主程序，解释其输出。
思考题：
如果一个共享库对象 lib1.so中定义了一个全局变量，而进程Ａ和进程Ｂ都使用了此共享库。注意观察14-1-1.c生成的 lib1.so中的b和14-1-2.c生成的 lib2.so中的b的异同。当进程Ａ改变这个全局变量时，进程Ｂ中的这个全局变量会受到影响么？

加载器

4.1可执行文件的加载
当启动一个可执行目标文件执行时，首先会通过某种方式调出常驻内存的一个称为加载器 (loader) 的操作系统程序来进行处理。例如，任何 UNIX 程序的加载执行都是通过调用 execve 系统调用函数来启动加载器进行的。加载器根据可执行目标文件中的程序头表信息，将可执行 目标文件中相关节的内容与虚拟地址空间中的只读代码段和可读写数据段通过页表建立映射， 然后启动可执行目标文件中的第一条指令执行。
对于特定的系统平台，每个可执行目标文件在运行时的存储器映像是确定的。如图4-1所示是Linux系统中可
执行目标文件的存储器映像。



图 4-1 Linux 下可执行目标文件运行时的存储器映像

将图 4-1与第 6 章的图 6. 30 比较，可以看出这里的存储器映像是指可执行目标文件中的 代码段
和数据段在虚拟地址空间中的映射关系。在图 4. 6 所示的可执行目标文件的程序头表 中，记录了可执行目标文件中所有存储段的相关信息，如存储段类型、段在虚拟地址空间中的 起始地址、长度、对齐方式、访问权限等。其中，只读代码段（简称为只读段）和可读写数 据段（简称为读/写段）都是可装入段（PT_LOAD）,从图 4-1可看出，只读段（包括.init 节、.text 节和.rodata 节）总是映射到虚拟地址为 0x08048000 开始的一段区域，可读写数据段（包括.data 节和.bss 节）则映射到只读段后面按 4KB 对齐的高地址上，其中.bss 节所在存储区 在运行时被初始化为 0。运行时堆（run-time heap）则在可读写数据段后面 4KB 对齐的高地址 处，通过调用 malloc 库函数动态向高地址分配空间，而运行时的用户栈（user stack）则是从用 户空间的最大地址往低地址方向增长。堆区和栈区中间有一块空间保留给共享库目标代码，栈 区以上的高地址区是操作系统内核的虚拟存储区。
每个可执行目标文件都釆用如图 4-1 所示的存储器映像方式，映射到一个统一的虚拟地 址空间上， 使得链接器在重定位时可以完全按照一个统一的虚拟存储空间来确定每个符号的地 址，而不用管其数据和代码将来存放在主存或磁盘的何处。因此，引入虚拟存储管理简化了链 接器的设计和实现。
同样，引入虚拟存储管理也简化了程序加载过程。因为统一的虚拟地址空间映像使得每个 可执行目标文件的只读代码段都映射到 0x08048000 开始的一块连续区域，可读写数据段映射 到虚拟地址空间中的一块连续区域，因而加载器可以非常容易地对这些连续区域进行分页，并 初始化相应页表项的内容。加载时，只读代码段和可读写数据段对应的页表项都被初始化为 “未缓存页”（即有效位为 0）,并指向磁盘中可执行目标文件中适当的地方。因此，程序加载 过程中，实际上并没有真正从磁盘上加载代码和数据到主存，而是仅仅创建了只读代码段和可 读写数据段对应的页表项。只有在执行代码过程中发生了 " 缺页"异常，才会真正从磁盘加载代码和数据到主存。有关虚拟存储管理、虚拟地址空间、页表、缺页异常等相关内容见第 6 章的 6. 5节。

4.2程序加载时的动态链接
在类 UNIX 系统中，共享库文件使用.so 后缀。例如，标准 C 函数库文件名为 libc.so0 用户 也可以自定义一个动态共享库文件。例如，对于图 4. 13 所示的两个源程序文件 myprocl.c 和 myproc2.c,可以使用以下 GCC 命令生成动态链接的共享库 mylib.so。
gcc - shared - fPIC - o myl ib . so myprocl.c myproc2 .c

上述命令中-shared 选项告诉链接器生成一个共享库目标文件；-fPIC 选项告诉编译器生成与位置无关的代码(Position Independent Code, PIC),使得共享库在被任何不同的程序引用时 都不需要修改其代码。这保证了共享库代码的存储位置可以是不确定的，而且即使共享库代码 的长度发生改变也不会影响调用它的程序。
假定有一个 main.c 程序，其中调用了 mylib.so 中的函数 myfunclo
void myfuncl(void)
int main()
{
Myfuncl();
Return 0;
}
为了生成可执行目标文件 myproc,可以先将 main.c 编译并汇编为可重定位目标文件 main.o,然后再将 main.o 和 mylib.so 以及标准 C 函数共享库 libc.so 进行链接。以下命令可以完 成上述功能：
gcc - o myproc mai n .c ./mylib.so
通过上述命令得到可执行目标文件 myproc,这个命令与静态链接命令“gcc - static - o myproc main.c mylib.a"的执行过程不同。静态链接生成的可执行目标文件在加载后可以直接运 行，因为所有外部函数都已包含在可执行目标文件中。而动态链接生成的可执行目标文件不能 运行，这是因为在动态链接生成可执行目标文件时，其中对外部函数的引用地址是未知的。因 此，在动态链接生成的可执行目标文件运行前，系统会首先将动态链接器以及所使用的共享库 文件加载到内存。动态链接器和共享库文件的路径都包含在可执行目标文件中，其中，动态链接器由加载器加载，而共享库由动态链接器加载。

图 4-1 给出了动态链接的全过程。整个过程被分成两步：首先，进行静态链接以生成部分链接的可执行目标文件 myproc,该文件中仅包含共享库(包括指定的共享目标文件 mylib.So 和默认的标准共享库文件libc.so)中的符号表和重定位表信息，而共享库中的代码和数据并没有被合并到 myproc 中；然后，在加载mypmc 时，由加载器将控制权转移到指定的动态链接器，由动态链接器对共享目标文件 libc.so、mylib.so 和myproc 中的相应模块内的代码和数据进行重定位并加载共享库，以生成最终的存储空间中完全链接的可执行目标，在完成重定位和加载共享库后，动态链接器把控制权转移到程序 myproc。在执行 myproc 的过程中，共享库中的代码和数据在存储空间的位置一直是固定的。
在上述过程中，有一个重要的问题是，如何在加载过程中将控制权从加载器转移到动态链接器？参看图 4-1 可以发现，在可执行目标文件的程序头表中有一个 Type = INTERP 的段。因此，这个问题的解决可通过在可执行目标文件 myproc 中加入一个 特殊的.interp 节来实现。当加载 myproc 时，加载器会发现在 myproc 的程序头表中包含了 .interp 节构成的段，其 p_type 字段取值为 PTJNTERP,该节中包含了动态链接器的路径名，而动态链 接器本身也是一个共享目标，在 Linux 系统中为 ld-linuxso,因而可以由加载器根据指定的路径 来加载并启动动态链接器运行。动态链接器完成相应的重定位工作后再把控制权交给 myproc, 启动其第一条指令执行。

4.3程序运行时的动态链接


图 4. 2 描述的是在程序被加载时对共享库进行动态链接的过程，实际上，共享库也可以 在程序运行过程中进行动态链接。在一些类 UNIX 系统中，提供了一个动态链接器接口，其中 定义了相应的几个函数，如 dlopen、dlsym、dierror、dlclose 等，其头文件为 dlfcn.h。以下给出 一个例子，用以说明如何在应用程序中使用动态链接器接口函数对共享库进行动态链接。
图 4. 2 给出了一个运行时进行动态链接的应用程序示例 main.c。对于由图 4. 13 所示的两 个源程序文件 myprocl.c 和 myproc2.c 生成的共享库 mylib.so,在 main.c 中调用了共享库 mylib.so中的函数 myfuncl 0 要编译该程序并生成可执行文件 myproc,通常用以下 GCC 命令：

gcc - rdynamic -o myproc main .c - Idl

选项-rdynamic 指示链接器在链接时使用共享库中的函数，选项-Idl 说明采用动态链接器接 口中
的dlopen、dlsym 等函数进行运行时的动态链接。
如图 4.2中源程序 main.c 所示，一个应用程序如果要在运行时动态链接一个共享库并引 用库中的函数或变量，则必须经过以下几个步骤。
首先，通过 dlopen 函数加载和链接共享库，如图 4. 22 中第 10 行所示。第 10 行的含义 是启动动态链接器来加载并链接当前目录中的共享库文件 mylib.so, 这里 dlopen 函数的第二个 参数为RTLD_LAZY,用来指示链接器对共享库中外部符号的解析时间推迟到执行库中代码时。若 dlopen 函数出错， 则返回值为 NULL；否则返回指向共享库文件句柄的指针。
在 dlopen 函数正常返回的情况下，通过 dlsym 函数获取共享库中所需函数。如图 4. 22 中第17 行所示。第 17 行的含义是指示动态链接器返回指定共享库 mylihso 中指定符号 myfuncl 的地址。若指定共享库中不存在指定的符号，则返回 NULL。dlsym 函数的第一个参数是指定共 享库的文件句柄，第二个参数用来标识指定符号的字符串，通常是后面将要使用的函数的函 数名。
 dlsym 函数正常返回的情况下，就可以使用共享库中的函数，如图 4. 22 中第 24 行所 示。函数对应代码的首地址由 dlsym 函数返回。
在使用完程序所需的所有共享库内函数或变量后，使用 dlclose 函数卸载这个共享库。如图 4. 22
中第 27 行所示。若卸载成功，返回为 0,否则为-1。
若调用 dlopen、dlsym 和 dlclose 时发生出错，则岀错信息可通过调用 dleiror 函数获得。
